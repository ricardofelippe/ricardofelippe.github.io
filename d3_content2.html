<!DOCTYPE html>
<html>
<head>


</head>

<body>

<h3 id="lesson57">Introduction to HTML <h3>
    <div>
     <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>D3 provides a variety of Layout helpers so you don't have to do complicate math or algorithmic computation</li>
<li>The D3 Layout - Stack Layout calculates, given a data set, the coordinates for each layer of the stack</li>
<li>To pass data into the D3 Layout Stack Layout, you have to pass in an array of arrays where each internal array represents a layer and every layer will have an array of objects that have the x and y key value pair defined for the x-position and y-thickness of the layer</li>
<li>Because you have to construct the data structure to pass into the D3 Layout Stack Layout, it's important to understand how to build nested data structures using .forEach, .map, and how to construct arrays of objects on the fly</li>
<li>When constructing the data structure to pass into the D3 Layout Stack Layout, it's important to keep data out of the keys of the key value pairs of the objects</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-bar-chart">Basic Chart - Bar Chart</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-grouped-bar-chart">Basic Chart - Grouped Bar Chart</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-stacked-bar-chart">Basic Chart - Stacked Bar Chart</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-pie-chart">Basic Chart - Pie Chart</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 Layout - Stack Layout
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
D3 Layout - Stack Layout
</strong>
</p>
<br>
<p>
D3 provides the various Layout helpers you can see on the screen.
</p>
<p>
[ Image: Image of D3 Layouts on the D3 API page ]
</p>
<p>
D3 Layout Helpers help do the calculations to make specific types of Graphs.
</p>
<p>
For instance - for the pie chart, rather than having to calculate the start and end angles of the arcs, you can pass data to this helper and it will figure it out for you.
</p>
<p>
The D3 layout helpers basically help do the heavy math lifting for you in the background, so you don't need to worry about doing the math.
</p>
<p>
This video is going to cover the D3 Layout Stack Layout.
</p>
<p>
We will walk through some example code to get a feel for how it works and then we will build a simple example of a Stacked Bar Chart using the Stack Layout.
</p>
<br>
<p>
On the Screen is the stacked bar chart we will be working towards.
</p>
<p>
[ Image: Image of Stacked Bar Chart of Fruits Consumed per type of fruit across four seasons ]
</p>
<p>
On the Y axis you can see the numbers 0 to 7 representing the total number of fruits eaten.
</p>
<p>
On the X axis you can see the four seasons of the year - spring, summer, fall and winter.
</p>
<p>
The three types of fruits are grapes, kiwis and apples.
</p>
<br>
<p>
We focus in on the fall bar.
</p>
<p>
[ Image: Image of Stacked Bar Chart of Fruits Consumed per type of fruit for only the Fall ]
</p>
<p>
We can see that the red rectangle is at the bottom.
</p>
<p>
Then the green rectangle is in the middle.
</p>
<p>
And lastly, the purple rectangle is at the top.
</p>
<br>
<p>
On the screen we have 3 coordinate points for the 3 colored rectangles.
</p>
<p>
[ Image: Image of Stacked Bar Chart of Fruits Consumed per type of fruit for only the Fall ]
</p>
<p>
SCREEN - Add coordinates to top left corners for each rectangle (Xa, Ya) , (Xk, Yk) , (Xg, Yg)
</p>
<p>
Recall that SVG rectangles are drawn from the top-left coordinate.
</p>
<p>
The purple rectangle has a top-left coordinate of Xg and Yg.
</p>
<p>
The green rectangle has a top-left coordinate of Xk and Yk.
</p>
<p>
The red rectangle has a top-left coordinate of Xa and Ya.
</p>
<br>
<p>
Looking at only the fall stacked bar, we examine the X coordinates.
</p>
<p>
[ Image: Image of Stacked Bar Chart of Fruits Consumed per type of fruit for only the Fall ]
</p>
<p>
SCREEN - Add coordinates to top left corners for each rectangle (Xa, Ya) , (Xk, Yk) , (Xg, Yg)
</p>
<p>
SCREEN - Add Equations for X's (Xg = Xk = Xa)
</p>
<p>
The X coordinates for all three rectangles are the same.
</p>
<p>
This makes sense
</p>
<p>
If they are stacked on top of each other, then the X coordinates need to be the same.
</p>
<br>
<p>
Looking at only the fall stacked bar, we examine the Y coordinates.
</p>
<p>
[ Image: Image of Stacked Bar Chart of Fruits Consumed per type of fruit for only the Fall ]
</p>
<p>
SCREEN - Add coordinates to top left corners for each rectangle (Xa, Ya) , (Xk, Yk) , (Xg, Yg)
</p>
<p>
SCREEN - Add Equations for Y's
        Ya = height of Red Rectangle
        Yk = height of Red Rectangle +
             height of Green Rectangle
        Yg = height of Red Rectangle +
             height of Green Rectangle +
             height of Purple Rectangle             
</p>
<p>
The Y coordinates are more complicated.
</p>
<p>
This is because we are stacking the rectangles on top of each other.
</p>
<p>
There are two things we need to pay attention to:
</p>
<p>
One - Where the rectangle below ended.
</p>
<p>
Two - What the height is of the current rectangle.
</p>
<p>
On the screen you can see the equations that will give us the correct Y coordinates.
</p>
<p>
The height of the Red Rectangle gives us the Ya.
</p>
<p>
The height of the green and red rectangles give us the Yk.
</p>
<p>
The height of the purple, green and red rectangles give us the Yg.
</p>
<br>
<p>
We can even simplify the equations so that all equations have 1 or 2 terms.
</p>
<p>
[ Image: Image of Stacked Bar Chart of Fruits Consumed per type of fruit for only the Fall ]
</p>
<p>
SCREEN - Add coordinates to top left corners for each rectangle (Xa, Ya) , (Xk, Yk) , (Xg, Yg)
</p>
<p>
SCREEN - Add Equations for Y's
<br>
Ya = height of Red Rectangle
<br>
Yk = Ya + height of Green Rectangle
<br>
Yg = Yk + height of Purple Rectangle
</p>
<p>
This makes it easier to think about as well as easier to calculate.
</p>
<p>
If we were going to build a stacked bar chart we would have to do these types of calculations manually.
</p>
<p>
As we shall cover shortly, the D3 Layout - Stack Layout will do this for us.
</p>
<br>
<p>
Let's look at the goal again.
[ Image: Image of Stacked Bar Chart of Fruits Consumed per type of fruit for all seasons ]
</p>
<p>
We just covered the perspective of looking at the stacked bars as individual bars that are stacked.
</p>
<p>
Another way to look at the stacked bar chart on the screen is to look at the chart as a series of layers that sit on top of each other.
</p>
<p>
The first layer is the red layer at the bottom.
</p>
<p>
The second layer is the green layer in the middle.
</p>
<p>
and the third layer is the purple layer on the top.
</p>
<br>
<p>
Continuing to think in this new perspective about layers, let's take a look at the kiwi layer.
</p>
<p>
[ Image: Image of Stacked Bar Chart of Fruits Consumed per type of fruit for only one type of fruit (Kiwi) ]
</p>
<p>
SCREEN - Add coordinates to top left corners for one rectangle (X, Y)
</p>
<p>
SCREEN - Add coordinates to bottom left corners for one rectangle (X, Y0)
</p>
<p>
When we think about how to place the rectangles now - we have to think about how to place them in space.
</p>
<p>
We have to think about the top-left corner coordinates as well as the bottom-left coordinates.
</p>
<p>
The bottom-left coordinates describe the base-line of the rectangle.
</p>
<p>
The top-left coordinates describes how far up from the base-line the layer has propagated.
</p>
<br>
<p>
When we think about the layers like this, we are starting to think in terms of the Stack Layout.
</p>
<p>
[ Image: Image of Stacked Bar Chart of Fruits Consumed per type of fruit for only one type of fruit (Kiwi) ]
</p>
<p>
SCREEN - Draw arrow to bottom of last with a single word - Base-line.
</p>
<p>
SCREEN - Drawn arrow to top of last rectangles with phrase - Propagation Distance from Base-line
</p>
<p>
Once we are thinking how to stack layers on top of layers, we can stack layers vertically, horizontally or even radially.
</p>
<br>
<p>
D3 dot layout dot stack constructs a new stack layout.
</p>
<p>
<pre><code class="javascript">d3.layout.stack()</code></pre>
</p>
<p>
This new construct is both an object and a function.
</p>
<p>
We can call the layout like a function.
</p>
<p>
As well as use methods to change the behavior of the layout.
</p>
<br>
<p>
To pass data into the stack layout, we have to pass in an array of arrays.
</p>
<p>
<pre><code class="javascript">d3.layout.stack()(layers[, index])

// layers = [ [...], [...], [...] ]

// layer = [ {...}, {...}, {...}, {...} ]

// object = { "x":..., "y":..., ... }</code></pre>
</p>
<p>
Each internal array will represent a layer.
</p>
<p>
Each layer will be an array of objects.
</p>
<p>
Each object should have an x and y key,value pair to define the x-position and the y-thickness of the layer.
</p>
<br>
<p>
What the D3 layout helper does is compute a y0 for each object which is the base-line of the layer given the previous layers in the data.
</p>
<p>
<pre><code class="javascript">d3.layout.stack()(layers[, index])

// layers = [ [...], [...], [...] ]

// layer = [ {...}, {...}, {...}, {...} ]

// object = { "x":..., "y":..., "y0":..., .... }</code></pre>
</p>
<br>
<p>
This is an example of two layers.
</p>
<p>
<pre><code class="javascript">layer_one = [{"x": 1, "y": 2}, {"x": 4, "y": 8}];

layer_two = [{"x": 1, "y": 4}, {"x": 4, "y": 15}];</code></pre>
</p>
<p>
The numbers are not related to our final goal - they were generated to show this example.
</p>
<p>
Each layer array is an array that contains two JavaScript Literal Objects.
</p>
<p>
Each object has an X key and a Y key.
</p>
<p>
Remember that Y is defined as the thickness of the layer of this object.
</p>
<br>
<p>
We define the variable layers as an array of individual layers.
</p>
<p>
<pre><code class="javascript">layer_one = [{"x": 1, "y": 2}, {"x": 4, "y": 8}];     // ** DIM **

layer_two = [{"x": 1, "y": 4}, {"x": 4, "y": 15}];    // ** DIM **

layers = [layer_one, layer_two];

d3.layout.stack()(layers);</code></pre>
</p>
<p>
When we pass in this layers data, the D3 layout helper will compute a Y0 for each object and add it to the object.
</p>
<p>
This Y0 is the baseline we will use when drawing the rectangles later.
</p>
<p>
Let's take a look at the JavaScript console to make this less abstract.
</p>
<br>
<p>
This web page has the D3 library imported from the d3js.org website.
</p>
<br>
<p>
We have opened the Chrome Developer Tools and are in the Console Section.
</p>
<br>
<p>
First we type in the two data layers.
</p>
<p>
<pre><code class="javascript">layer_one = [{"x": 1, "y": 2}, {"x": 4, "y": 8}];

layer_two = [{"x": 1, "y": 4}, {"x": 4, "y": 15}];</code></pre>
</p>
<br>
<p>
Then we combine the two layers into an array of layers.
</p>
<p>
<pre><code class="javascript">layers = [layer_one, layer_two];</code></pre>
</p>
<br>
<p>
Let's expand the array to see the data
</p>
<p>
BROWSER - click into each array and all the objects.
</p>
<p>
We can see that the first array and first object has an x of 1 and a y of 2.
</p>
<p>
We can see that the second array and first object has an x of 1 and y of 4.
</p>
<p>
Because they have the same X, we know that these two objects would be stacked on top of each other.
</p>
<p>
Rather than doing the math and figuring out where the new baseline will be.
</p>
<p>
Let's get the D3 Stack Layout to help us.
</p>
<br>
<p>
We construct the D3 Stack Layout.
</p>
<p>
<pre><code class="javascript">var stack = d3.layout.stack();</code></pre>
</p>
<p>
We assign the result to the variable stack.
</p>
<p>
The variable stack is now an object and a function.
</p>
<br>
<p>
Let's use it as function and pass in the layers data.
</p>
<p>
<pre><code class="javascript">stack(layers);</code></pre>
</p>
<p>
The D3 Stack Layout modifies the arrays and objects in place.
</p>
<p>
Which means that we do not need to assign the result to a new variable. 
</p>
<br>
<p>
Let's open up the layers array of arrays now and take a look at the data in each object.
</p>
<p>
BROWSER - open the result
</p>
<p>
You can see that the two arrays are still there.
</p>
<p>
You can also see that each array contains two objects.
</p>
<p>
What is new is that in each object we now have a key,value pair for the key of y0.
</p>
<p>
Let's look at the first array.
</p>
<p>
The Y0 is 0 for both objects.
</p>
<p>
This is because the baseline for this layer will be 0 since it is the first layer.
</p>
<p>
Let's look at the second array now.
</p>
<p>
The Y0 is not 0 for either object.
</p>
<p>
In fact it's different numbers for each object in the second array.
</p>
<p>
This is because this is the second layer so it will start where the first layer ended.
</p>
<p>
We can verify this by looking at the Y of the first object in the first array and the Y0 of the first object in the second array.
</p>
<p>
We can see that the y0 of the first object in the second array is 2 - which is the same as the Y of the first object in the first array.
</p>
<p>
The same pattern applies to the second objects in each array.
</p>
<p>
The Y0 of the second object in the second array is 8, which is the Y of the second object in the first array.
</p>
<p>
The D3 Stack Layout kept internal track of where the last layer ended and updated the new layer to make sure it knew where the last layer ended.
</p>
<p>
We will use this when we construct our stacked bar chart.
</p>
<p>
The last thing to note is that we did not have to specify anywhere the number of layers we were passing in or the number of objects per layer.
</p>
<p>
This is powerful because we could pass in a large number of layers and a large number of objects to the layout and it would do all of the math for us.
</p>
<br>
<p>
Let's now build step by step the goal of a stacked bar chart using the D3 Stack Layout.
</p>
<br>
<br>
<p>
<strong>
Stacked Bar Chart using Stack Layout 
</strong>
</p>
<br>
<p>
On the Screen is the stacked bar chart we will be working towards.
</p>
<p>
[ Image: Image of Stacked Bar Chart of Fruits Consumed per type of fruit across four seasons ]
</p>
<p>
When working on real life projects, this should be a wire frame drawing that you would be working against.
</p>
<p>
When making data visualizations, I highly recommend drawing out the goal on paper before you start coding.
</p>
<p>
Then, when you have your idea on paper, make a small example dataset from a real data set to build the first coded version.
</p>
<p>
From this picture, we can see that will want to know the following things:
</p>
<p>
The total count of fruit per season to get the y-axis max point.
</p>
<p>
The names of the seasons.
</p>
<p>
The count of each fruit consumed.
</p>
<p>
An x-axis and y-axis.
</p>
<p>
An SVG Container.
</p>
<p>
An x scaling function and y scaling function to be able to map our values to the SVG Container.
</p>
<p>
and Individual layers for each fruit type since we are using the D3 Stack Layout.    
</p>
<br>
<p>
We start with the data set. 
</p>
<p>
<pre><code class="javascript">var fruitConsumption = [ {"season": "spring", "apple": 1, "kiwi": 4, "grape": 1},
                         {"season": "summer", "apple": 2, "kiwi": 1, "grape": 2},
                         {"season": "fall",   "apple": 3, "kiwi": 3, "grape": 1},
                         {"season": "winter", "apple": 2, "kiwi": 2, "grape": 2}];</code></pre>
</p>
<p>
We will use a hard coded variable, rather than serving a CSV or TSV from the server.
</p>
<p>
This is so that we can see the data clearly as the first step.
</p>
<p>
Our data set is comprised of four JavaScript Literal Objects in an array.
</p>
<p>
Each object has four key,value pairs.
</p>
<p>
The keys are season, apple, kiwi and grape.
</p>
<p>
The values for the season keys cover the four seasons - spring, summer, fall and winter.
</p>
<p>
The values for the individual fruit names vary from 1 to 4.
</p>
<p>
Note that we do not have a total fruit consumed key,value pair for any season.
</p>
<p>
Also note that we have data in our keys.
</p>
<p>
This should make you wince.
</p>
<p>
One very important idea when using data with D3 is that your keys should be as generic as possible and never contain any data.
</p>
<p>
The reason this dataset was constructed in this way was to make you aware of this issue.
</p>
<br>
<p>
First - figure out the season names from the data set.
</p>
<p>
<pre><code class="javascript">var seasonNames = fruitConsumption.map( function(d) { 
    return d.season;
});</code></pre>
</p>
<p>
For every object in the fruitConsumption data, we apply a function that returns the season of that object.
</p>
<p>
This creates a new array that we assign to the variable name seasonNames.
</p>
<p>
SCREEN - highlight .map
</p>
<p>
The .map functionality is an iteration method that JavaScript Arrays comes with for array manipulation.
</p>
<p>
It creates a new array with the result of a function that has been applied to every element in the array that it is being called upon.
</p>
<p>
Remember - D3's canonical way of representing any type of data is an array.
</p>
<br>
<p>
Next - figure out the names of the fruits from the data set.
</p>
<p>
<pre><code class="javascript">var fruitNames = d3.keys(fruitConsumption[0]).filter(function(key) { return key !== "season"; });</code></pre>
</p>
<p>
This code looks at the first object in the fruitConsumption array of objects.
</p>
<p>
SCREEN - highlight d3.keys
</p>
<p>
We use d3.keys to extract all the keys from the all the key,value pairs in this first object.
</p>
<p>
SCREEN - highlight .filter
</p>
<p>
Then, using this list of keys, we use the array.filter JavaScript method to create a new array with only the elements for which the conditional statement of the key not being equal to the string "season" is true.
</p>
<p>
Because we know that each object has the keys: season, apple, kiwi and grape - this filtering will return an array of the fruit names.
</p>
<br>
<p>
Next, we put right to wrong the two things we noticed about our data set earlier.
</p>
<p>
<pre><code class="javascript">fruitConsumption.forEach(function(d) {

    d.fruitsConsumed = fruitNames.map(function(name) {
        return {
            "fruitName": name,
            "consumedCount": d[name]
        };
    });

    d.totalFruit = d3.sum( d.fruitsConsumed, function(d) {
        return d.consumedCount;
    });        
});</code></pre>
</p>
<p>
One - that the keys contained data.
</p>
<p>
and Two - that we did not have a total fruit consumption count per season.
</p>
<br>
<p>
Let's look at how we fix the issue of the keys containing data.
</p>
<p>
<pre><code class="javascript">fruitConsumption.forEach(function(d) {

    d.fruitsConsumed = fruitNames.map(function(name) {  // ** HIGHLIGHT **
        return {                                        // ** HIGHLIGHT **
            "fruitName": name,                          // ** HIGHLIGHT **
            "consumedCount": d[name]                    // ** HIGHLIGHT **
        };                                              // ** HIGHLIGHT **
    });

    d.totalFruit = d3.sum( d.fruitsConsumed, function(d) {
        return d.consumedCount;
    });        
});</code></pre>
</p>
<p>
SCREEN - dim everything except highlighted bit.
</p>
<p>
SCREEN - color the fruitsConsumed word
</p>
<p>
To do that we want to create a new key,value pair inside of the fruitConsumption object.
</p>
<p>
This new key,value pair will have the key name of "fruitsConsumed"
</p>
<p>
The value for this key will be an array of objects.
</p>
<p>
Each of these objects will have two key,value pairs.
</p>
<p>
SCREEN - color fruitName and consumedCount
</p>
<p>
The keys will be fruitName and consumedCount.
</p>
<p>
Now, instead of having the actual fruitName be a key, it will have a generic key of fruitName.
</p>
<p>
SCREEN - color fruitNames
</p>
<p>
To actually construct this, we take the fruitNames we calculated earlier and an Array map method.
</p>
<p>
For each fruit name we return an object where the fruitName key receives the fruit name value.
</p>
<p>
And where the consumed count is returned from the object we are currently looking at from the forEach array method.
</p>
<br>
<p>
We shall see this shortly when we build the chart in the JavaScript Console.
</p>
<p>
[ Image: Image of JavaScript Console fruitConsumption data array including all the data objects ]
</p>
<p>
For now, let's look at the updated object.
</p>
<p>
We see the key,value pair of "apple" and 1.
</p>
<p>
Right below it we see the new key,value pair of fruitsConsumed.
</p>
<p>
You can see that the we have basically moved the name of the fruit from being a key to being a value.
</p>
<p>
This is helpful if we have an iteration method with an accessor function that is looking for the name of the fruit and/or consumedCount.
</p>
<br>
<p>
Going back to our code, let's now take a look at how we solve the issue of not having a total fruit count per season.
</p>
<p>
<pre><code class="javascript">fruitConsumption.forEach(function(d) {

    d.fruitsConsumed = fruitNames.map(function(name) {     
        return {                                            
            "fruitName": name,                                 
            "consumedCount": d[name]};                         
    });

    d.totalFruit = d3.sum( d.fruitsConsumed, function(d) {  // ** HIGHLIGHT **
        return d.consumedCount;                             // ** HIGHLIGHT **
    });                                                     // ** HIGHLIGHT ** 
});</code></pre>
</p>
<p>
SCREEN - color d3.sum
</p>
<p>
While in the Array forEach iteration method, the code uses d3.sum on the newly created key,value pair of fruitsConsumed.
</p>
<p>
Using the accessor function we define, which gets and returns the consumedCount, the d3.sum method returns the sum of the given array of consumedCount for each season.
</p>
<p>
This sum will be the sum of all the fruits.
</p>
<br>
<p>
We shall see this shortly when we build the chart in the JavaScript Console.
</p>
<p>
[ Image: Image of JavaScript Console showing array of objects that shows how much fruit was consumed for each type of fruit ]
</p>
<p>
For now, let's look at how this works.
</p>
<p>
We take the first object of fruitConsumption.
</p>
<p>
Then we get the value for the key "fruitsConsumed".
</p>
<p>
When we open each object in the array, you can see the new objects we created.
</p>
<p>
Each object has the keys of fruitName and consumedCount.
</p>
<p>
We can pass this array into the d3.sum() operator which returns the sum of the array while using the accessor function.
</p>
<p>
You can see that if we add 1 apple plus 4 kiwi plus 1 grape from the fruitsConsumed array of objects that we get six fruits.
</p>
<p>
Which is what d3.sum() returns.
</p>
<br>
<p>
So when we use the array.forEach iterator, we are going to get the total fruits for each season.
</p>
<p>
<pre><code class="javascript">fruitConsumption.forEach(function(d) {

    d.fruitsConsumed = fruitNames.map(function(name) {     
        return {                                            
            "fruitName": name,                                 
            "consumedCount": d[name]};                         
    });

    d.totalFruit = d3.sum( d.fruitsConsumed, function(d) {  // ** HIGHLIGHT **
        return d.consumedCount;                             // ** HIGHLIGHT **
    });                                                     // ** HIGHLIGHT ** 
});</code></pre>
</p>
<br>
<p>
Next, we will define the SVG Viewport and the inner drawing space.
</p>
<p>
<pre><code class="javascript">
var margin = {top: 80, right: 30, bottom: 30, left: 30},     // ** Highlight var name **
    width = 300 - margin.left - margin.right,                // ** Highlight var name **
    height = 300 - margin.top - margin.bottom;               // ** Highlight var name **</code></pre>
</p>
<p>
We use the D3 margin convention.
</p>
<p>
We leave extra room at the top, for the chart legend which will detail which color belongs to which fruit.
</p>
<br>
<p>
Next, we define the x scale as a D3 Ordinal Scale.
</p>
<p>
<pre><code class="javascript">var x = d3.scale.ordinal()
    .domain(seasonNames)
    .rangeRoundBands([0, width], 0.1);</code></pre>
</p>
<p>
SCREEN - color domain( )
</p>
<p>
The domain is the array of 4 season names.
</p>
<p>
SCREEN - color domain( )
</p>
<p>
The range is the width of the inner drawing space.
</p>
<p>
This scale will convert a season into a number on the x-axis that corresponds to the range round bands.
</p>
<br>
<p>
Next, we define the y scale as a D3 Linear Scale.
</p>
<p>
<pre><code class="javascript">var y = d3.scale.linear()
    .domain([0, d3.max(fruitConsumption, function(d) { return d.totalFruit; })])
    .range([height, 0]);</code></pre>
</p>
<p>
SCREEN - color domain( )
</p>
<p>
The domain goes from 0 to the max number of fruits consumed per a season.
</p>
<p>
We use the d3.max operator to return the max total fruit consumption per season using the accessor function we define.
</p>
<p>
SCREEN - color range( )
</p>
<p>
The range of the domain is defined backwards as the SVG Coordinate space has it's origin coordinate at the top left and the y-axis coordinates get bigger towards the bottom of the screen.
</p>
<br>
<p>
Next, we define the color ordinal scale we will use.
</p>
<p>
<pre><code class="javascript">var color = d3.scale.ordinal()
    .domain(fruitNames)
    .range(["#d62728", "#2ca02c", "#9467bd"]);</code></pre>
</p>
<p>
SCREEN - color domain( ) 
</p>
<p>
The domain of this ordinal scale is the name of the fruits.
</p>
<p>
SCREEN - color range( )
</p>
<p>
The range is an array of 3 hard-coded HTML colors.
</p>
<br>
<p>
Next, we define the X Axis and Y Axis.
</p>
<p>
<pre><code class="javascript">var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");

var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");</code></pre>
</p>
<p>
We set the scale each axis should use as well as the orientation.
</p>
<br>
<p>
Then we define the SVG Viewport and Inner Drawing Space.
</p>
<p>
<pre><code class="javascript">var svgViewport = d3.select("#visualization")
    .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
    .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
This is the normal way to define the Viewport if you are using the D3 margin convention.
</p>
<br>
<p>
Then we add the X axis to the chart making sure to transform translate the SVG Group element so that it appears on the bottom of the screen.
</p>
<p>
<pre><code class="javascript">svgViewport.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);</code></pre>
</p>
<br>
<p>
Then we add the Y axis to the chart.
</p>
<p>
<pre><code class="javascript">svgViewport.append("g")
    .attr("class", "y axis")
    .call(yAxis);</code></pre>
</p>
<br>
<p>
Now we get to the code where we construct the layers.
var layers = fruitNames.map(function(fruitName) {
    return fruitConsumption.map(function(d) {
        return {
            "x": x(d.season),
            "y": d[fruitName],
            "fruitName":fruitName};
        });       
    });</code></pre>
</p>
<p>
We want to construct three layers - where each layer represents a fruit.
</p>
<p>
SCREEN - color fruitNames and map
</p>
<p>
So the code starts with the fruit names and does an array map.
</p>
<p>
This first array map takes a fruit name and uses it within a function.
</p>
<p>
SCREEN - color fruitConsumption and map
</p>
<p>
This function will return an array where we take the fruitConsumption array of objects and do a second array map.
</p>
<p>
This second array map takes one of the data objects and uses it within a function.
</p>
<p>
This function returns an object with three keys.
</p>
<p>
The keys are "x", "y" and "fruitName".
</p>
<p>
The values of these keys are important.
</p>
<p>
The fruitName is just the fruit name from the first array map function.
</p>
<p>
The Y is the number of fruits eaten with the fruit name during this season.
</p>
<p>
The X is the season name passed to the X ordinal scaling function.
</p>
<p>
Remember - the X Ordinal scale takes in a string of a season name and returns a number on the range between 0 and the width of the inner drawing space.
</p>
<br>
<p>
In simpler language - We will iterate through the three fruit names.
</p>
<p>
[ Image: Image of JavaScript console showing the array of arrays that contain the data objects for each fruit and x and y coordinates]
</p>
<p>
For each fruit name, we will iterate through the four season objects.
</p>
<p>
This means we will do a total of 12 iterations.
</p>
<p>
During the inside iteration we will construct a new JavaScript Object Literal.
</p>
<p>
The key of fruit name will have the fruit name from the outside iteration.
</p>
<p>
The key of "y" will have the count of fruit that was eaten for this particular fruit for this particular season.
</p>
<p>
The key of "x" will have the season name scaled through the x ordinal scale to get a number on the number line.
</p>
<p>
You can see on the screen that we have three arrays of four elements.
</p>
<p>
Each array represents one type of fruit.
</p>
<p>
Each of the four elements inside of the array represents a different season.
</p>
<br>
<p>
Next we will create the D3 Stack Layout.
</p>
<p>
<pre><code class="javascript">var stack = d3.layout.stack();</code></pre>

stack(layers);</code></pre>
</p>
<p>
Now we pass in our layers data into the D3 Stack Layout.
</p>
<p>
The D3 Stack Layout will then do the math in the background for us.
</p>
<br>
<p>
We run this in the JavaScript console so that you can see it now.
</p>
<p>
[ Image: Image of JavaScript console showing the array of arrays that contain the data objects for each fruit and x and y coordinates now that it has been run through the d3.layout.stack()]
</p>
<p>
We open up the fourth object in each array so that you can compare it to the layers array of arrays we had before.
</p>
<p>
You can see that the objects now have a y0 key,value pair.
</p>
<p>
If we look across the three layers at the bottom of the screen, we can see that the Y0 goes from 0 to 2 and then to 4.
</p>
<p>
Which is what we would expect given the Y variable for each of the objects.
</p>
<br>
<p>
Next, we use the D3 pattern to bind the arrays in the layers array to individual SVG Group Elements.
</p>
<p>
<pre><code class="javascript">var svgLayer = svgViewport.selectAll(".layer")
    .data(layers)
  .enter().append("g")
    .attr("class", "layer");</code></pre>
</p>
<p>
Each SVG Group Element we create receives the class of layer.
</p>
<p>
That is - we are binding each layer array to an SVG Group Element as it's data attribute.
</p>
<br>
<p>
We will talk about this code in two stages: the first stage is how we create the rectangles and the second stage will be how we define the specific attributes for the rectangles.
</p>
<p>
<pre><code class="javascript">var rect = svgLayer.selectAll("rect")    // ** HIGHLIGHT **
    .data(function(d) { return d; })     // ** HIGHLIGHT **
  .enter().append("rect")                // ** HIGHLIGHT **
    .attr("x", function(d) { return d.x; })
    .attr("y", function(d) { return y(d.y + d.y0); })
    .attr("width", x.rangeBand())
    .attr("height", function(d, i) { return height - y(d.y); })
    .style("fill", function(d, i) { return color(d.fruitName); });</code></pre>
</p>
<p>
SCREEN - color svgLayer
</p>
<p>
We take the svgLayer selection variable from the previous set of code.
</p>
<p>
We then use the D3 pattern to selectAll non-existent elements.
</p>
<p>
Then we use the data operator to take the data bound to each SVG Group Element in the svgLayers selection and bind it to a temporary selection.
</p>
<p>
We then select the enter selection and append an SVG Rectangle shape to merge the temporary selection with a selection of SVG Rectangle elements.
</p>
<p>
The only slightly out of the ordinary thing here is the nested .data calls.
</p>
<p>
In the previous code, we bound each layer array to an SVG Group Element as it's data attribute.
</p>
<p>
In this code, we are binding each interior object of each layer array into a rectangle element.
</p>
<br>
<p>
Now, let's talk about how we define the specific attributes for the rectangles.
</p>
<p>
<pre><code class="javascript">var rect = svgLayer.selectAll("rect")      
    .data(function(d) { return d; })       
  .enter().append("rect")                          
    .attr("x", function(d) { return d.x; })                         // ** HIGHLIGHT **
    .attr("y", function(d) { return y(d.y + d.y0); })               // ** HIGHLIGHT **
    .attr("width", x.rangeBand())                                   // ** HIGHLIGHT **
    .attr("height", function(d, i) { return height - y(d.y); })     // ** HIGHLIGHT **
    .style("fill", function(d, i) { return color(d.fruitName); });  // ** HIGHLIGHT **</code></pre>
</p>
<p>
The "x" attribute is just the value from the "x" key from the objects we created in the layers.
</p>
<p>
The "y" attribute is the sum of the y key value and y0 key value from the objects we created in the layers scaled through the Y scale.
</p>
<p>
Why the addition of Y and Y0?
</p>
<p>
Remember that Y0 is the baseline element and Y is the number of fruits consumed.
</p>
<p>
To get the top left corner, we need the base line number of fruits plus the fruits consumed for this particular fruit.
</p>
<p>
We scale it through the Y Scale function, so that it fits correctly in our SVG Viewport.
</p>
<p>
The "width" attribute is the rangeBand of the x scaling function.
</p>
<p>
The "height" attribute is the height of the inner drawing space minus the "y" key value scaled through the Y Scale.
</p>
<p>
Why is it the height minus the scaled number of fruits for this particular fruit?
</p>
<p>
Because the SVG Coordinate space is inverted - so to get an accurate representation of the height of a number of fruits, we need to get take the full height and subtract from it the Y scale of fruits consumed.
</p>
<p>
Since the Y Scale of fruits is inverted, the more fruits there are, the lower the number it will return.
</p>
<p>
Lastly, the "style fill" attribute is defined as the fruit name from the object we created in the layers passed through the color ordinal scale function.
</p>
<p>
The color ordinal scale function will take in a string of a fruit and return one of the HTML Color strings.
</p>
<br>
<p>
The last bit of code we create is a legend like the one in the D3js.org Website Basic Scatterplot Example.
</p>
<p>
<pre><code class="javascript">var legend = d3.select("svg").selectAll(".legend")
    .data(color.domain().slice().reverse())
  .enter().append("g")
    .attr("class", "legend")
    .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });</code></pre>
</p>
<p>
We use the D3 pattern to append the color names to SVG Group Elements.
</p>
<p>
Note that we select the SVG element and not the SVG Viewport to make sure the legend is created above the Inner Drawing Space.
</p>
<p>
This will ensure that if all seasons have a maximum fruit consumption, that we will still be able to see the legend.
</p>
<br>
<p>
Then, we create rectangles using the SVG Group Element selection and the Color Ordinal Scale.
</p>
<p>
<pre><code class="javascript">legend.append("rect")
    .attr("x", width + margin.left - 18)
    .attr("width", 18)
    .attr("height", 18)
    .style("fill", color);</code></pre>
</p>
<br>
<p>
Finally, we add the text to designate what each colored box stands for.
</p>
<p>
<pre><code class="javascript">legend.append("text")
    .attr("x", width + margin.left - 24)
    .attr("y", 9)
    .attr("dy", ".35em")
    .style("text-anchor", "end")
    .text(function(d) { return d; });</code></pre>
</p>
<br>
<p>
Alright, we've been through the code once, let's now create it in the JavaScript Console.
</p>
<br>
<p>
We start with a document loading the D3 library from the d3js.org website.
</p>
<br>
<p>
We add in a sentence at the top of the page, some HTML new line breaks and a div with the id of "visualization".
</p>
<p>
<pre><code class="html">Fruits Consumed Per Season in 2012
&lt;br&gt;
&lt;br&gt;
&lt;div id="visualization"&gt;&lt;/div&gt;
&lt;br&gt;</code></pre>
</p>
<p>
The div is where we will add the SVG element and build the visualization.
</p>
<p>
We save down the file and open it in the web browser.
</p>
<br>
<p>
We open to the web browser and reload the file.
</p>
<p>
BROWSER reload the web page
</p>
<p>
We have opened the Chrome Developer Tools and have the JavaScript console up.
</p>
<p>
We can see the sentence at the top of the page.
</p>
<br>
<p>
Next, we define our Fruit Consumption Data Set.
</p>
<p>
<pre><code class="javascript">var fruitConsumption = [ {"season": "spring", "apple": 1, "kiwi": 4, "grape": 1},
                         {"season": "summer", "apple": 2, "kiwi": 1, "grape": 2},
                         {"season": "fall",   "apple": 3, "kiwi": 3, "grape": 1},
                         {"season": "winter", "apple": 2, "kiwi": 2, "grape": 2}];</code></pre>
</p>
<br>
<p>
Next, we get the season names
</p>
<p>
<pre><code class="javascript">var seasonNames = fruitConsumption.map(function(d) { return d.season; });

seasonNames;</code></pre>
</p>
<p>
You can see that we were able to extract the four different season names using the array map functionality.
</p>
<br>
<p>
Next, we get the fruit names
</p>
<p>
<pre><code class="javascript">var fruitNames = d3.keys(fruitConsumption[0])
    .filter(function(key) { return key !== "season"; });

fruitNames;</code></pre>
</p>
<p>
You can see that we were able to extract the three different types of fruits using the array filter functionality.
</p>
<br>
<p>
Next, we iterate through our fruitConsumption data set and add two new key,value pairs to each object.
</p>
<p>
<pre><code class="javascript">fruitConsumption.forEach(function(d) {  
    d.fruitsConsumed = fruitNames.map(function(name) {
        return {
            "fruitName": name,
            "consumedCount": d[name]
        };
    });

    d.totalFruit = d3.sum(d.fruitsConsumed, function(d) { return d.consumedCount; });        
});

fruitConsumption;</code></pre>
</p>
<p>
BROWSER - expand fruitConsumption, the first object, the array and the first object.
</p>
<p>
I expand the first two objects in the fruitConsumption array.
</p>
<p>
You can see that each object now has a key,value pair of totalFruit.
</p>
<p>
You can also see the new key,value pair for the fruitsConsumed.
</p>
<br>
<p>
Next, we start defining chart variables.
</p>
<p>
<pre><code class="javascript">var margin = {top: 80, right: 30, bottom: 30, left: 30},
    width  = 300 - margin.left - margin.right,
    height = 300 - margin.top - margin.bottom;</code></pre>
</p>
<p>
We will use these variable to define the SVG Viewport and inner drawing space.
</p>
<br>
<p>
Next, we define the X Ordinal Scale.
</p>
<p>
<pre><code class="javascript">var x = d3.scale.ordinal()
    .domain(seasonNames)
    .rangeRoundBands([0, width], 0.1);</code></pre>

x.domain();

x.rangeBand();</code></pre>
</p>
<p>
The domain of the x ordinal scale is the season names, which we can see on the screen.
</p>
<p>
The rangeBand of the x ordinal scale is 52 units.
</p>
<br>
<p>
Next, we define the Y Linear Scale
</p>
<p>
<pre><code class="javascript">var y = d3.scale.linear()
    .domain([0, d3.max(fruitConsumption, function(d) { return d.totalFruit; })])
    .range([height, 0]);

y.domain();

y.range();</code></pre>
</p>
<p>
The domain of the Y linear scale goes from 0 to the max number of fruits consumed in any one season.
</p>
<p>
We can see that this calculation yields the Y linear scale going from 0 to 7.
</p>
<p>
We can also see that the range of the Y linear scale is 190 to 0.
</p>
<p>
Remember, this range is defined backwards because the Y Axis in the SVG Coordinate Space is inverted.
</p>
<br>
<p>
Next, we define the Color Ordinal Scale.
</p>
<p>
<pre><code class="javascript">var color = d3.scale.ordinal()
    .domain(fruitNames)
    .range(["#d62728", "#2ca02c", "#9467bd"]);

color.domain();

color.range();</code></pre>
</p>
<p>
The domain of the color scale is the three fruit names.
</p>
<p>
The range of the color scale is the three HTML colors.
</p>
<br>
<p>
Next, we define the X Axis.
</p>
<p>
<pre><code class="javascript">var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");</code></pre>
</p>
<br>
<p>
Next, we define the Y Axis.
</p>
<p>
<pre><code class="javascript">var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");</code></pre>
</p>
<br>
<p>
Next, we define the SVG Viewport and inner drawing space.
</p>
<p>
<pre><code class="javascript">var svgViewport = d3.select("#visualization").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
BROWSER - click into the Visualization div, svg and into the G element.
</p>
<p>
Here we can finally see that we have added something to the webpage.
</p>
<br>
<p>
Next, we add in the X Axis to the graph.
</p>
<p>
<pre><code class="javascript">svgViewport.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);</code></pre>
</p>
<p>
BROWSER - click into the transform to see the x axis.
</p>
<p>
Remember that we have to transform translate the x axis to the bottom.
</p>
<br>
<p>
Next, we add in the Y Axis to the graph
</p>
<p>
<pre><code class="javascript">svgViewport.append("g")
    .attr("class", "y axis")
    .call(yAxis);</code></pre>
</p>
<p>
BROWSER - click on the y axis
</p>
<br>
<p>
Now, we go back to our data and create the layers of data that we want to pass to the D3 Stack Layout.
</p>
<p>
<pre><code class="javascript">var layers = fruitNames.map(function(fruitName) {
    return fruitConsumption.map(function(d) {
        return {"x": x(d.season), "y": d[fruitName], "fruitName":fruitName};
    });       
});

layers;</code></pre>
</p>
<p>
BROWSER - click into the array and open the fourth object for each array.
</p>
<p>
You can see that this creates an array of 3 arrays.
</p>
<p>
And inside each interior array are four objects.
</p>
<p>
Each of these objects have a fruitName key, x key and y key.
</p>
<br>
<p>
Now, let's create the D3 Stack Layout and pass the layers data to it.
</p>
<p>
<pre><code class="javascript">var stack = d3.layout.stack();

stack(layers);</code></pre>
</p>
<p>
BROWSER - click into array and open the fourth object for each array.
</p>
<p>
You can see that in each object we now have a y0 key,value pair.
</p>
<br>
<p>
Next, let's use the D3 pattern to attach each layer to an SVG Group Element
</p>
<p>
<pre><code class="javascript">var svgLayer = svgViewport.selectAll(".layer")
    .data(layers)
  .enter().append("g")
    .attr("class", "layer");

d3.select(".layer");</code></pre>
</p>
<p>
BROWSER - In the elements section click on the three layers
</p>
<p>
BROWSER - Then click into the array, g object, then the data array and then the 4th object.
</p>
<p>
You can see the three SVG Group elements that were added into the web document.
</p>
<p>
If we select the first element with class of layer, we can open it up to see it's data attribute.
</p>
<p>
Here you can see that it is indeed the first layer that was attached.
</p>
<p>
This layer contains 4 objects.
</p>
<p>
These four objects are what we will bind to SVG Rectangles in the next code section.
</p>
<p>
BROWSER - Close array.
</p>
<br>
<p>
Next, we add an SVG rectangle for each object in each layer.
</p>
<p>
<pre><code class="javascript">var rect = svgLayer.selectAll("rect")
    .data(function(d) { return d; })
  .enter().append("rect")
    .attr("x", function(d) { return d.x; })
    .attr("y", function(d) { return y(d.y + d.y0); })
    .attr("width", x.rangeBand())
    .attr("height", function(d, i) { return height - y(d.y); })
    .style("fill",  function(d, i) { return color(d.fruitName); });</code></pre>
</p>
<p>
BROWSER - Open 1st layer and hover over each rectangle element.
</p>
<p>
When we open one layer and hover over each rectangle element, you can see that it is indeed a layer of rectangles.
</p>
<p>
We now have our rectangles drawn.
</p>
<br>
<p>
The last thing we'll need to do is to add a legend.
</p>
<p>
<pre><code class="javascript">var legend = d3.select("svg").selectAll(".legend")
    .data(color.domain().slice().reverse())
  .enter().append("g")
    .attr("class", "legend")
    .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });</code></pre>
</p>
<p>
BROWSER - Close layer and click on first legend element.
</p>
<p>
This has created and positioned the SVG Group elements inside of which we'll create the rectangles and text.
</p>
<br>
<p>
Next, we create the boxes for each type of fruit and color it in.
</p>
<p>
<pre><code class="javascript">legend.append("rect")
    .attr("x", width + margin.left - 18)
    .attr("width", 18)
    .attr("height", 18)
    .style("fill", color);</code></pre>
</p>
<p>
You can now see the colored boxes.
</p>
<br>
<p>
Finally, we write out the text to designate what kind of fruit each colored box stands for.
</p>
<p>
<pre><code class="javascript">legend.append("text")
    .attr("x", width + margin.left - 24)
    .attr("y", 9)
    .attr("dy", ".35em")
    .style("text-anchor", "end")
    .text(function(d) { return d; });</code></pre>
</p>
<p>
You can now see the text designating the fruit next to each colored box.
</p>
<br>
<p>
And with that we have covered the D3 Stack Layout, how it works, what it does and how we can use it.
</p>
<p>
We have also gone through the complete step by step process of building a stacked bar chart using the D3 Stack Layout.
</p>
        </div>
      </div>

</div>    
    </div>    

