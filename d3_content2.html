<!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>The D3 Drag behavior, d3.behavior.drag(), constructs a drag behavior that creates an event listener to handle the drag gesture (mouse and touch) on the element you apply the drag behavior onto</li>
<li>The D3 Drag Behavior is interesting because it involves the compound event of interacting with an element by clicking or touching, dragging staid element, and finally de-clicking or stopping the touch</li>
<li>To that end, the D3 Drag Behavior listens to three specific events name - the "dragstart", "drag", and "dragend"</li>
<li>The "dragstart" and "dragend" events can be left undefined, whereas the "drag" event must be defined</li>
<li>The definition of the "drag" event has to do the actual moving of the element(s) that you are dragging - which usually means changing the attribute value pairs of the elements you selected to drag</li>
<li>The d3.behavior.drag() D3 Drag Behavior provides for you the absolute "x" and "y" coordinates of the element that is being dragged inside of the variable d3.event (d3.event.x and d3.event.y)</li>
<li>To ensure the offset between the mouse position and the starting element position during the drag, the D3 Drag Behavior provides the origin method, drag.origin(Object), which keeps track internally of this offset</li>
<li>If the D3 Drag Behavior origin is not used, then you will notice a jump on the screen when the element commences the drag behavior</li>
<li>Using Math, you can limit the D3 Drag Behavior to an enclosure of your choice - in this example, we create and use a bounding area outside of which the D3 Drag Behavior cannot drag an element outside of</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/d3-transition-basics">D3 Transition Basics</a></li>
<li><a href="https://www.dashingd3js.com/lessons/dom-event-model-and-javascript">DOM Event Model and JavaScript</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-and-dom-events">D3 and DOM Events</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-transition-events">D3 Transition Events</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 Drag Behavior
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
The Goal
</strong>
</p>
<br>
<p>
Let's take a close look at what we are going to be building in this video.
</p>
<p>
BROWSER: Start by clicking on one of the circles and moving it around
</p>
<p>
This web page has the D3 library imported from the d3js.org website.
</p>
<p>
This video example is going to investigate the D3 Drag Behavior
</p>
<p>
This technique is useful in regular data visualizations, force layout diagrams as well as in Geography Visualizations.
</p>
<p>
We will generate two SVG circles and make it so that they are draggable.
</p>
<p>
In addition, we will define specific behaviors that occur when the drag starts, while the drag is happening and when the drag ends.
</p>
<p>
Each circle exhibits a different simple behavior to show what is possible.
</p>
<p>
Additionally, we will cover a simple technique to provide a bounding box for the drag behavior.
</p>
<br>
<br>
<p>
<strong>
D3 Drag Behavior
</strong>
</p>
<br>
<p>
This code constructs a drag behavior.
</p>
<p>
<pre><code class="javascript">d3.behavior.drag()</code></pre>
</p>
<p>
Both mouse events and touch events are supported by the drag behavior.
</p>
<p>
What this code does is create event listeners to handle the drag gesture on the element we apply the drag behavior onto to.
</p>
<br>
<p>
For this video, we will assume that the mouse events are equivalent to touch events.
</p>
<p>
<pre><code class="javascript">// Mouse Event ~ Touch Event</code></pre>
</p>
<p>
So we will only talk about mouse events for the rest of the video to save saying mouse slash touch event.
</p>
<p>
For the basic examples we will be doing you can think of them as equivalent.
</p>
<p>
However, if you are implementing something more complicated, it's worth exploring whether the behavior you are coding up is equivalent in the mouse / touch space.
</p>
<br>
<p>
We have previously covered the Mouse Down, Mouse Up and Mouse Click events.
</p>
<p>
<pre><code class="javascript">// Mouse Down
// Mouse Up
// Mouse Click</code></pre>
</p>
<p>
A Mouse Down event is pressing the mouse button down.
</p>
<p>
A Mouse Up event is releasing the mouse button that was previously down.
</p>
<p>
A Mouse Click event is when a Mouse Down event is followed by a Mouse Up Event with the mouse staying in the same location.
</p>
<p>
Because the events are independent, we could trigger different behaviors for each event.
</p>
<br>
<p>
A Mouse event we haven't covered is the Mouse Move event.
</p>
<p>
<pre><code class="javascript">// Mouse Move</code></pre>
</p>
<p>
As you can probably guess, this event is triggered every time the mouse is moved.
</p>
<p>
Note - every single time the mouse moves, even if it is moved just a pixel.
</p>
<p>
For this reason, most applications don't monitor this mouse event as just moving the mouse around the page generates large amount of data.
</p>
<p>
So for the most part, the mouse move event handler is registered if and only if when it's needed and then immediately removed as soon as it's not needed any more.
</p>
<p>
Why is this important?
</p>
<br>
<p>
This is important because a drag event involves the movement of the mouse.
</p>
<p>
<pre><code class="javascript">// Theoretical Drag Event
// 1) Grab the object
// 2) Move the object
// 3) Let go of the object</code></pre>
</p>
<p>
Before we talk about code, lets build a theoretical framework of what constitutes a drag event in real life.
</p>
<p>
First - we will want to grab the object we are going to move.
</p>
<p>
Second - we will want to move the object we have grabbed.
</p>
<p>
Third and lastly - we will want to let go of the object we grabbed.
</p>
<p>
So three events have to happen for us to be able to drag an object around.
</p>
<br>
<p>
If we take the theoretical framework and translate it into mouse events, then we should experience three different mouse events.
</p>
<p>
<pre><code class="javascript">// Drag Event
// 1) Mouse Down
// 2) Mouse Move
// 3) Mouse Up</code></pre>
</p>
<p>
First - the mouse should be pressed down.
</p>
<p>
Second - while the mouse is still pressed down, the mouse should move
</p>
<p>
Third - the mouse should be released.
</p>
<p>
Note - the mouse doesn't have to stop moving when the mouse up event happens.
</p>
<p>
So three events have to happen for us to be able to complete the life-cycle of a drag event.
</p>
<br>
<p>
Taking the theoretical model one step further, D3 has specific event names for the start, the movement and the end of the drag.
</p>
<p>
<pre><code class="javascript">// Drag Event
// 1) Mouse Down => "dragstart"
// 2) Mouse Move => "drag"
// 3) Mouse Up   => "dragend"</code></pre>
</p>
<p>
This helps make the code more readable and helps to tie the event triggers to the D3 behavior we are monitoring.
</p>
<p>
The first one is the "dragstart".
</p>
<p>
This is fired when the drag gesture is started.
</p>
<p>
The second one is the "drag".
</p>
<p>
This is fired when the element is dragged.
</p>
<p>
The third one is the "dragend".
</p>
<p>
This is fired when the drag gesture has finished.
</p>
<br>
<p>
A very helpful piece of information that D3 provides for us while the "drag" event is happening is the absolute "x" and "y" coordinates of the element that is being dragged.
</p>
<p>
<pre><code class="javascript">// "drag" event bonus
// => d3.event.x
// => d3.event.y</code></pre>
</p>
<p>
These coordinates are part of the d3.event object.
</p>
<p>
The d3.event object is a DOM event that captures information about the event that the user triggered.
</p>
<p>
Which in our case, for the "drag" event, will be the "x" and "y" absolute coordinates of the element.
</p>
<br>
<br>
<p>
<strong>
D3 Drag Origin
</strong>
</p>
<br>
<p>
The D3 Drag Origin is used to determine the starting position of the element being dragged.
</p>
<p>
<pre><code class="javascript">var drag = d3.behavior.drag()

drag.origin(Object)</code></pre>
</p>
<p>
This makes sure the drag behavior preserves the offset between the mouse position and the starting element position during the drag.
</p>
<p>
If no origin is specified, when the drag starts moving the element will move to where the mouse is which can be seen as a jump on the screen.
</p>
<p>
Let's take a look now at what this looks like.
</p>
<br>
<p>
Run the full source code with no  origin(Object) no X and Y coordinates
</p>
<p>
Run the full source code with the origin(Object) no X and Y coordinates
</p>
<br>
<p>
This web page has the D3 library imported from the d3js.org website.
</p>
<br>
<p>
We have created the example twice on this page.
</p>
<p>
The top example does not have the Origin set.
</p>
<p>
The bottom example does have the Origin set.
</p>
<br>
<p>
As you see me click on the edges of the circles and start the drag gesture, you will notice that the circle appears to jump to the mouse cursor.
</p>
<p>
BROWSER: Click on the very edges of the circles
</p>
<br>
<p>
This is what happens when an Origin is not specified.
</p>
<br>
<p>
So you want to make sure that you always specify an origin unless you really want the jump to happen.
</p>
<br>
<p>
So if we specify an Origin to the drag behavior, the behavior will preserve the offset between the mouse position and the starting element position.
</p>
<p>
<pre><code class="javascript">var drag = d3.behavior.drag()

drag.origin(Object)</code></pre>
</p>
<p>
Which is great, because we don't want to experience a jump when the drag event occurs.
</p>
<p>
We pass Object as the origin accessor which is then used to determine the starting point of the element being dragged.
</p>
<br>
<br>
<p>
<strong>
D3 Drag Action
</strong>
</p>
<br>
<p>
Once we have defined the D3 Drag Behavior we have to add the specific events we want to listen to and what functionality the listener must accomplish, otherwise nothing will happen:
</p>
<p>
<pre><code class="javascript">var drag = d3.behavior.drag()
  
// drag.on(type, listener)

// mouse down
drag.on("dragstart", function(..) {..});

// mouse move
drag.on("drag", function(..) {..});

// mouse up
drag.on("dragend", function(..) {..});</code></pre>
</p>
<p>
As we covered earlier, the type of events we can listen to are the drag start, drag and drag end.
</p>
<p>
These are more or less self-explanatory.
</p>
<br>
<p>
For the start and end of the drag, we will usually want to change the appearance of the element to visually communicate to the user that the element has been selected or deselected.
</p>
<p>
<pre><code class="javascript">// mouse down
drag.on("dragstart", function(..) {..});

// mouse move ** HIDDEN **
drag.on("drag", function(..) {..});

// mouse up
drag.on("dragend", function(..) {..});</code></pre>
</p>
<p>
In our example, we have the black circle change to a different color when the dragstart event is triggered.
</p>
<p>
Then, when the dragend event is triggered, we change the circle color back to black.
</p>
<br>
<p>
For the actual dragging of the element, the event listener functionality has to do the actual moving of the element we are dragging.
</p>
<p>
<pre><code class="javascript">// Mouse Move
drag.on("drag", function(..) {..});

d3.event.x

d3.event.y</code></pre>
</p>
<p>
This involves changing the attributes of the element we selected.
</p>
<p>
As we covered earlier, a very helpful piece of information that D3 provides for us while the "drag" event is happening is the absolute "x" and "y" coordinates of the mouse event.
</p>
<p>
This information comes out of the coordinates that are part of the d3.event object.
</p>
<p>
The D3.event object is a DOM event that captures information about the event that the user triggered.
</p>
<p>
Which in our case, for the "drag" event, will be the "x" and "y" absolute coordinates of the element as it is being dragged.
</p>
<p>
This way, as the mouse moves, we know the x and y coordinates so can easily update the x and y attributes of the element we are moving.
</p>
<p>
In our example, we also have the function tell us which circle we have clicked on as well as the X and Y coordinates.
</p>
<p>
We'll cover this later when we do the Example Code Explanation.
</p>
<br>
<br>
<p>
<strong>
D3 Drag Bounding Area
</strong>
</p>
<br>
<p>
One more thing to pay attention to is that though the height and width of the SVG Viewport limit how it shows up on the webpage page, it does not actually limit the SVG drawing surface.
</p>
<p>
<pre><code class="javascript">// SVG Viewport
d3.select("body")
  .append("svg")
    .attr("height", "200")
    .attr("width", "200");</code></pre>
</p>
<p>
The SVG drawing surface is infinite so it is possible to define and move SVG objects to X and Y coordinates outside of the SVG Viewport.
</p>
<p>
Though they will no longer be visible, they will still exist.
</p>
<br>
<p>
This is something you really want to pay attention to when using drag behaviors.
</p>
<p>
<pre><code class="javascript">// SVG Viewport
d3.behavior.drag()</code></pre>
</p>
<p>
It is entirely possible to drag an element outside of the Viewport if you don't specify a Bounding Area.
</p>
<p>
Let's take a look at an example, without the bounding area defined.
</p>
<br>
<p>
BROWSER: Here we run the the full source code of the example but do not define the bounding area
</p>
<p>
As you can see, I can still drag the circles around.
</p>
<p>
However, when I drag them outside of the bounding area they disappear.
</p>
<p>
Further more, if I release the mouse button, then I have no way to reselect them because of the way the mouse listener works inside of the SVG container.
</p>
<p>
So now I've lost both of the SVG circles.
</p>
<p>
This is why it's important to define a bounding box.
</p>
<br>
<p>
To define the bounding box we have to do a small bit of Math.
</p>
<p>
[ Image: Image of the Bounding Box ]
</p>
<p>
(widen enough to cover full area)
</p>
<p>
To make our life simple, we will treat the SVG container as the bounding box we want to create.
</p>
<p>
First, we define the boundaries according to the width and height of the SVG container.
</p>
<p>
Regardless of where we drag our element, we want to make sure that they don't leave this box.
</p>
<p>
Which then leads us to the math.
</p>
<p>
If we look at a circle, the radius and the x and y center points dictate the boundary edges of the circle.
</p>
<p>
If we look at circle one, we can see that we never want the x1 coordinate minus the radius to be less than zero.
</p>
<p>
If we look at circle two, we can see that we never want the y coordinate minus the radius to be less than zero.
</p>
<p>
For circle three, we can see that we never want the x3 plus the radius to be bigger than the width.
</p>
<p>
Just like for circle three, we can see that we never want the y3 plus the radius to be bigger than the height.
</p>
<p>
If we impose these conditions on the circle elements and make sure they are not violated during the drag event, then the circles will never leave the boundary box.
</p>
<p>
The same type of math can be done for any other type of shape.
</p>
<p>
Obviously the more complicated the shape the more complicated the math.
</p>
<p>
Next, let's go piece by piece and explain the code of the example we are using for this video.
</p>
<br>
<br>
<p>
<strong>
Example Code Explanation
</strong>
</p>
<br>
<p>
First, we are going to define the height and width of the SVG container.
</p>
<p>
<pre><code class="javascript">var width = 200,
    height = 200,
    radius = 25;</code></pre>
</p>
<p>
We also define the radius of the SVG circle elements we will create.
</p>
<br>
<p>
Then we define the D3 drag behavior.
</p>
<p>
<pre><code class="javascript">var drag = d3.behavior.drag()
    .origin(Object)
    .on("dragstart", dragstart)
    .on("dragend",   dragend  )
    .on("drag",      dragmove);</code></pre>
</p>
<p>
We specify the origin accessor.
</p>
<p>
Then we define the three events types we want to listen to and the three event listener functions that should be run when a specific event is triggered.
</p>
<p>
They are named in a self-documenting way.
</p>
<p>
The dragstart event triggers the dragstart function.
</p>
<p>
The dragend event triggers the dragend function.
</p>
<p>
The drag event triggers the dragmove function.
</p>
<br>
<p>
Next, we append the SVG Viewport to the HTML body and define it's width, height and border.
</p>
<p>
<pre><code class="javascript">var svg = d3.select("body")
  .append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("border", "2px solid");</code></pre>
</p>
<p>
This will also serve as the bounding box for the Circle Dragging.
</p>
<br>
<p>
Next, we append HTML div and HTML span elements to the page after the SVG Viewport:
</p>
<p>
<pre><code class="javascript">d3.select("body").append("div").attr("id", "circle_id").text("Circle ID: ");

d3.select("body").append("div").attr("id", "x_var").text("X: ");
d3.select("body").append("div").attr("id", "y_var").text("Y: ");

d3.select("#circle_id").append("span").attr("id", "circle_id_text");

d3.select("#x_var").append("span").attr("id", "x_coord");
d3.select("#y_var").append("span").attr("id", "y_coord");</code></pre>
</p>
<p>
These will be used to provide information on which circle is currently being dragged and what X and Y coordinates the circle has at that moment in time.
</p>
<p>
We use an HTML DIV to provide the text labels.
</p>
<p>
We use an HTML Span to provide an element that we can select with d3 and provide text to it.
</p>
<br>
<p>
Next, we use the D3 pattern to bind two hard-coded JavaScript Object literal objects to SVG Circles.
</p>
<p>
<pre><code class="javascript">svg.selectAll("circle")
    .data([{x: 50, y: 50}, {x: 150, y: 150} ])
  .enter().append("circle")
    .attr("r", radius)
    .attr("cx", function(d, i) { return d.x; })
    .attr("cy", function(d, i) { return d.y; })
    .attr("id", function(d, i) { return "circle_" + i; })
    .call(drag);</code></pre>
</p>
<p>
We define the circle's radius, cx, cy and id based on anonymous functions that pull out the relevant data from the __data__ attributes of each circle that have been appended.
</p>
<p>
We also give each circle it's own distinct id that we will use later.
</p>
<p>
Note - because there were no other circles before this circle creation, we use the enter selection and ignore the exit and update selections.
</p>
<p>
The last command that we do is to call the drag function on the selection.
</p>
<p>
This calls the drag function on each of the circles in the D3 selection.
</p>
<p>
This ensures that each specific circle now has all of the drag event listeners attached to it.
</p>
<br>
<p>
Now that we have the circles, let's define the drag event listener functions.
</p>
<p>
<pre><code class="javascript">function dragstart(d) {
  
    circle = d3.select(this);

    if (circle.attr("id") === "circle_0") {
        circle.style("fill", "red");
    } else {
        circle.style("fill", "blue");  
    }

}</code></pre>
</p>
<p>
We start with the dragstart.
</p>
<p>
We use the "this" variable to reselect the SVG circle.
</p>
<p>
Depending on the ID of the circle we will either color it red or color it blue while being dragged.
</p>
<p>
This coloring action tells the user that the element has been selected.
</p>
<br>
<p>
Next, we define the drag event listener dragend function.
</p>
<p>
<pre><code class="javascript">function dragend(d) {

    d3.select("#circle_id_text").text(null);
    d3.select("#x_coord").text(null);
    d3.select("#y_coord").text(null);

    d3.select(this)
        .style("fill", "black");
}</code></pre>
</p>
<p>
We select the HTML span elements and set their inner text to null.
</p>
<p>
This serves the purpose of deleting the text.
</p>
<p>
We do this because when the drag ends, there shouldn't be an element selected nor should there be an X and Y coordinate.
</p>
<p>
Lastly within this function, we return the circle to the black color as we are no longer interacting with the circle.
</p>
<br>
<p>
This is the main function for the example.
</p>
<p>
<pre><code class="javascript">function dragmove(d) {

    circle = d3.select(this);

    circleID = circle.attr("id");

    d.x = Math.max(radius, Math.min(width - radius, d3.event.x))
    d.y = Math.max(radius, Math.min(height - radius, d3.event.y))

    d3.select("#circle_id_text").text(circleID);
    d3.select("#x_coord").text(d.x);
    d3.select("#y_coord").text(d.y);

    circle
        .attr("cx", d.x)
        .attr("cy", d.y);
}</code></pre>
</p>
<p>
It is the drag event listener dragmove function.
</p>
<p>
It is here where the dragging action will take place.
</p>
<p>
First, we use the "this" variable to create a D3 selection with the element we have clicked on.
</p>
<p>
Then we get the ID of the element.
</p>
<br>
<p>
Next, we use math to make sure the element stays within the bounding box.
</p>
<p>
BROWSER: highlight d3.event.x and d3.event.y
</p>
<p>
We use the d3.event.x and d3.event.y to track where the mouse cursor is and what the element x and y coordinates are.
</p>
<p>
The d dot x and d dot y update the x and y coordinates of the accessor object.
</p>
<p>
We'll explore these equations in the next slide.
</p>
<p>
Then we define and place the text into the HTML Span Elements to keep us up to date with which circle is currently selected and what the x and y coordinates are.
</p>
<p>
Finally, we give the circle selected the updated X and Y coordinates.
</p>
<p>
Because this dragmove formula is called every time the mouse moves as little as one pixel, the circle cx and cy attributes will be updated fast enough that it will look like it is moving fluidly.
</p>
<br>
<p>
Let's talk about the math.
</p>
<p>
<pre><code class="javascript">d.x = Math.max(radius, Math.min(width - radius, d3.event.x))
// => [25, width-25]

d.y = Math.max(radius, Math.min(height - radius, d3.event.y))
// => [25, height-25]</code></pre>
</p>
<p>
As we covered in a previous section, we want to make sure that given the radius of the circle and the height and width of the SVG Container, that the cx and cy of the circle never go beyond a certain point.
</p>
<p>
These math formulas see that the conditions hold.
</p>
<p>
For the X coordinate, the CX of the circle can only go from 25 to the width of the SVG Viewport minus 25.
</p>
<p>
Even if the d3.event.x is bigger than the width minus 25, the Math.min formula will keep the CX stuck at the width minus 25 value.
</p>
<p>
For the Y coordinate, the CY of the circle can only go from 25 to the height of the SVG Viewport minus 25.
</p>
<p>
Even if the d3.event.Y is bigger than the width minus 25, the Math.min formula will keep the CY stuck at the width minus 25 value.
</p>
<p>
This makes is so that regardless of where you drag the cursor, the circles will stay inside of the bounding box.
</p>
<p>
Let's now do the JavaScript Console Walk Through.
</p>
<br>
<br>
<p>
<strong>
JavaScript Console Walk Through
</strong>
</p>
<br>
<p>
This web page has the D3 library imported from the d3js.org website.
</p>
<br>
<p>
We have opened the Chrome Developer Tools and are in the Console Section.
</p>
<br>
<p>
We start by defining the variables used for the height and width of the SVG as well as the radius of the circle.
</p>
<p>
<pre><code class="javascript">var width  = 200,
    height = 200,
    radius = 25;</code></pre>
</p>
<br>
<p>
Next, because we are pasting code into the JavaScript console and cannot use JavaScript Function Hoisting, we define the D3 Drag Behavior Event Listener Functions first.
</p>
<br>
<p>
We start with the dragstart function
</p>
<p>
<pre><code class="javascript">function dragstart(d) {

    circle = d3.select(this);

    if (circle.attr("id") === "circle_0") {
        circle.style("fill", "red");
    } else {
        circle.style("fill", "blue");  
    }
}</code></pre>
</p>
<br>
<p>
Next, we define the dragend function
</p>
<p>
<pre><code class="javascript">function dragend(d) {

    d3.select("#circle_id_text").text(null);
    d3.select("#x_coord").text(null);
    d3.select("#y_coord").text(null);


    d3.select(this)
        .style("fill", "black");
}</code></pre>
</p>
<br>
<p>
Next, we define the dragmove function
</p>
<p>
<pre><code class="javascript">function dragmove(d) {

    circle = d3.select(this);

    circleID = circle.attr("id");

    d.x = Math.max(radius, Math.min(width  - radius, d3.event.x))
    d.y = Math.max(radius, Math.min(height - radius, d3.event.y))

    d3.select("#circle_id_text").text(circleID);
    d3.select("#x_coord").text(d.x);
    d3.select("#y_coord").text(d.y);

    circle
        .attr("cx", d.x)
        .attr("cy", d.y);
}</code></pre>
</p>
<br>
<p>
Now that we have defined the three event listener functions, we define the D3 Drag Behavior function.
</p>
<p>
<pre><code class="javascript">var drag = d3.behavior.drag()
    .origin(Object)
    .on("dragstart", dragstart)
    .on("dragend",   dragend  )
    .on("drag",      dragmove);</code></pre>
</p>
<p>
Remember that we want to pass and define the origin so that we don't experience jumpy behavior.
</p>
<br>
<p>
With the D3 Drag Behavior and event listener functions defined, let's create the SVG Viewport and Circles.
</p>
<br>
<p>
We create the SVG Viewport.
</p>
<p>
<pre><code class="javascript">var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("border", "2px solid");</code></pre>
</p>
<p>
Note: that we add a border style to make it easier to see the bounding box.
</p>
<p>
In production environments you do not want to apply a border to SVG elements as they are not supposed to render anything directly by themselves.
</p>
<p>
That said, for this video, we use the border style to make sure we visually see what we have coded up.
</p>
<br>
<p>
Next, we create the HTML Div and Span elements that will hold the key information regarding to what the circles are doing when dragged.
</p>
<br>
<p>
First we define the Divs
</p>
<p>
<pre><code class="javascript">d3.select("body").append("div").attr("id", "circle_id").text("Circle ID: ");

d3.select("body").append("div").attr("id", "x_var").text("X: ");
d3.select("body").append("div").attr("id", "y_var").text("Y: ");</code></pre>
</p>
<p>
You can see that we now have the text labels for the circle id as well as the X and Y coordinates.
</p>
<br>
<p>
Then we define the Spans as child elements of the HTML Div elements.
</p>
<p>
<pre><code class="javascript">d3.select("#circle_id").append("span").attr("id", "circle_id_text");

d3.select("#x_var").append("span").attr("id", "x_coord");
d3.select("#y_var").append("span").attr("id", "y_coord");</code></pre>
</p>
<p>
We use a span with a distinct id to be able to programmatically change the text from inside the dragmove function.
</p>
<br>
<p>
Lastly, we define the circle elements and call the drag function on each element in the selection.
</p>
<p>
<pre><code class="javascript">svg.selectAll("circle")
    .data([{x: 50, y: 50}, {x: 150, y: 150} ])
  .enter().append("circle")
    .attr("r", radius)
    .attr("cx", function(d, i) { return d.x; })
    .attr("cy", function(d, i) { return d.y; })
    .attr("id", function(d, i) { return "circle_" + i; })
    .call(drag);</code></pre>
</p>
<p>
BROWSER - drag circle elements for a long time.
</p>
<p>
As we drag the elements, you can see the circle ID of the circle we are dragging as well as the current X and Y coordinates.
</p>
<p>
Something you may have noticed before is that the blue circle can be dragged on top of the other circle.
</p>
<p>
However, the red circle cannot be dragged on top of the other circle.
</p>
<p>
In fact, it goes underneath the circle.
</p>
<p>
The clue to why this happens is found if we look at the ID's of the circles.
</p>
<p>
BROWSER: Drag circles
</p>
<p>
The circle that can go on top of has the id of circle underscore 1.
</p>
<p>
While the circle that goes beneath the other circle has the id of circle underscore 0.
</p>
<p>
Rather than having a Z index like in HTML where we can specifically state what elements go on top of other elements, with SVG the last element drawn goes over previous elements.
</p>
<p>
SVG draws elements in the order they are specified in the document.
</p>
<p>
So if we had three circles, the first generated circle would not be able to go over any of the other two circles.
</p>
<p>
The second generated circle would be able to go over the first generated circle but not the third generated circle.
</p>
<p>
Lastly, the third generated circle would be able to go over both the first and second generated circles.
</p>
<p>
The way people get around this with code is to reorder the elements with D3.
</p>
<p>
This implementation will be left for another time.
</p>
<br>
<p>
And with that we have covered the basics of thinking, creating and moving SVG objects that exhibit the drag behavior.
</p>
<br>
<p>
We covered the 3 different drag events that D3 provides for us as well as how to make sure the graphics don't get jumpy when we drag them around.
</p>
<br>
<p>
This technique will be useful in regular data visualizations, force layout diagrams as well as in Geography Visualizations.
</p>
        </div>
      </div>

