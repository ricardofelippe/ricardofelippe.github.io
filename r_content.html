<!DOCTYPE html>
<html>

<body>


<h2 id="R0">R Tips!</h2>


<h3>The location of startup files</h3>
When start R the .Rprofile will be read. This file is located in R.HOME. To find out where R_HOME is, use R.home() command.<br>
The following commands will open your .Rprofile from within an R editor:

<ul>
<li>file.edit("~/.Rprofile") # edit .Rprofile in HOME </li>
<li>file.edit(".Rprofile") # edit project specific .Rprofile</li>
</ul>

Restarting R session...: CTRL + SHIFT + F10

<h3>Caching variables</h3>
<li><a href="https://bookdown.org/csgillespie/efficientR/programming.html#caching-variables" target="_blank"><mark>Use memoise package!(clickMe!)</mark></a></li>

<h3>Searching for R Packages</h3>
<li> Example:RSiteSearch("haversine") </li>



Tips :<br>


   <p>To get tidy output from r-models in general also the  package broom is a good alternative  <p>
    <a href="ftp://cran.r-project.org/pub/R/web/packages/broom/vignettes/broom.html" target="_blank"><mark>BROOM</mark></a>

     Comando parse(): You can use parse() to transform a string into an expression<br>

	You can reverse this process and transform an expression into a string using deparse():<br>

    To clarify that you want to use a dplyr function rename without problem with another function, you can use the notation: dplyr::rename<br>
    Too show order in ggplot, remenber to re-order factor variables(example pag HTML in Guideline for good plots)<br>

==========*==========*==========*==========*<br>


<h2 id="R1">R and its indices</h2>


Useful functions:
<pre>
Where is the Min() or Max() or first TRUE or FALSE ?

Description: Determines the location, i.e., index of the (first) minimum or maximum of a numeric (or logical) vector.

Usage
<li>which.min(x)</li>
<li>which.max(x)</li>
</pre>




<h2 id="R2">R and its lists</h2>
Useful functions
<pre>
List Objects
Description:ls and objects return a vector of character strings giving the names of the objects in the specified environment. 
</pre>

<h2 id="R3">Subsetting</h2>
<p><a href="http://adv-r.had.co.nz/Subsetting.html#simplify-preserve" > <h4>Subsetting</h4> </a><p>

<ol>
Exercises
<li>Fix each of the following common data frame subsetting errors: </li>

mtcars[mtcars$cyl == 4, ]
R: mtcars[4,mtcars$cyl]

mtcars[-1:4, ]
R:  mtcars[-(1:4), ]

mtcars[mtcars$cyl <= 5]
R: mtcars[,mtcars$cyl <= 5,]

mtcars[mtcars$cyl == 4 | 6, ]
R: mtcars[,mtcars$cyl ==  6, ]


<li>Why does x <- 1:5; x[NA] yield five missing values? (Hint: why is it different from x[NA_real_]?)</li>
R: NA is of class logical, so x[NA] becomes recycled to x[NA, NA, NA, NA, NA]. Since subsetting an atomic with NA leads to an NA, you will get 5 of them returned.


<li>What does upper.tri() return? How does subsetting a matrix with it work? Do we need any additional subsetting rules to describe its behaviour?</li>
	x <- outer(1:5, 1:5, FUN = "*")
	x[upper.tri(x)]

R: Returns a matrix of logicals the same size of a given matrix with entries TRUE in the lower or upper triangle. Additional rules should be insert if you can include or no diagonal.



<li>Why does mtcars[1:20] return an error? How does it differ from the similar mtcars[1:20, ]?</li>
R: mtcars[1:20] returns an error because don't known what is the column to select.

<li>Implement your own function that extracts the diagonal entries from a matrix (it should behave like diag(x) where x is a matrix).</li>

<li>What does df[is.na(df)] <- 0 do? How does it work?</li>

</ol>  

<h2 id="R4">R Graphics!</h2>

Graphics: Principles:

    <li>Show comparison</li><br>
    <li>Show mechanism</li><br>
    <li>Show Multivariate data</li><br>
    <li>Show integrating evidence.</li><br>
    <li>Describing and documenting the evidence with sources ans apropriate labels and scales.</li><br>



<h2 id="R5">R Data Products!</h2>
	
<pre>
Shiny:<br>

    Tutorial Shiny: http://shiny.rstudio.com/tutorial/<br>

GoogleVis:<br>

    https://www.youtube.com/playlist?list=PLpl-gQkQivXhr9PyOWSA3aOHf4ZNTrs90<br>
    The book is available here:<br>
        https://leanpub.com/ddp<br>
    https://github.com/seankross/slides/blob/gh-pages/Developing_Data_Products/start/book.<br>
    http://datasciencespecialization.github.io/<br>

Plotly: git: https://github.com/ricardofelippe/Developing_Data_Products/blob/master/plotly/plotly.Rmd<br>

    ggplot x Plotly:<br>

comand: ggplotly() See: https://plot.ly/ggplot2/<br>

Authentication credentials: ??<br>

Comand: plotly_POST() Post it to the ploty website<br>

</pre>

<h2 id="R6">R Colors!</h2>

<pre>
Colors<br>

Packages: * grDevices : functions -colorRamp and colorRampPalette : Both of these take color names as arguments and use them as "palettes", that is,| these argument colors are blended in different proportions to form new colors.<br>

    colorRamp: takes a palette of colors (the arguments) and returns a function that takes values between 0 and 1 as arguments. The 0 and 1 correspond to the extremes of the color palette. Arguments between 0 and 1 return blends of these extremes.<br>

Example:<br>

    colorRampPalette, a function similar to colorRamp. It also takes a palette of colors and returns a function. This function, however, takes integer arguments (instead of numbers between 0 and 1) and returns a vector of colors each of which is a blend of colors of the original palette.<br>
    RColorBrewer Package, available on CRAN, that contains interesting and useful color palettes, of which there are 3 types, sequential, divergent, and qualitative. Which one you would choose to use depends on your data.<br>

If you open the palette set, you will see 3 types: The top section shows the sequential palettes in which the colors are ordered from light to dark. The divergent palettes are at the bottom. Here the neutral color (white) is <br>in the center, and as you move from the middle to the two ends of each palette, the colors increase in intensity. The middle display shows the qualitative palettes which look like collections of random colors. These might be used to distinguish factors in your data.

Code Examples:<br>

    -----------------------------------------------------------------------------------------------—<br>

Colors() : list the names of 657 predefined colors.<br>

Comands using RColorBrewer: cols<-brewer.pal(3,"BuGn") : BuGn is one of sequencial palettes. showMe(cols) : show the colors pal<-colorRampPalette(cols)<br>

showMe(pal(20)) : show the colors<br>

pal<-colorRamp(c("red","blue")) seqcol<-pal(seq(0,1,len=6))<br>

seqcol[1,]<br>

    -----------------------------------------------------------------------------------------------—<br>
</pre>
<h2 id="R7">R ggplot!</h2>

<pre>
ggplot<br>

Files: See : D:\Users\ricardo.ramos\Desktop\Coursera\Curso_R\Ggplot<br>

Cheat Sheet: https://www.rstudio.com/wp-content/uploads/2016/11/ggplot2-cheatsheet-2.1.pdf<br>

Ggplot contains 7 building blocks:<br>

    There's a DATA FRAME which contains the data you're trying to plot<br>
    Then the AESTHETIC MAPPINGS determine how data are mapped to color, size, etc.<br>
    The GEOMS (geometric objects) are what you see in the plot (points, lines, shapes)<br>
    FACETS are the panels used in conditional plots<br>
    STATS are statistical transformations such as binning, quantiles, and smoothing which ggplot2 applies to the data.<br>
    SCALES show what coding an aesthetic map uses (for example, male = red, female = blue)<br>
    Finally, the plots are depicted on a COORDINATE SYSTEM.<br>

As in the base plotting system (and in contrast to the lattice system), when building plots with ggplot2, the plots are built up in layers, maybe in several steps. You can plot the data, then overlay a summary (for instance, a regression line or smoother) and then add any metadata and annotations you need.

Code Examples:

    -----------------------------------------------------------------------------------------------—

Data: mpg

g<-ggplot(mpg,aes(displ,hwy)) : ggplot created a graphical object which we assigned to the variable g.

Note that if you tried to print g with the expressions g or print(g) you'd get an error! Even though it's a great package, ggplot doesn't know how to display the data yet since you didn't specify how you wanted to see it. Now type g+geom_point() and see what happens.

Basics functions:

    g+geom_point()+geom_smooth(method="lm")+facet_grid(.~drv)+ggtitle("Swirl Rules!")

    -----------------------------------------------------------------------------------------------—

Customização:

Each of the “geom” functions (e.g., _point and _smooth) has options to modify it. Also, the function theme() can be used to modify aspects of the entire plot, e.g. the position of the legend. Two standard appearance themes are included in ggplot. These are theme_gray() which is the default theme (gray background with white grid lines) and theme_bw() which is a plainer (black and white) color scheme.

Now we'll modify the aesthetics so that color indicates which drv type each point represents. Again, use g and add to it a call to the function geom_point with 3 arguments. The first is size set equal to 4, the second is alpha equal to 1/2. The third is a call to the function aes with the argument color set equal to drv. Note that you MUST use the function aes since the color of the points is data dependent and not a constant as it was in the previous example.

    g+geom_point(size=4,alpha=1/2,aes(color=drv))

Extensions ggplot2:

Site: https://www.ggplot2-exts.org

Code Examples:

library(GGally) nepali <- nepali %>% select(id, sex, wt, ht, age) %>% mutate(id = factor(id), sex = factor(sex, levels = c(1, 2), labels = c("Male", "Female"))) %>% distinct(id, .keep_all = TRUE)

ggpairs(nepali %>% select(sex, wt, ht, age))

Use guideline of good plots with ggplot;

    Guideline 1: Aim for high data density.

-> if an element of the plot is redundant, take it out.

</pre>
<h2 id="R8">R Cleaning and Getting Data!</h2>

<pre>
 Aspectos relevantes do Pacote tidyr obtido com o swirl()

Pacote: tidyr()

Consultar PDF no dropbox sobre esse item!!

Interesting function: tidyverse

Components of Tidy Data:

    The Raw data
    a tidy data set
    a code describing each variable and its values in the tidy data set.
    an explicit and exat recipe you used to go grom 1 -> 2,3.

    Downloading files

Known your working directory: main commands getwd() and setwd()

Relative and Absolute paths

-Relative - setwd("./data") setwd("../") - Absolute - setwd("/Useres/data")

In windows setwd("c\\Users\\Andrew\\Downloads")

Example checking for a data directory and creating if it doesn't exist:

if (!file.exists("data")){ dir.create("data") }

    Getting data form the internet- download.file()

==========*==========*==========*==========*

    Environments:

Environments formalize relationships between variable names and values.Environments are organized in parent/child relationships such that every environment keeps track of its parent, but parents are unaware of which environments are their children.

After seeing the cases above you may be curious if it’s possible for an execution environment to manipulate the global environment. You’re already familiar with the assignment operator <-, however you should also be aware that there’s another assignment operator called the complex assignment operator which looks like <<-. You can use the complex assignment operator to re-assign or even create name-value bindings in the global environment from within an execution environment. In this first example, the function assign1() will change the value associated with the name x:

x <- 10 x [1] 10 assign1 <- function(){ x <<- "Wow!" } assign1() x [1] "Wow!"

    Debugar

Comandos * traceback(): You have to call traceback immediately after the errro occurs. * debug(): Usar debug(funcaoADebugar)

    RProfile

system.time(): takes an arbitrary R expression as input and returns the amount of time taken to evaluate the expression. Compute the time in seconds

==========*==========*==========*==========*

PACOTES:

__Dplyr__:

Dplyr supplies five 'verbs' that cover most fundamental data manipulation tasks:

    select()
    filter()
    arrange()
    mutate()
    summarize()

group_by()

=====================================================================================================
</pre>

<h2 id="R9">R Functional Programming!</h2>

<pre>
__purr__: (Programação Funcional)

    Map functions 

The map family of functions applies a function to the elements of a data structure, usually a list or a vector. The function is evaluated once for each element of the vector with the vector element as the first argument to the function. The return value is the same kind if data structure (a list or vector) but with every element replaced by the result of the function being evaluated with the corresponding element as the argument to the function.

In the purrr package the map() function returns a list, while the map_lgl(), map_chr(), and map_dbl() functions return vectors of logical values, strings, or numbers respectively.

Exemplos de comandos: map_chr(c(5, 4, 3, 2, 1), function(x){ c("one", "two", "three", "four", "five")[x] }) [1] "five" "four" "three" "two" "one"

map_lgl(c(1, 2, 3, 4, 5), function(x){ x > 3 }) [1] FALSE FALSE FALSE TRUE TRUE

The map_if() function takes as its arguments a list or vector containing data, a predicate function, and then a function to be applied. A predicate function is a function that returns TRUE or FALSE for each element in the provided list or vector. In the case of map_if(): if the predicate functions evaluates to TRUE, then the function is applied to the corresponding vector element, however if the predicate function evaluates to FALSE then the function is not applied.

map_if(c(1, 2, 3, 4), is_even, square) 1 [1] 1

2 [1] 4

3 [1] 3

4 [1] 16

map_if(1:5, function(x){ x %% 2 == 0 }, function(y){ y^2 }) %>% unlist() [1] 1 4 3 16 5

The map_at() function only applies the provided function to elements of a vector specified by their indexes. Like map_if(), map_at() always returns a list.

map_at(c(4, 6, 2, 3, 8), c(1, 3, 4), square) 1 [1] 16

2 [1] 6

3 [1] 4

4 [1] 9

5 [1] 8

map_at(seq(100, 500, 100), c(1, 3, 5), function(x){ x - 10 }) %>% unlist() [1] 90 200 290 400 490

map2_chr(letters, 1:26, paste) [1] "a 1" "b 2" "c 3" "d 4" "e 5" "f 6" "g 7" "h 8" "i 9" "j 10" "k 11" "l 12" "m 13" "n 14" "o 15" "p 16" "q 17" "r 18" "s 19" [20] "t 20" "u 21" "v 22" "w 23" "x 24" "y 25" "z 26"

reduce(c("a", "b", "c", "d"), paste_talk) [1] "abcd"

reduce_right(c("a", "b", "c", "d"), paste_talk) [1] "dcba"

contains(random_ints, 45) [1] TRUE

The pmap() family of functions is similar to map2(), however instead of mapping across two vectors or lists, you can map across any number of lists. The list argument is a list of lists that the function will map over, followed by the function that will applied:

pmap_chr(list( list(1, 2, 3), list("one", "two", "three"), list("uno", "dos", "tres") ), paste) [1] "1 one uno" "2 two dos" "3 three tres"

The detect_index() function takes the same arguments as detect(), however it returns the index of the provided vector which contains the first element that satisfies the predicate function. Use detect_index() and is_even() to find the index of the first element of random_ints that is an even number.

detect_index(random_ints, is_even) [1] 2

detect_index(20:40, function(x){ x > 22 && x %% 2 == 0 }) [1] 5

The group of functions that includes keep(), discard(), every(), and some() are known as filter functions. Each of these functions takes a vector and a predicate function as arguments.

For keep() only the elements of the vector that satisfy the predicate function are returned while all other elements are removed. Use the keep() function with random_ints and is_even() to extract the even elements of random_ints.

    keep(random_ints, is_even)

[1] 6 10 8

The discard() function works similarly, it only returns elements that don’t satisfy the predicate function. Use discard() to filter out the even elements of random_ints.

    discard(random_ints, is_even)

[1] 41 71 63 53 89 47 33 91 99 37 97 61 23 81 39 43 101 65 83 69 87 49 79 35 85 75 73 95 55 31 67 21 25 [34] 27 59 45 93 29 57 51 77

every(random_ints, function(x){x < 100})

Partial application of functions can allow functions to behave a little like data structures. Using the partial() function from the purrr package you can specify some of the arguments of a function, and then partial() will return a function that only takes the unspecified arguments. Use partial() to create a new function caled gt_10 which returns TRUE if its only argument is greater than ten and FALSE otherwise.

    gt_10 <- partial(gt, b = 10)

=====================================================================================================

Operator %>%

The benefit of %>% is that it allows us to chain the function calls in a linear fashion. The code to the| right of %>% operates on the result from the code to the left of %>%.

As you read it, you can pronounce the %>% operator as the word 'then'.

Exemplo de comando:

    arrange() the result by size_mb, in descending order.
    If you want your results printed to the console, add
    print to the end of your chain.

cran %>% select(ip_id, country, package, size) %>% mutate(size_mb = size / 2^20) %>% filter(size_mb <= 0.5) %>% arrange(desc(size_mb)) # Your call to arrange() goes here

For: Examples

Next and Break: -----------------------------------------------------------------------------------------------— for(i in 1:100) { if(i <= 20) { ## Skip the first 20 iterations next } ## Do something here }

for(i in 1:100) { print(i)

if(i > 20) { ## Stop loop after 20 iterations break } }

==========*==========*==========*==========* Functions:

Functions are used to encapsulate a sequence of expressions that are executed together to achieve a specific goal. A single function typically does "one thing well"—often taking some input and the generating output that can potentially be handed off to another function for further processing. Drawing the lines where functions begin and end is a key skill for writing functions. When writing a function, it's important to ask yourself what do I want to encapsulate?

There is going to be a user who will desire the ability to modify certain aspects of your code to match their specific needs or application. Aspects of your code that can be modified often become function arguments that can be specified by the user. This user can range from yourself (at a later date) to people you have never met using your code for purposes you never dreamed of. When writing any function it's important to ask what will the user want to modify in this function? Ultimately, the answer to this question will lead to the function's interface.

    Once we've identified which aspects of a block of code we might want to modify or vary, we can take those things and abstract them to be arguments of a function.
    It is important specify defaults for arguments in our funcions, mainly if we are often called interactively. When using R in interactive mode, it can be a pain to have to specify the value of every argument in every instance of calling the function. Sometimes we want to call a function multiple times while varying a single argument (keeping the other arguments at a sensible default).

Programação Funcional:

Functional programming concentrates on four constructs:

Data (numbers, strings, etc) Variables (function arguments) Functions Function Applications (evaluating functions given arguments and/or data)

</pre>



</body>
</html> 
