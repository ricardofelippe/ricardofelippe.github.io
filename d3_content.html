<!DOCTYPE html>
<html>
<head>


</head>

<body>

<h2 id="d30">How Setup a Server with Python!</h2>
<pre>
* With python27 installed:
1- Use PowerShell, put this comamd

Go to the folder MyBlog
put this: .\python -m SimpleHTTPServer



2-http://172.28.38.106:8000/
</pre>

<h2 id="d31">Demostrating the Dom!</h2>
    
<button type="button" onclick="change_div_element()">Change this div element!</button><br>
<button type="button" onclick="put_text_in_div_element()">put_text_in_div!</button><br>
<button type="button" onclick="touch_div_and_showAlert()">touch_div_and_showAlert!</button><br>
<button type="button" onclick="put_circle_in_div_and_showInteration()">1-PutCircle_ShowInteration!</button><br>
<button type="button" onclick="showText_WithDelay()">1.1-showText_WithDelay!</button><br>
<button type="button" onclick="showTransition()">1.2-showTransition!</button><br>
<button type="button" onclick="Load_cast_measure_displayasBarChart()">Load_cast_measure_displayasBarChart()!</button><br>
<button type="button" onclick="Show_NestsData_Json()">Show_NestsData_Json!</button><br>
<button type="button" onclick="Creating_Scatterplot_in_div()">Creating_Scatterplot_in_div!</button><br>



<div id="vizcontainer" > 
    
</div>

<hr>
<div id="dimple1" > 

    In this example I'll assume it is <code>C:\Temp\MyDimpleSite</code></p>
<p>Now launch your operating system's command line and navigate to your new folder.  For example if you are using Windows - launch cmd.exe and type:</p>
<pre><code>cd\temp\mydimplesite
</code></pre>
<p>Next you need to install all the application dependencies, which is as simple as typing the following in the command prompt:</p>
<pre><code>npm install
</code></pre>
<p>This should automatically install everything you need (Thanks node.js!). Then run the following:</p>
<pre><code>node app.js
</code></pre>
<p>Which will launch a node express web server on port 3000, whose configuration is in the app.js file.  This won't actually do anything visible, the cursor will go to the next line and happily blink there forever.</p>
<p>Now you can browse the examples in your favourite browser.  So for the horizontal bars example use the following URL:</p>
<pre><code>http://localhost:3000/examples/bars_horizontal.html
</code></pre>
<p>This will serve the example file from your hard drive located at:</p>
<pre><code>C:\Temp\MyDimpleSite\examples\bars_horizontal.html
</code></pre>
<p>All of the examples on the dimple site will be located in this folder and can be accessed similarly.</p>

    
</div>
    
    
<h2 id="d32">SVG elements!</h2>
<li><a href="Listing_1_2_ASampleWebPageWithSVGElements__EbookD3InAction.html">Single Web Page with SVG elements</a></li>

    
<div id="infovizDiv">
<svg style="width:500px;height:500px;border:1px lightgray solid;">
<path d="M 10,60 40,30 50,50 60,30 70,80"
style="fill:black;stroke:gray;stroke-width:4px;" />
<polygon style="fill:gray;"
points="80,400 120,400 160,440 120,480 60,460" />
<g>
<line x1="200" y1="100" x2="450" y2="225"
style="stroke:black;stroke-width:2px;"/>
<circle cy="100" cx="200" r="30"/>
<rect x="410" y="200" width="100" height="50"
style="fill:pink;stroke:black;stroke-width:1px;" />
</g>
</svg>
</div>
<button type="button" onclick="change_svg_element()">Change this svg element!</button><br>
<button type="button" onclick="change_class_circle()">Change the class's circle!</button><br>    
    
    


<div id="vizcontainer2">
</div>



<h3 id="d33">Load data! <h3>

	<button type="button" onclick="d3_read_csv()">Use cities.csv and console.log()</button><br>
	<button type="button" onclick="d3_FunctionJsonRead()">Use tweets.json and console.log()</button>

<h3 id="d34">About Select data! <h3>
	<pre>
		Three categories of information about each element determine its behavior and
		appearance: styles, attributes, and properties. Styles can determine transparency, color,
		size, borders, and so on. Attributes typically refer to classes, IDs, and interactive behavior,
		though some attributes can also determine appearance, depending on which type of
		element you’re dealing with. Properties typically refer to states, such as the “checked”
		property of a check box, which is true if the box is checked and false if the box is
		unchecked. D3 has three corresponding functions to modify these values. If we wanted
		to modify the HTML elements in the previous example, we could use D3 functions that
		abstract this process:
		d3.select("#someDiv").style("border", "5px darkgray dashed");
		d3.select("#someDiv").attr("id", "newID");
		d3.select("#someCheckbox").property("checked", true);
	</pre>


<h3>Measuring data! <h3>
<p></p>    

<p id="min" title="Minimum">Minimum</p> 
<button type="button" onclick="d3_minimum()">Minimum</button><br>

<p id="max" title="Maximum">Maximum</p> 
<button type="button" onclick="d3_maximum()">Maximum</button><br>

<p id="min_max" title="Min & Maximum">Min & Maximum</p> 
<button type="button" onclick="d3_min_max()">Min & Maximum</button><br>


<hr>
<h3 id="lesson0">How Read Json: Patterns <h3>
    <p>
        <pre>
        Use this comand:
        d3.json("./data/exemplo.json",function(error,data) {
        callbackError=error;
        callbackData=data;});
        
        
    The data may be in this format:
        
 {"dados":[
{"modulo":"Venda",  "serviço":"1.1401-Serviços gerenciais, de consultoria gerencial, de relações públicas e de comunicação social", "valor":"861383325",  "foco":"País",  "pais":"Estados Unidos",  "ano":"2014"},
{"modulo":"Aquisição",  "serviço":"1.1401-Serviços gerenciais, de consultoria gerencial, de relações públicas e de comunicação social", "valor":"861383325",  "foco":"País",  "pais":"Estados Unidos",  "ano":"2014"}
]}
        
To access data, use: callbackData["dados"]    
    
    </pre>
    ☺</p>


    
<h3 id="lesson1">Introduction to HTML <h3>
    
<pre>
    Introduction to HTML

You are probably familiar with computer document extensions such as ".pdf", ".doc", ".xls", ".txt", etc...

These extensions tell a program what file format the file is written in and contains.

These files contain instructions on how to rebuild the document for viewing and/or editing every time it is opened.

Additionally, these instructions also tell you the contents inside of the document.

Lastly, these instructions also tell you the meta data of the document.

Meta data is the data about the data, so it could be things like the author of the document, the last modified date, the version number, and other things.

Which leads us to HTML.



HTML stands for Hyper Text Markup Language.

HTML is a language to describe the contents of a web document.

It uses elements or tags, which are wrapped around the text content to indicate how any software that accesses the webpage should interpret that part of the document.



What HTML Looks Like.

HTML looks like this:

<!DOCTYPE html>
<html>
  <head>
    <title>Hello World</title>
  </head>
  <body>
    <p>Hello World!</p>
  </body>
</html>
You have the DOCTYPE.

You have HTML.

Head.

Title.

The closing tag for Head.

The body.

The paragraph.

The Hello World! content.

Closing tag for the paragraph.

Closing tag for the body and the closing tag for the HTML.

As you can see, the HTML tags are wrapped around the text content of the document.

So any type of document that we find on the web is going to look very much the same.



A Brief History of HTML.

Tim Berners-Lee was the primary author of HTML which was formally published on June 1993.

He also wrote the first web server and first web browser.

He and his colleagues constructed HTML while working at CERN - an international scientific organization based in Geneva, Switzerland.

Tim Berners-Lee is currently the Director of the World Wide Web Consortium, W3C, the group that sets the technical standards for the Web.

Even today HTML, as interpreted by Web Browsers, continues to change and be updated.



The Structure of an HTML document.

The first part of the HTML document is the document type or doc type.

This describes which kind of HTML is being used so that browsers know how to interpret the document.

Next comes the html tag which is a wrapper around the whole document.

Note that the last part of the html document is the closing html tag.

Inside of the html tag, we commonly find the <head> section and the <body> section.

The <head> section will contain the meta data of the document - the data about the data.

The <body> section will contain the the actual content of the page.

As you can see, the structure is of elements nested inside of other elements.

An element within another element is called a child element.

An element that contains an element nested inside is called the parent element.

Elements that are within the same level and have a parent element are called sibling elements.

This parent/child/sibling concept is very important for Cascading Style Sheets, JavaScript, and browsers.



The Syntax of HTML Elements.

HTML elements are the building blocks of the HTML web page.

The elements consist of a pair of tags (starting and ending tags) and the textual or graphical content inside of the tags.

Elements can also have attributes inside of these tags.

The attributes are always keyword="value"
    
   </pre>    
    
<h3 id="lesson2">Introduction to HTML <h3>    
<pre>
Introduction to CSS

What is CSS?

CSS stands for Cascading Style Sheets.

CSS is a simple method for adding style (font, color, spacing, etc) to HTML Documents.

CSS allows you to describe how the document is represented on the screen and / or when it is printed.

If you think of HTML as describing the structure of the document, you can think of CSS as describing the look of the document.

In computer science, this is referred to as "Separation of Concerns."

Separation of Concerns is a design principle for separating a computer program into distinct sections, such that each section addresses a separate concern.

In the case of CSS, you can have one CSS document that defines the overall look and feel of a whole website of HTML documents.



What CSS looks like.

CSS can looks like this:

html { background-color: white; }

body { font: 18px "Lucida Grande"; color: black; }

a { color: blue; }
As you can see, the lines of CSS can define the color, font size, font style, link color, etc for each specific structural HTML element.

In this case 
- The HTML background color will be white 
- The body part of the HTML Document will use a font that is 18px tall, uses the Font Type "Lucida Grande", and is colored black. 
- And all the links will have a color Blue.



Brief History of CSS.

Before, we covered that HTML was formally published in June 1993.

In April 1994, HTML 2.0 added IMG - the image tag.

HTML 3.0 introduced the concept of a Table.

This HTML Table concept was meant only for the presentation of tabular data.

However, people quickly realized that by placing images and text inside of various data cells, they could control the layout of the page.

In May 1996, HTML 3.2 made it possible to set fonts, colors, place backgrounds behind the text content, and many other presentational methods.

As this presentational layer was being developed, web browsers went from being text only to supporting the next HTML tags that were being developed.

Unfortunately, most of the web browsers developed their own tags and accessibility.

Luckily, W3C stepped in and in December 1996, they released the CSS 1 Level Specification.

This specification started the process of separating display from content.

Today, the latest CSS specification people are working on is called CSS3.



The Structure of CSS Within an HTML Document

CSS styling can be applied by the browser defaults, an external style sheet, an internal style sheet, and/or inline styling.

Browser defaults are the most basic defaults as they are defaults your browser uses on every web page you view.

External style sheets are the style sheets that are referenced by a link within the Head Portion of the HTML Document.

Internal style sheets are the style sheets found and written out within the actual Head Portion of the HTML Document.

CSS styling can be applied Inline Style - that is, inside of a particular HTML element.

Lastly, JavaScript can also be used to define, change, and remove CSS styling from an HTML element.

Ignoring the JavaScript for now, the order of "Cascade" in "Cascading Style Sheets" is as follows:

Browser default
External Style Sheet
Internal Style Sheet
Inline Style
This means that the Inline Style will override the Internal Style Sheet which will override the External Style Sheet which overrides the Browser Defaults.

Which is why and how we think of CSS as being in a cascade.



The Syntax of CSS

CSS statements will often look like the following:

body { background-color: #ffffff; color: #000000; }

li {color: green; }

#first_text { color: orange; }

.footer_text { color: red; }
The first part of the statement is called the selector.

The selectors, li, #first_text, .footer_text, are patterns used to select the elements you want to style.

The second part of the statement is what is enclosed within the curly brackets or braces for those of you in the UK.

The enclosed part specifically defines how the element or elements selected will be styled.

You may notice that some of the selectors have a period in front of them, some have a hash mark or number sign in front of them and some have nothing.

A Hash mark signifies that you are selecting a particular HTML element while a period signifies that you are selecting several HTML elements.

In HTML, the id attribute provides a document-wide unique identifier for an element - so there is only one element that fits this selector.

In HTML, the class attribute provides a way of classifying similar elements - so there can be many elements that fit this selector.

Looking at this table, we can see the various ways that CSS selectors can be written:

.class selects all the elements with the particular class name

#id selects the elements with the particular id

The CSS document can get very large when you start writing selectors for specific elements inside of other elements or conjunctions of elements.

You can see all the different ways to select various elements within elements in this table.
</pre>
    
    
<h3 id="lesson3">Introduction to JavaScript <h3> 
<pre> 


Takeaways:
<li>JS stands for JavaScript</li>
<li>JavaScript controls the interaction with the document.</li>
JavaScript can be inserted into an HTML document in four main places:
Inline - within an HTML Element
HTML Body - within the body section of an HTML Document
HTML Head - within the head section of an HTML Document
Linked File - a file that lives elsewhere (on the server or different server)
JavaScript variables are case sensitive
Semi-colons are important in JavaScript
Comments can be written as "//" or "/* .... */"
Double equals ("==") does a type conversion when checking for equality
Triple equals ("===") checks equality of type and of value (no type conversion)

    Introduction to JavaScript

What is JavaScript?

JavaScript is a computer programming Language.

JavaScript was originally implemented as part of web browsers so that client scripts could interact with users.

If you think of HTML as describing the structure of the document and CSS as describing the look of the document, JavaScript controls the interaction with the document.

The most common uses of JavaScript are to write functions embedded in or included in the HTML of a page.

These functions then interact with the Document Object Model (the DOM).

A collection of these functions can be and are distributed as JavaScript Libraries.

jQuery, Prototype, MooTools, and D3 amongst others are example of JavaScript Libraries.



What JavaScript looks like

JavaScript can look like the following:

<script type="text/javascript">
  function showAlert() {
    var msg = 'This is a message';
    alert (msg);
  }
showAlert();
</script> 
As you can see:

The Script starts with a script tag.

Then a function called showAlert is defined.

Within this function a variable named msg is declared.

This variable is passed to a function named alert.

Then the function ends.

Finally, the function showAlert is called.



Brief History of JavaScript

JavaScript then called LiveScript was first shipped as part of the beta release of the Netscape Web browser called Navigator in September 1995.

Although it shares it's name with Java, the two languages are very different.

In December 1995, the name was changed to JavaScript from LiveScript.

Microsoft introduced JavaScript into it's own web browser, Internet Explorer, in August 1996.

In November 1996, Netscape submitted JavaScript to Ecma International for consideration as an industry standard.

It was accepted and the scripting language became a standard.

JavaScript, JScript and ActionScript are considered dialects of of ECMAScript.

As of today the Oracle Corporation owns the trademark to "JavaScript"

So when we talk about JavaScript 98% of the time we are really talking about ECMAScript.



The Structure of JavaScript Within an HTML Document

JavaScript can be inserted into an HTML document in four main places.

Inline - within an HTML Element

In the HTML Body - within the body section of an HTML Document

In the HTML Head - within the head section of an HTML Document

and

As a linked file specified in the HTML Head - this linked file can be on the same server or a different server.

Or for this tutorial, the linked files will live in the same folder on the same computer.

Let's take a look at the four ways to write JavaScript within an HTML document.

First do the inline:


<input type="button" value="Inline Hello" onClick="alert('Inline Hello');" />



The Syntax of JavaScript

The most basic JavaScript Syntax to be aware of is:

Case sensitivity:

var apples = 1;
var Apples = 2;
var appleS = 3;
apples === apples;
Apples === Apples;
appleS === appleS;
apples === Apples;
apples === appleS;
Semi colons are very important:

function temp() {
  return 1+2;
}

// vs

function temp() {
  return
  1+2;
}

// second is treated as

function temp() {
  return; // <---- Automatic Semi-Colon injection
  1+2;
}
Comments:

// is a comment

// This is also a comment:
/* asdf
   asdf
   asdf
*/
Double equals vs triple equals.

That is the most basic JavaScript Syntax to be aware of as we get started.

As we go along well pick up much more of the JavaScript Syntax.

</pre>
      
<h3 id="lesson4">Getting Started With D3.js<h3> 
      <pre>
      Setup a Folder to Hold D3

1 - Open folder browser

2 - Create a new folder on the desktop

3 - Make it easy to find and remember



Get the Latest D3 Version

1 - Open Web browser

2 - Go to d3js.org

3 - Scroll down the page

4 - I explain why you'd rather save the file than internet connection

5 - Save as to folder

6 - Extract the zip file

7 - I talk about the difference of the two files

8 - copy everything one step below



Use Chrome + JavaScript Command Line

1 - Open Web browser

2 - I talk about why I using Chrome

3 - I talk about developer tools

4 - I show how to open the JavaScript Console

5 - I show how to move the console from the bottom to the side

6 - I Explain how to do returns

* Soft Return (doesn't evaluate) - Shift + Enter

* Hard Return (evaluate) - Enter / Return Key

7 - I show example trying to type out a function

* With hard return vs soft return

function temp() {
  return '1';
}


Set up HTML + D3 Combo

1 - Open text editor and type out HTML

<!DOCTYPE html>
<html>
  <head>
  </head>
  <body>
    <p>Hello!</p>
  </body>
</html>
2 - Add in the JavaScript

3 - Bring up the developer tools

* Click into the file

4 - Bring up the JavaScript Consoler

* Type d3.

This will bring about all the javascript functions that you can append using the chain syntax

5 - Check out what version number of D3 you downloaded

* Type:

d3.version;
6 - Semantic Versioning

* D3.js is now on 3. something
* Semantic versioning means that things there may be changes in the D3 code that are now backwards incompatible - that is, if you used Version 2... and you upgrade to version 3.... your code may stop working.
      </pre>


<h3 id="lesson5">D3 Selections<h3> 
<pre>
Takeaways:
The Basic D3 Visualization Pattern is .select, .data, .enter, .append
d3.select selects only the FIRST matching element found in the document.
d3.selectAll selects ALL matching elements in document traversal order (top to bottom)
D3 selections are represented as JavaScript arrays with "special powers"
D3 uses CSS3 Selectors as it's selection tool
Resources:
Web Sites:

CSS3 Mozilla Developer Network Documentation
Sizzle CSS Selector Engine
Transcript: 

D3 Selections

Basic D3 Visualization Pattern

The Basic D3 Visualization Pattern is

.select
.data
.enter
.append
This selects the elements that you are going to use, attaches data to them and creates them on the screen.

Let's look at some quick examples from the D3js.org Website:

- Bubble Chart

.select
.data
.enter
.append
- Sunburst Partition

.select
.data
.enter
.append
- Choropleth

.select
.data
.enter
.append
- Click-to-Zoom via Transform Map

.select
.data
.enter
.append
As you can see, no matter how varied the visualization, the main pattern is select, data, enter and append.

This video focuses on the first step - the selection.



d3.select

First, let's take a look at the d3.select method.

This method selects only the FIRST matching element.

1 - Go to our Initial HTML File

2 - Add in a list

<ul>
	<li>One</li>
	<li>Two</li>
	<li>Three</li>
</ul>
3 - Add in two more paragraphs with a class fancy-paragraph

<p class="fancy-paragraph">Evening Gown Required</p>
<p class="fancy-paragraph" style="color:red;">Tuxedo required</p>
4 - Add in a span

<span style="color:red;">Bridge</span>
<span id="wide-span">Brooklyn Bridge</span>
5 - Add in a div within a div

<div class="outer-div">
	outer
	<div class="inner-div">
		inner
	</div>
</div>
6 - Reload the HTML document

7 - Check the Chrome Developer Tools for the HTML Elements

8 - Then go to the Chrome Developer Tools JavaScript Console

9 - d3.select("body");

Show what it shows
clear the screen;
10 - d3.select("ul");

Show what it shows
clear the screen;
11 - d3.select("li");

Show what it shows
clear the screen;
12 - d3.select("p");

Show what it shows
clear the screen;
13 - d3.select(".fancy-paragraph");

Show what it shows
clear the screen;
14 - d3.select("span");

Show what it shows
clear the screen;
15 - d3.select("#wide-span");

Show what it shows
clear the screen;
16 - d3.select("div");

Show what it shows
clear the screen;
17 - d3.select(".inner-div");

Show what it shows
clear the screen;
18 - What if we don't have an element, can we select it? => d3.select("#narrow-span");

Show what it shows
returns empty selection
clear the screen;


d3.selectAll

Next, let's take a look at the d3.selectAll method.

This method selects ALL matching elements in document traversal order.

Document traversal order means Top to Bottom.

1 - Then go to the Chrome Developer Tools JavaScript Console

2 - d3.selectAll("body");

Show what it shows
clear the screen;
3 - d3.selectAll("ul");

Show what it shows
clear the screen;
4 - d3.selectAll("li");

Show what it shows
clear the screen;
5 - d3.selectAll("p");

Show what it shows
clear the screen;
6 - d3.selectAll(".fancy-paragraph");

Show what it shows
clear the screen;
7 - d3.selectAll("span");

Show what it shows
clear the screen;
8 - d3.selectAll("#wide-span");

Show what it shows
clear the screen;
9 - d3.selectAll("div");

Show what it shows
clear the screen;
10 - d3.selectAll(".inner-div");

Show what it shows
clear the screen;
11 - What if we don't have an element, can we select it? => d3.selectAll("#narrow-span");

Show what it shows
returns empty selection
clear the screen;


D3 Selections are arrays

You may have noticed that the D3 selections have square brackets around them in the console.

In Javascript, square brackets signify the array data structure.

On the screen -> var myArray = [[1,2],[3,4]];
Arrays retain their ordering and their data can be access through indices.

Arrays in JavaScript are zero-indexed (that is the first element has an index of zero)

On the screen -> myArray[0]
Will give you the [1,2] array.

On the screen -> myArray[1]
Will give you the [3,4] array.

Let's take a look at the d3.select and d3.selectAll arrays in the JavaScript Console:

1 - d3.select("body");

Show the square brackets
This is because d3.select or d3.selectionAll returns an array of arrays.
Each element that is found is put into it's own array.
2 - var myArray = [[1,2],[3,4]];

3 - myArray;

4 - Click down on the arrows to show the two arrays

5 - myArray[0];

6 - myArray[0][0];

7 - myArray[1];

Clear screen
8 - d3.select("body")[0];

9 - d3.select("body")[0][0];

Clear screen
10 - d3.select("p");

11 - d3.select("p")[0];

12 - d3.select("p")[0][0];

Clear screen
13 - d3.selectAll("p");

14 - d3.selectAll("p")[0];

15 - d3.selectAll("p")[0][0];

Clear screen


CSS3 Selectors as the Selection Tool

D3 uses CSS3 Selectors as it's selection tool

So you can select elements by

tag - "div", "span"
class - ".inner-div", ".outer-div", ".fancy-paragraph"
id - "#wide-span"
attribute - "[color=red]"
or
containment - ".outer-div child"
and lastly,

there can be a union or an intersection of selectors.

As a special note - some browsers don't yet support CSS3 selectors natively.

For those browsers, you should take a look at the JavaScript Library called Sizzle.

Screenshot of Sizzle Library website.

</pre>


<h3 id="lesson6">D3 Arrays<h3> 
<pre>
Takeaways:
For nearly everything you do with D3, the data will be stored in arrays
JavaScript Array Mutator Methods modify the original data array
Mutator Methods can lead to data being altered, lost, or changed if you aren't careful
JavaScript Array Accessor Methods return a part or representation of the array
Accessor methods do not change the original data array
D3 has basic array utilities built on top of JavaScript's array utilities
Some of these basic array utilities include d3.min, d3.max, d3.extent, d3.sum, d3.mean, and d3.median.
Resources:
Web Sites:

JavaScript Array Mozilla Developer Network Documentation
Transcript: 

D3 Arrays

In D3 Data = Arrays

When using D3—and doing data visualization in general — you will tend to do a lot of array manipulation.

D3's canonical representation of data is an array.

D3 uses Arrays and Associative Arrays.

We focus on Arrays in this video.

Later we will look at Associative Arrays.



JavaScript Arrays

First, let's take a look at JavaScript Arrays.

Because D3 sits on top of JavaScript, we can use all of the power available in JavaScript within our D3 work.

An array is an enumerated list of variables.

It allows us to replace

x0 = 0;
x1 = 1;
x2 = 2;
x3 = 3;
x4 = 4;
x5 = 5;
with

x[0] = 0;
x[1] = 1;
x[2] = 2;
x[3] = 3;
x[4] = 4;
x[5] = 5;
Since an array is an enumerated list, it means that it retains it's order.

Additionally, arrays can consist of any kind of variable you want

var myArray = ["1", 2, function() {return 3;} ];
In this case the array consists of a string, a number and a function.

We can even have an array of arrays.

This gives us multi-dimensional arrays.

Which is great for matrix math if/when we run into it.

var matrixArray = [ [1,2] , [3,4] ];


JavaScript Array Mutator Methods

Basic D3 Array Utilities

array.reverse
array.shift
array.sort
array.splice
array.unshift
Next, let's take a look at a few Basic JavaScript Array Mutator Methods

A Mutator Method means that it modifies the array.

Lets take a look at an array in the JavaScript Console:

1 - We use the Initial.html file since it already has D3 loaded

2 - Open the Chrome Developer Tools and get the JavaScript Console

3 - [Later - have the video zoom in for the full time]

4 - Define the two arrays we will use

var easyArray = [3, 5, 8, 13, 8, 5, 3, -2, 0, 5];
easyArray;
5 - [Read out - array.reverse: reverses the order of the elements in the array]

6 - easyArray.reverse();

7 - easyArray;

8 - clear();

9 - Define the array again

var easyArray = [3, 5, 8, 13, 8, 5, 3, -2, 0, 5];
easyArray;
10 - [Read out - array.shift: removes the first element from the array]

11 - easyArray.shift();

12 - easyArray;

13 - clear();

14 - Define the array again

var easyArray = [3, 5, 8, 13, 8, 5, 3, -2, 0, 5];
easyArray;
15 - [Read out - array.sort: sorts the elements of the array]

16 - easyArray.sort();

17 - easyArray;

18 - clear();

19 - Define the array again

var easyArray = [3, 5, 8, 13, 8, 5, 3, -2, 0, 5];
easyArray;
20 - [Read out - array.splice: add or remove elements from the array]

21 - easyArray.splice(1,2);

22 - easyArray;

23 - easyArray.splice(1,0,"Banana");

24 - easyArray;

25 - easyArray.splice(3,2,"Sundae");

26 - easyArray;

25 - clear();

26 - Redefine the array

var easyArray = [3, 5, 8, 13, 8, 5, 3, -2, 0, 5];
easyArray;
27 - [Read out - array.unshift: add 1 or more elements to the front of the array]

28 - easyArray.unshift(10, 11, 12);

29 - easyArray;

30 - easyArray.length

31 - clear();

And those are the basic JavaScript Array Mutator methods.

The key word to pay attention to is * mutator *

These methods change the array in place so there is the potential to alter, lose or change the data if you aren't careful.



JavaScript Array Accessor Methods

Basic D3 Array Utilities

array.concat
array.join
array.slice
array.indexOf
array.lastIndexOf
Next, let's take a look at a few Basic JavaScript Array Accessor Methods

An Accessor Method returns a part or representation of the array

Lets take a look at two arrays in the JavaScript Console:

1 - We continue to use the Chrome Developer Tools we opened earlier

2 - [Later - have the video zoom in for the full time]

3 - Define the two arrays we will use

var easyArray = [3, 5, 8, 13, 8, 5, 3, -2, 0, 5];
var tinyArray = [4, 5];
easyArray;
tinyArray;
4 - [Read out - array.concat: join the array with other arrays or values]

5 - easyArray.concat(tinyArray);

6 - easyArray;

7 - tinyArray;

8 - clear();

9 - As these methods are not mutator methods, the arrays have not been modified.

easyArray;
10 - [Read out - array.join: join all the array elements into a string]

11 - easyArray.join();

12 - easyArray;

13 - clear();

14 - Again, the arrays haven't been modified.

easyArray;
15 - [Read out - array.slice: extract a section of the array] 
extracts up to, but not included the end.

16 - easyArray.slice(1,4); 
easyArray;

17 - easyArray.slice(1); 
easyArray;

18 - clear();

19 - Again, the arrays haven't been modified.

easyArray;
20 - [Read out - array.indexOf: find the 1st occurrence of a value within an array]

21 - easyArray.indexOf(5);

23 - clear();

24 - Again, the arrays haven't been modified.

easyArray;
25 - [Read out - array.lastIndexOf: find the last occurrence of a value within an array]

26 - easyArray.lastIndexOf(5); 
easyArray.length

27 - clear();

28 - [Read out - PAY ATTENTION TO THE Letters that are CAPITALIZED I and O]

And those are the basic JavaScript Array Accessor methods.



Basic D3 Array Utilities

Basic D3 Array Utilities

d3.min
d3.max
d3.extent
d3.sum
d3.mean
d3.median
Lastly, let's take a look at a few Basic D3 Array Utilities

These utilities come in very hand later when we are working with scales and axes.

Lets look at what D3 provides for us to manipulate arrays in the JavaScript Console:

1 - We continue to use the Chrome Developer Tools we opened earlier

2 - [Later - have the video zoom in for the full time]

3 - Define the two arrays we will use

var easyArray = [3, 5, 8, 13, 8, 5, 3, -2, 0, 5];
easyArray;
4 - [Read out - d3.min: returns the minimum value using natural order]

5 - d3.min(easyArray);

6 - easyArray;

7 - clear();

9 - As these D3 methods are not mutator methods, the arrays have not been modified.

10 - easyArray;

11 - [Read out - d3.max: returns the maximum value using natural order]

12 - d3.max(easyArray);

13 - easyArray;

14 - clear();

15 - As these D3 methods are not mutator methods, the arrays have not been modified.

16 - easyArray;

17 - [Read out - d3.extent: returns an array containing the minimum and maximum values using natural order]

18 - d3.extent(easyArray); 
d3.extent(easyArray)[0]; 
d3.extent(easyArray)[1];

19 - easyArray;

20 - clear();

21 - As these D3 methods are not mutator methods, the arrays have not been modified.

22 - easyArray;

23 - [Read out - d3.sum: returns the sum of the array]

24 - d3.sum(easyArray);

25 - easyArray;

26 - clear();

27 - As these D3 methods are not mutator methods, the arrays have not been modified.

28 - easyArray;

29 - [Read out - d3.mean: returns the mean of the array]

30 - d3.mean(easyArray);

31 - easyArray; 
d3.sum(easyArray)/easyArray.length

32 - clear();

33 - As these D3 methods are not mutator methods, the arrays have not been modified.

34 - easyArray;

35 - [Read out - d3.median: returns the median of the array]

36 - d3.median(easyArray);

37 - easyArray;

38 - clear();

And those are the most basic D3 Array Utilities.
</pre>

<hr>
<h3 id="lesson7">Adding a DOM Element<h3> 

<div>
<ul>
Takeaways:
<li>
D3 Selections are arrays of elements with special powers
</li>
<li>
D3 binds additional methods to the array so that you can apply operators to the selected elements
</li>
<li>
D3 .append operator appends a new element with the specified name as the last child of each element in the current selection
</li>
<li>
D3 .append operator returns a new selection containing appended elements
</li>
<li>
D3 .insert operator inserts a new element with the specified name before the element matching the specified before selector, for each element in the current selection
</li>
<li>
D3 .insert operator returns a new selection containing inserted elements
</li>
<li>
D3 .remove operator removes the elements in the current selection from the current document.
</li>
<li>
D3 .remove operator is currently a one-way operation so be careful with it
</li>
</ul>



D3 Selections Revisited
</strong>
</p>
<p>
D3 Selections are literally arrays of elements.
</p>
<p>
In addition to the JavaScript methods available, 
</p>
<p>
D3 binds additional methods to the array so that you can apply operators to the selected elements.
</p>
<p>
Remember, the selection is an array of an array of elements.
</p>
<p>
That is, each selected element lives in its own array within the selection array.
</p>
<p>
This is done to preserve the hierarchical structure of Elements.
</p>
<br>
<br>
<p>
<strong>
D3 Append Operator
</strong>
</p>
<p>
<pre><code class="javascript">selection.append(name);</code></pre>
</p>
<p>
First, let's take a look at the D3 Append Operator
</p>
<p>
This appends a new element with the specified name as the last child of each element in the current selection.
</p>
<p>
Then, it returns a new selection containing the APPENDED ELEMENTS.
</p>
<p>
1 - We use the Initial.html file since it already has D3 loaded and it already contains the HTML goodies we will use for this video.
</p>
<p>
2 - Open the Chrome Developer Tools and get the JavaScript Console
</p>
<p>
3 - Setup the screen so that we can see the HTML, the browser and the result of the D3 work.
</p>
<p>
4 - Check the D3 version to make sure it is working
</p>
<p>
<pre><code class="javascript">d3.version;</code></pre>
</p>
<p>
5 - d3.select("body");
</p>
<p>
6 - d3.select("body").append("hr");
</p>
<p>
<ul>
<li>hr is a horizontal rule or thematic break in HTML</li>
<li>Show the hr in the browser</li>
<li>Show the hr in the elements</li>
<li>reload browser</li>
</ul>
</p>
<p>
7 - d3.select("ul").append("hr");
</p>
<p>
<ul>
<li>Show the hr in the browser</li>
<li>Show the hr in the elements</li>
<li>Talk about how the li elements are children to the UL</li>
<li>Which is why the hr shows up as the last child element</li>
<li>reload browser</li>
</ul>
</p>
<p>
8 - d3.select("li").append("hr");
</p>
<p>
<ul>
<li>Show the hr in the browser</li>
<li>Show the hr in the elements</li>
<li>Talk about select only selects the first one</li>
<li>Which is why the hr shows up only after the first one</li>
<li>reload browser</li>
</ul>
</p>
<p>
9 - d3.selectAll("li").append("hr");
</p>
<p>
<ul>
<li>Show the hr in the browser</li>
<li>Show the hr in the elements</li>
<li>Talk about selectAll selects all the elements</li>
<li>And how it adds in the hr as the last child of each one</li>
<li>Which is why the hr shows up three times</li>
<li>reload browser</li>
</ul>
</p>
<p>
10 - d3.select("p").append("hr");
</p>
<p>
<ul>
<li>Show the hr in the browser</li>
<li>Show the hr in the elements</li>
<li>Talk about select only selects the first one</li>
<li>Which is why the hr shows up only after the first one</li>
<li>reload browser</li>
</ul>
</p>
<p>
11 - d3.selectAll("p").append("hr");
</p>
<p>
<ul>
<li>Show the hr in the browser</li>
<li>Show the hr in the elements</li>
<li>Talk about selectAll selects all the elements</li>
<li>And how it adds in the hr as the last child of each one</li>
<li>Which is why the hr shows up three times</li>
<li>reload browser</li>
</ul>
</p>
<p>
12 - d3.select(".inner-div").append("hr");
</p>
<p>
<ul>
<li>Show the hr in the browser</li>
<li>Show the hr in the elements</li>
<li>Talk about select only selects the first one</li>
<li>Which is why the hr shows up only after the first one</li>
<li>reload browser</li>
</ul>
</p>
<p>
13 - d3.select("#narrow-span").append("hr");
</p>
<p>
<ul>
<li>Appending an Element to something that doesn't exist</li>
<li>Returns an empty selection array</li>
<li>reload browser</li>
</ul>
</p>
<p>
And that is the basics of the D3 .append operator
</p>
<br>
<br>
<p>
<strong>
D3 Insert Operator
</strong>
</p>
<p>
<pre><code class="javascript">selection.insert(name, before)</code></pre>
</p>
<p>
Next, let's take a look at the D3 Insert Operator
</p>
<p>
This inserts a new element with the specified name before the element matching the specified before selector, for each element in the current selection.
</p>
<p>
If the before selector does not match any elements, then the new element will be the last child as with append operator.
</p>
<p>
Then, it returns a new selection containing the INSERTED ELEMENTS.
</p>
<p>
1 - We continue to use the Initial.html file
</p>
<p>
2 - d3.select("body").insert("hr");
</p>
<p>
<ul>
<li>Show the hr in the browser</li>
<li>Show the hr in the elements</li>
<li>reload browser</li>
</ul>
</p>
<p>
3 - d3.select("body").insert("hr", "span");
</p>
<p>
<ul>
<li>hr is a horizontal rule or thematic break in HTML</li>
<li>Show the hr in the browser</li>
<li>Show the hr in the elements</li>
<li>reload browser</li>
</ul>
</p>
<p>
4 - d3.select("body").insert("hr", ":first-child");
</p>
<p>
<ul>
<li>hr is a horizontal rule or thematic break in HTML</li>
<li>Show the hr in the browser</li>
<li>Show the hr in the elements</li>
<li>reload browser</li>
</ul>
</p>
<p>
5 - d3.select("ul").insert("hr", ":first-child");
</p>
<p>
<ul>
<li>Show the hr in the browser</li>
<li>Show the hr in the elements</li>
<li>Talk about how the li elements are children to the UL</li>
<li>Which is why the hr shows up as the first child element</li>
<li>reload browser</li>
</ul>
</p>
<p>
6 -
<br>
d3.select(".outer-div");
<br>
d3.select(".outer-div").insert("hr", ".inner-div");
</p>
<p>
<ul>
<li>Show the hr in the browser</li>
<li>Show the hr in the elements</li>
<li>talk about why .inner-div is the correct selection</li>
<li>talk about why the hr shows up before the inner div</li>
<li>reload browser</li>
</ul>
</p>
<p>
7 - d3.select("#narrow-span").insert("hr");
</p>
<p>
<ul>
<li>Appending an Element to something that doesn't exist</li>
<li>Returns an empty selection array.</li>
<li>reload browser	</li>
</ul>
</p>
<p>
8 -
<br>
d3.select(".outer-div");
<br>
d3.select(".outer-div").insert("hr", ".fancy-paragraph");
</p>
<p>
<ul>
<li>Show the hr in the browser</li>
<li>Show the hr in the elements</li>
<li>talk about why .fancy-paragraph is a wrong selection</li>
<li>talk about why the hr shows up as the last child of the .outer-div</li>
<li>reload browser	</li>
</ul>
</p>
<p>
And that is the basics of the D3 .insert operator
</p>
<br>
<br>
<p>
<strong>
D3 Remove Operator
</strong>
</p>
<p>
<pre><code class="javascript">selection.remove();</code></pre>
</p>
<p>
Next, let's take a look at the D3 Remove Operator
</p>
<p>
This removes the elements in the current selection from the current document.
</p>
<p>
Currently, this is a one-way operation.
</p>
<p>
If you remove elements, there is no way to add them back, even if you still have the selection variable.
</p>
<p>	
1 - We continue to use the Initial.html file
</p>
<p>
2 - d3.select("body").remove()
</p>
<p>
<ul>
<li>Show what was removed in the browser</li>
<li>Show what was removed in the elements</li>
<li>reload browser</li>
</ul>
</p>
<p>
3 -
<br>
var bodySelection = d3.select("body");
<br>
    bodySelection.remove();
<br>
    bodySelection;
</p>
<p>
<ul>
<li>Show what was removed in the browser</li>
<li>Show what was removed in the elements</li>
<li>Show that the bodySelection is still an array, though it's empty</li>
<li>reload browser</li>
</ul>
</p>
<p>
4 - d3.select("ul").remove()
</p>
<p>
<ul>
<li>Show what was removed in the browser</li>
<li>Show what was removed in the elements</li>
<li>reload browser</li>
</ul>
</p>
<p>
5 - d3.select("li").remove()
</p>
<p>
<ul>
<li>Show what was removed in the browser</li>
<li>Show what was removed in the elements</li>
<li>reload browser</li>
</ul>
</p>
<p>
6 - d3.selectAll("li").remove()
</p>
<p>
<ul>
<li>Show what was removed in the browser</li>
<li>Show what was removed in the elements</li>
<li>reload browser</li>
</ul>
</p>
<p>
7 - d3.selectAll(".fancy-paragraph").remove()
</p>
<p>
<ul>
<li>Show what was removed in the browser</li>
<li>Show what was removed in the elements</li>
<li>reload browser</li>
</ul>
</p>
<p>
8 - d3.select("#narrow-span").remove()
</p>
<p>
<ul>
<li>returns the null array</li>
<li>reload browser</li>
</ul>
</p>
<p>
And that is the basics of the D3 .remove operator
</p>

</div>

<hr>

<h3 id="lesson8">Fundamentals of SVG<h3> 
<div>
     <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>
SVG stands for Scalable Vector Graphics
</li>
<li>
SVG is a specification for creating vector graphics
</li>
<li>
SVG can be scaled up or down without lose of image quality
</li>
<li>
SVG images and behaviors are defined in XML
</li>
<li>
Since the DOM uses XML, we can use the DOM tree to create, access, and structure SVG Images
</li>
<li>
SVG images can be defined within an HTML document as if you were writing HTML
</li>
<li>
To define an SVG image, use an opening &lt;svg&gt; tag and a closing &lt;svg&gt; tag
</li>
<li>
SVG comes with basic shapes built in: rectangle, circle, ellipse, line, polyline, and polygon.
</li>
</ul>
</p>
        </div>
    


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
Web Sites:
</strong>
</p>
<p>
<ul>
<li>
<a href="https://developer.mozilla.org/en-US/docs/Web/SVG">Scalable Vector Graphics (SVG) | Mozilla Developer Network</a>
</li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            Fundamentals of SVG
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
What SVG is
</strong>
</p>
<p>
SVG stands for Scalable Vector Graphics.
</p>
<p>
SVG is a family of specifications for creating vector graphics.
</p>
<p>
Vector graphics are not created out of pixels.
</p>
<p>
Drawing vectors is called Vector Based Graphics.
</p>
<p>
Since Vector Graphics are not created out of pixels, they can be scaled up to larger or smaller sizes without losing image quality.
</p>
<p>
SVG images and their behaviors are defined in XML text files.
</p>
<p>
Since the DOM includes XML as part of the DOM specification, we can use the DOM Tree to access and update the structure, content and style of SVG Images.
</p>
<p>
This means that SVG elements can be styled using CSS just like HTML.
</p>
<br>
<br>
<p>
<strong>
What HTML5 Canvas is
</strong>
</p>
<p>
The HTML5 Canvas specification is a versatile JavaScript API (application program interface) allowing us to code programmatic drawing operations.
</p>
<p>
Canvas, by itself, allows you to define a canvas context object which can then be drawn inside.
</p>
<p>
This drawing object is created as a &lt;canvas&gt; tag element on the HTML page.
</p>
<p>
Within this context, you can use the simple powerful API to perform quick drawing operations on a 2D bitmap surface.
</p>
<p>
The drawing consists of pixels on a surface.
</p>
<p>
Drawing pixels is called Raster Based graphics.
</p>
<p>
Also No DOM nodes are created for any graphical element.
</p>
<br>
<br>
<p>
<strong>
SVG vs HTML5 Canvas
</strong>
</p>
<p>
SVG is a Vector Based Graphics system which creates DOM objects for each graphical element.
</p>
<p>
HTML5 canvas is a Raster Based Graphics system which creates images based on JavaScript API interaction.
</p>
<p>
Similarities
</p>
<p>
<ul>
<li>Both allow for drawing graphics</li>
<li>Both allow for drawing in 2-d</li>
</ul>
</p>
<p>
Differences
</p>
<p>
<ul>
<li>Vector vs Raster</li>
<li>SVG has DOM elements</li>
<li>Canvas allows for very complex images</li>
<li>Canvas gives constant performance</li>
<li>SVG slows down with an increase in DOM elements</li>
<li>SVG allows for event attachment</li>
<li>SVG allows contains animation API</li>
<li>Canvas redraws everything if something changes</li>
</ul>
</p>
<p>
Most D3.js examples use SVG so we will explore SVG further.
</p>
<br>
<br>
<p>
<strong>
The Structure of SVG Within an HTML Document
</strong>
</p>
<p>
SVG Graphics are defined within an HTML Document just as if you were writing HTML.
</p>
<p>
You start with an opening &lt;svg&gt; tag
</p>
<p>
You close with a closing &lt;/svg&gt; tag
</p>
<p>
Inside you can specify basic shapes
</p>
<p>
<ul>
<li>Rectangle</li>
<li>Circle</li>
<li>Ellipse</li>
<li>Straight Line</li>
<li>Polyline</li>
<li>Polygon</li>
</ul>
</p>
<p>
or specify an SVG Path.
</p>
<p>
The SVG Path allows you to create all the basic shapes and many other ones.
</p>
<p>
The SVG Path represent the outline of a shape that can be stroked, filled, used as a clipping path, or any combination of all three.
</p>
<p>
SVG Path is basically a pen you can move around.
</p>
<br>
<br>
<p>
<strong>
The Syntax of Basic SVG Objects
</strong>
</p>
<p>
Open the Initial.html file in a text editor.
</p>
<p>
Type the following at the top of the file:
</p>
<p>
A Rectangle
</p>
<p>
<pre><code class="html">&lt;svg width="50" height="50"&gt;
  &lt;rect x="0" y="0" width="50" height="50" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
A Circle
</p>
<p>
<pre><code class="html">&lt;svg width="50" height="50"&gt;
  &lt;circle cx="25" cy="25" r="25" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
An Ellipse
</p>
<p>
<pre><code class="html">&lt;svg width="50" height="50"&gt;
 &lt;ellipse cx="25" cy="25" rx="15" ry="10" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
A Straight Line
</p>
<p>
<pre><code class="html">&lt;svg width="50" height="50"&gt;
  &lt;line x1="5" y1="5" x2="40" y2="40" stroke="gray" stroke-width="5"  />
&lt;/svg&gt;</code></pre>
</p>
<p>
A Polyline
</p>
<p>
<pre><code class="html">&lt;svg width="50" height="50"&gt;
  &lt;polyline fill="none" stroke="blue" stroke-width="2" 
    points="05,30
            15,30 
            15,20
            25,20
            25,10
            35,10" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
A Polygon
</p>
<p>
<pre><code class="html">&lt;svg width="50" height="50"&gt;
  &lt;polygon fill="yellow" stroke="blue" stroke-width="2" 
    points="05,30
            15,10 
            25,30" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
Then open the Initial.html file in the web browser to see the SVG Shapes.
</p>
<p>
<describe them>
</p>
<p>
Then take a look at the Developer Tools for the HTML Elements.
</p>
<p>
<describe them>
</p>
<p>
And that is The Syntax of basic SVG Objects.
</p>
        </div>
      </div>

    </div>

<hr>

<h3 id="lesson9">Adding an SVG Element<h3> 

<div>
    <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>
You can use the D3 .append operator to append SVG elements
</li>
<li>
The D3 .attr allows you to insert an attribute and assign it a value
</li>
<li>
Using the JavaScript/D3 chain syntax, you can add two attributes with their values to a tag you appended
</li>
<li>
The SVG circle simple shape needs a "cx", "cy" and "r" to be properly defined
</li>
<li>
You can use D3 to append an SVG circle simple shape as well as define the attribute value pairs of "cx", "cy", and "r"
</li>
<li>
The D3 style operator is a shortcut for setting the CSS style property for a given selection with the specified value you define
</li>
<li>
Because D3 is built on JavaScript and is constructed so that the chain syntax works, you can increase legibility of your code by assigning selections to JavaScript variables
</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lesson:
</strong>
</p>
<p>
<ul>
<li>
<a href="https://www.dashingd3js.com/lessons/adding-a-dom-element">Adding a DOM Element</a>
</li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            Adding an SVG Element
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
D3 Append Revisited
</strong>
</p>
<p>
<pre><code class="javascript">d3.selection.append(name)</code></pre>
</p>
<p>
First, let's take a look at the D3 Append Operator
</p>
<p>
This appends a new element with the specified name as the last child of each element in the current selection.
</p>
<p>
Then, it returns a new selection containing the APPENDED ELEMENTS.
</p>
<p>
In addition to appending HTML elements, one can also append SVG Elements.
</p>
<br>
<br>
<p>
<strong>
Setting Selection Attributes
</strong>
</p>
<p>
<pre><code class="javascript">d3.selection.attr(name[, value])</code></pre>
</p>
<p>
Next, lets take a look at the .attr operator.
</p>
<p>
This operator inserts an attribute and a value, if specified, into the elements in the selection.
</p>
<p>
Then it returns a selection.
</p>
<p>
<pre><code class="html">&lt;tag attribute="value"&gt;Marmalade&lt;/tag&gt;</code></pre>
</p>
<p>
The structure of the HTML markup, is that there is a tag that contains attributes that have values.
</p>
<p>
<pre><code class="html">&lt;svg width="50" height="50"&gt; ... &lt;/svg&gt;</code></pre>
</p>
<p>
In the case of this SVG statement
</p>
<p>
<ul>
<li>The tag is SVG</li>
<li>The attributes are width and height</li>
<li>and the values are 50 and 50</li>
</ul>
</p>
<p>
<pre><code class="javascript">d3.selection.attr(name[, value])</code></pre>
</p>
<p>
Which means that given a selection, D3 allows us to add a tag attribute and its values.
</p>
<p>
* Note, only one attribute and value can be added at a time.
</p>
<p>
<pre><code class="javascript">d3.selection.attr(name[, value]).attr(name[, value])</code></pre>
</p>
<p>
So to add two attributes, you will have to use the chain syntax.
</p>
<p>
<pre><code class="html">&lt;svg width="50" height="50"&gt; ... &lt;/svg&gt;</code></pre>
</p>
<p>
Which means we can convert the SVG statement to the following:
</p>
<p>
<pre><code class="javascript">d3.selection.attr("width","50").attr("height","50");</code></pre>
</p>
<br>
<br>
<p>
<strong>
Circle Example
</strong>
</p>
<p>
<pre><code class="html">&lt;svg width="50" height="50"&gt;
  &lt;circle cx="25" cy="25" r="25" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
We will use this SVG circle as the example:
</p>
<p>
Closeup of text file
</p>
<p>
Talk about the SVG already there in the div svg_by_hand
</p>
<p>
Talk about how we are going to write in the command line first.
</p>
<p>
Closeup of the HTML web page with the JavaScript editor open
</p>
<p>
Talk about how / why reload the browser frequently
</p>
<br>
<p>
D3 check
</p>
<p>
<pre><code class="javascript">d3.version;</code></pre>
</p>
<p>
Check the D3 version to make sure it is working
</p>
<p>
reload the browser
</p>
<br>
<p>
Make sure the right DIV is selected			
</p>
<p>
<pre><code class="javascript">d3.select(".svg_by_d3");</code></pre>
</p>
<p>
Select the class
</p>
<p>
<pre><code class="javascript">d3.select(".svg_by_d3").append("p");</code></pre>
</p>
<p>Append a paragraph element to it.
</p>
<p>
<pre><code class="javascript">d3.select("p").remove();</code></pre>
</p>
<p>
Remove the paragraph element that was just added
</p>
<p>
Reload the browser
</p>
<br>
<p>
Add in the SVG tag
</p>
<p>
<pre><code class="javascript">d3.select(".svg_by_d3").append("svg");</code></pre>
</p>
Use the arrow key to see previous commands to save on the typing
<p>
Append the SVG tag // Browser
</p>
<p>
Reload the browser
</p>
<br>
<p>
Next we add in the attributes to the SVG tag
</p>
<p>
<pre><code class="javascript">d3.select(".svg_by_d3").append("svg").attr("width","50").attr("height","50");</code></pre>
</p>
<p>
Using the chain syntax, we select the SVG element and add two attributes to the SVG tag.
</p>
<p>
With the width attribute being 50 and the height attribute being 50
</p>
<p>
Which you can see in the html elements
</p>
<p>
Reload the browser
</p>
<br>
<p>
Next we add in a circle to the SVG
</p>
<p>
<pre><code class="javascript">d3.select(".svg_by_d3").append("svg").attr("width","50").attr("height","50").append("circle");</code></pre>
</p>
<p>
You can see that the command added a CIRCLE tag within the SVG
</p>
<p>
__BROWSER__ If you look at the circle that was added versus the previous circle, you can see that the previous circle had three attributes - a cx, a cy, and an r attribute
</p>
<p>
Press the up arrow and let's add these attributes
</p>
<br>
<p>
Next we add in three attributes to the SVG Circle
</p>
<p>
<pre><code class="javascript">d3.select(".svg_by_d3").append("svg").attr("width","50").attr("height","50").append("circle").attr("cx","25").attr("cy","25").attr("r","25");</code></pre>
</p>
<p>
You can see that we can continue chaining commands all day long.
</p>
<p>
__BROWSER__ From here you can see that when we added the attributes to the CIRCLE SVG element, the web browser figured out how to represent it visually.
</p>
<p>
And that is how you add an SVG element
</p>
<br>
<br>
<p>
<strong>
D3 Style Operator
</strong>
</strong>
</p>
<p>
<pre><code class="javascript">selection.style(name[, value[, priority]])</code></pre>
</p>
<p>
The Style Operator, if a name and value is specified, sets the CSS style property for the given selection with the given specified value.
</p>
<p>
The circle just created was a black circle.
</p>
<p>
How do we change the color to blue?
</p>
<p>
One way is to add an attribute called fill and give it the value of blue
</p>
<p>
<pre><code class="javascript">d3.select(".svg_by_d3").append("svg").attr("width","50").attr("height","50").append("circle").attr("cx","25").attr("cy","25").attr("r","25").attr("fill","blue");</code></pre>
</p>
<p>
This does exactly what we wanted - to color the circle blue.
</p>
<p>
However, D3 comes with a proper Style Operator.
</p>
<p>
<pre><code class="javascript">d3.select(".svg_by_d3").append("svg").attr("width","50").attr("height","50").append("circle").attr("cx","25").attr("cy","25").attr("r","25").style("fill","blue");</code></pre>
</p>
<p>
This does exactly what we wanted as well - to color the circle blue;
</p>
<p>
Why then would you want to use the style operator to style elements?
</p>
<p>
Because style behaves more consistently with external stylesheets.
</p>
<p>
The .style operator ensures the element-specific style takes priority over all other styles.
</p>
<br>
<br>
<p>
<strong>
D3 Legibility through JS variables
</strong>
</p>
<p>
<pre><code class="javascript">d3.select(".svg_by_d3").append("svg").attr("width","50").attr("height","50").append("circle").attr("cx","25").attr("cy","25").attr("r","25").style("fill","blue");</code></pre>
</p>
<p>	
Thus far we have chained our D3 commands to come up with this mess.
</p>
<p>
While it is readable, it is hard to keep track of
</p>
<p>
<ul>
<li>what the selection is</li>
<li>what has been appended</li>
<li>what attributes and values were given to it</li>
<li>and what if/any style has been added to the elements</li>
</ul>
</p>
<p>
We are in luck for three reasons
</p>
<p>
<ol>
<li>D3 is built on top of JavaScript so whitespaces between function chaining is ignored</li>
<li>Almost everything in D3 returns a selection</li>
<li>Those selections can be assigned to variables using JavaScript</li>
</ol>
</p>
<p>
<pre><code class="javascript">d3.select(".svg_by_d3").append("svg").attr("width","50").attr("height","50").append("circle").attr("cx","25").attr("cy","25").attr("r","25").style("fill","blue");</code></pre>
</p>
<p>
Which means we can go from this to this:
</p>
<p>
<pre><code class="javascript">var divSelection = d3.select(".svg_by_d3");

var svgSelection = divSelection.append("svg").attr("width","50").attr("height","50");

var circleSelection = svgSelection.append("circle").attr("cx","25").attr("cy","25").attr("r","25").style("fill","blue");</code></pre>
</p>
<p>
Which when typed into the console, works as follows:
</p>
<p>
Show on the screen
</p>
<p>
Reload the web page
</p>
<p>
Type out the information
</p>
<p>
<pre><code class="javascript">var divSelection = d3.select(".svg_by_d3");
var svgSelection = divSelection.append("svg").attr("width","50").attr("height","50");
var circleSelection = svgSelection.append("circle").attr("cx","25").attr("cy","25").attr("r","25").style("fill","blue");</code></pre>
</p>
<p>
Point out the three variables with the mouse
</p>
<p>
Press Return
</p>
<p>
The blue circle shows up
</p>
<p>
Click on the elements above to show that the circle showed up.
</p>
<p>
And that is how you can increase D3 Legibility through JS variables
</p>
<p>
</p>
<p>
Lastly, we can add this into the html file and properly format it.
</p>
<p>
<pre><code class="javascript">var divSelection = d3.select(".svg_by_d3");

var svgSelection = divSelection.append("svg")
    .attr("width","50")
    .attr("height","50");

var circleSelection = svgSelection.append("circle")
    .attr("cx","25")
    .attr("cy","25")
    .attr("r","25")
    .style("fill","blue");</code></pre>
</p>
<p>
This makes it much easier to read and understand.
</p>
        </div>
      </div>

</div>    


<hr>

<h3 id="lesson10">D3 Data Operator<h3> 
<div>
    
    <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>
The D3 Data Operator takes in an array of data
</li>
<li>
The D3 Data Operator joins a specified array of data with the current selection
</li>
<li>
The D3 Data Operator can join any type of JavaScript "thing" with the selection
</li>
<li>
Because the D3 Data Operator takes in an array of data, there is no "theoretical" limit to how many pieces of data you can bind (practically, you run into browser limitations)
</li>
<li>
Because there can be a mismatch between your data array and your D3 selection, D3 takes care of you and assigns various "things" to separate selections (which we cover in other videos)
</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lesson:
</strong>
</p>
<p>
<ul>
<li>
<a href="https://www.dashingd3js.com/lessons/d3-selections">D3 Selections</a>
</li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 Data Operator
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
D3 Data Operator
</strong>
</p>
<p>
<pre><code class="javascript">d3.selection.data([values[, key]])</code></pre>
</p>
<p>
First, let's take a look at the D3 Data Operator
</p>
<p>
This joins the specified array of data with the current selection.
</p>
<p>
Lets first take a look at how the data operator behaves with one data point
</p>
<br>
<p>
Insert a Paragraph Element
</p>
<p>
<pre><code class="javascript">d3.select("body").insert("p");</code></pre>
</p>
<p>
Using a new bare bones HTML file
</p>
<p>
We select the body
</p>
<p>
And insert a paragraph element
</p>
<p>
BROWSER - Click on the body tag to expand it
</p>
<p>
and you can see that the paragraph element has been inserted into the HTML document.
</p>
<br>
<p>
Let's look at the properties of the "p" element
</p>
<p>
<pre><code class="javascript">d3.select("p");</code></pre>
</p>
<p>
BROWSER - Click on the Array in the command line
</p>
<p>
BROWSER - Click on the zero index element
</p>
<p>
BROWSER - Highlight the accessKey: "" as the first property
</p>
<p>
As you can see, this paragraph element has many properties.
</p>
<p>
Notice that the first property of the paragraph element is the accessKey
</p>
<br>
<p>
Now, let's attach an array of 1 number to this paragraph element
</p>
<p>
<pre><code class="javascript">d3.select("p").data([1]);</code></pre>
</p>
<p>
First, select the paragraph element
</p>
<p>
Then chain the data command to the selection
</p>
<p>
With an array that contains one data element
</p>
<p>
BROWSER - Click on the Array in the command line
</p>
<p>
BROWSER - Click on the zero index element
</p>
<p>
BROWSER - Highlight the __data__: 1
</p>
<p>
You can see all the the paragraph element's properties.
</p>
<p>
Notice that the first property is now something called underscore underscore data underscore underscore
</p>
<p>
This is where D3 binds the data
</p>
<p>
In this case, it was the number one.
</p>
<p>
The single element inside of the array we passed to the paragraph selection.
</p>
<br>
<p>
Now, let's attach an array of 3 numbers to this paragraph element
</p>
<p>
<pre><code class="javascript">d3.select("p").data([[1,2,3]]);</code></pre>
</p>
<p>
Instead of having a single number as the first element of this array
</p>
<p>
The first element is now itself an array containing three numbers
</p>
<p>
BROWSER - Click on the Array in the command line
</p>
<p>
BROWSER - Click on the zero index element
</p>
<p>
BROWSER - Highlight the __data__: Array[3]
</p>
<p>
BROWSER - Click on __data__ arrow
</p>
<p>
BROWSER - Highlight the three numbers and the length of the array
</p>
<p>
You can see that the first property of the paragraph element (data) is Array brackets 3
</p>
<p>
Two things to notice
</p>
<p>
One - we successfully attached an array of 3 numbers to the paragraph element
</p>
<p>
Two - the Array brackets 3 is telling us the length of the array
</p>
<p>
When we click into the array
</p>
<p>
We can see the three numbers from our array as well as their respective indecies	
</p>
<br>
<p>
Now, let's attach a function to this paragraph element
</p>
<p>
<pre><code class="javascript">d3.select("p").data([ function returnThree() { return 3; } ]);</code></pre>
</p>
<p>
This time the first element of the array is a JavaScript function
</p>
<p>
This function named returnThree returns the number 3
</p>
<p>
BROWSER - Click on the Array in the command line
</p>
<p>
BROWSER - Click on the zero index element
</p>
<p>
BROWSER - Highlight the __data__: function returnThree() { return 3; }
</p>
<p>
BROWSER - Click on __data__ arrow
</p>
<p>
BROWSER - Highlight the arguments, caller, length and name
</p>
<p>
You can see that the data property is now the function defined in the array passed to the data operator
</p>
<p>
Notice that the name property contains the name of the function
</p>
<p>
If the function was an anonymous function, the name property would be an empty string
</p>
<br>
<p>
Lastly, let's attach a JavaScript Object to this paragraph element
</p>
<p>
<pre><code class="javascript">d3.select("p").data([ superwoman = { "gender": "female", "transportation": "flying" } ]);</code></pre>
</p>
<p>
We haven't yet covered JavaScript Object Literals or JavaScript Associative Arrays
</p>
<p>
For now, trust me that the way superwoman is defined creates a JavaScript Object
</p>
<p>
BROWSER - Click on the Array in the command line
</p>
<p>
BROWSER - Click on the zero index element
</p>
<p>
BROWSER - Highlight the __data__: Object
</p>
<p>
BROWSER - Click on __data__ arrow
</p>
<p>
BROWSER - Highlight the gender, and transportation
</p>
<p>
You can see that the data property is now the Object defined in the array passed to the data operator
</p>
<p>
You can see each name, value pair for the object
</p>
<br>
<p>
In each of these cases, we were binding 1 piece of data (be it a value, function, array or object) to one DOM element.
</p>
<br>
<br>
<p>
<strong>
D3 Data Operator with many Data Values
</strong>
</p>
<p>
<pre><code class="javascript">d3.selection.data([values[, key]])</code></pre>
</p>
<p>
Let's continue to look at the D3 Data Operator
</p>
<p>
Remember that the Data Operator joins the specified array of data with the current selection.
</p>
<p>
This time however, instead of binding 1 piece of data, we are going to bind 2 pieces of data
</p>
<p>
Though 2 is a small number, what is learned here can be generalized to any number of Data points.
</p>
<br>
<p>
Insert a Paragraph Element
</p>
<p>
<pre><code class="javascript">d3.select("body").insert("p");
// Arrow up to get the same command
d3.select("body").insert("p");</code></pre>
</p>
<p>
BROWSER - Click on the body tag to expand it
</p>
<p>
Using the bare bones HTML file
</p>
<p>
We select the body and insert a paragraph element
</p>
<p>
then we insert another paragraph
</p>
<p>
and you can see, two paragraph elements has been inserted into the HTML document body	
</p>
<br>
<p>
Now - let's look at the properties of the "p" elements
</p>
<p>
<pre><code class="javascript">d3.selectAll("p");</code></pre>
</p>
<p>
BROWSER - Click on the Array in the command line
</p>
<p>
BROWSER - Click on the zero index element
</p>
<p>
BROWSER - Highlight the accessKey: "" as the first property
</p>
<p>
BROWSER - Click on the one index element
</p>
<p>
BROWSER - Highlight the accessKey: "" as the first property
</p>
<p>
BROWSER - Highlight the length: 2
</p>
<p>
As you can see, the selection Array contains the two paragraph elements that were inserted
</p>
<p>
When we click into each paragraph, you can see that the first property element is the accessKey
</p>
<p>
Also - notice that the selectAll Selection provides the length of the array which is the number of elements selected
</p>
<br>
<p>
Now, let's attach an array of 2 number to the paragraph elements
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").data([1, 2]);</code></pre>
</p>
<p>
First, select all the paragraph elements
</p>
<p>
Then chain the data command to the selection
</p>
<p>
With an array that contains two data elements
</p>
<p>
BROWSER - Click on the Array in the command line
</p>
<p>
BROWSER - Click on the zero index element
</p>
<p>
BROWSER - Highlight the __data__: 1
</p>
<p>
BROWSER - Click on the one index element
</p>
<p>
BROWSER - Highlight the __data__: 1
</p>
<p>
This command returned a selection containing the two paragraphs
</p>
<p>
When you click into each paragraph, you can see that the first property is now the data property
</p>
<p>
Second, you can see that the zero index paragraph element got the zero index data array point
</p>
<p>
and that the one index paragraph element got the one index data array point
</p>
<p>
This is generalizable to as many data points as you have
</p>
<p>
The first selection elements gets the first data point, the second element gets the second data point and so on and so forth
</p>
<br>
<p>
Now, let's attach an array of 3 numbers to each of the paragraph elements
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").data([ [1,2,3], [4,5,6] ]);</code></pre>
</p>
<p>
Instead of having single numbers as elements of the array, we now have arrays as elements of the array
</p>
<p>
The first element is now itself an array containing three numbers
</p>
<p>
The second element is now itself an array containing three numbers
</p>
<p>
BROWSER - Click on the Array in the command line
</p>
<p>
BROWSER - Click on the zero index element
</p>
<p>
BROWSER - Highlight the __data__: Array[3]
</p>
<p>
BROWSER - Click on __data__ arrow
</p>
<p>
BROWSER - Highlight the three numbers and the length of the array
</p>
<p>
BROWSER - Click on the one index element
</p>
<p>
BROWSER - Highlight the __data__: Array[3]
</p>
<p>
BROWSER - Click on __data__ arrow
</p>
<p>
BROWSER - Highlight the three numbers and the length of the array
</p>
<p>
Notice - we successfully attached an array of 3 numbers to each of the paragraph elements
</p>
<p>
When we click into each of the data arrays attached to each paragraph element
</p>
<p>
We can see the three numbers from our array as well as their respective indices
</p>
<br>
<p>
Now, let's attach a function to each of the paragraph elements
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").data([ function() { return 3; }, function() { return 4; } ]);</code></pre>
</p>
<p>
Instead of having single numbers as elements of the array, we now have functions as elements of the array
</p>
<p>
The first  element is now itself an anonymous function that when evaluated returns the number 3
</p>
<p>
The second element is now itself an anonymous function that when evaluated returns the number 4
</p>
<p>
BROWSER - Click on the Array in the command line
</p>
<p>
BROWSER - Click on the zero index element
</p>
<p>
BROWSER - Highlight the __data__: function() { return 3; }
</p>
<p>
BROWSER - Click on __data__ arrow
</p>
<p>
BROWSER - Highlight the arguments, caller, length and name
</p>
<p>
BROWSER - Click on the one index element
</p>
<p>
BROWSER - Highlight the __data__: function() { return 4; }
</p>
<p>
BROWSER - Click on __data__ arrow
</p>
<p>
BROWSER - Highlight the arguments, caller, length and name
</p>
<p>
Notice - we successfully attached an anonymous function to each of the paragraph elements
</p>
<p>
Because we used anonymous functions this time, the name property for each function is an empty string
</p>
<br>
<p>
Lastly, let's attach JavaScript Objects to the paragraph elements
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").data([ superwoman = { "gender":"female", "transportation":"flying" },batman = { "gender":"male", "transportation":"batmobile" } ]);</code></pre>
</p>
<p>
Instead of having single numbers as elements of the array, we now have JavaScript Objects as elements of the array
</p>
<p>
The first  element is now the superwoman javascript object
</p>
<p>
The second element is now the batman javascript object
</p>
<p>
BROWSER - Click on the Array in the command line
</p>
<p>
BROWSER - Click on the zero index element
</p>
<p>
BROWSER - Highlight the __data__: Object
</p>
<p>
BROWSER - Click on __data__ arrow
</p>
<p>
BROWSER - Highlight the gender, and transportation
</p>
<p>
BROWSER - Click on the one index element
</p>
<p>
BROWSER - Highlight the __data__: Object
</p>
<p>
BROWSER - Click on __data__ arrow
</p>
<p>
BROWSER - Highlight the gender, and transportation
</p>
<p>
You can see that the data property for each paragraph now contains the Objects defined in the array passed to the data operator
</p>
<p>
You can see each name, value pair for the object in each paragraph element
</p>
<br>
<p>
In each of these cases, we were binding 1 piece of data (be it a value, function, array or object) to one DOM element.
</p>
<p>
However, since we had several pieces of data and several DOM elements, 
</p>
<p>
the first data point gets bound to the first DOM element in the selection
</p>
<p>
the second data point gets bound to the second DOM element in the selection
</p>
<p>
and so on and so forth
</p>
<br>
<br>
<p>
<strong>
Mismatches between Data Points and DOM Elements
</strong>
</p>
<p>
<pre><code class="javascript">d3.selection.data([values[, key]])</code></pre>
</p>
<p>
So far we have covered how data attaches a data point to the DOM element
</p>
<p>
Then we covered what happens if we have more than 1 data point and more than 1 DOM element
</p>
<p>
Now we cover what happens if we have a mismatch between data points and DOM elements
</p>
<p>
That is
</p>
<p>
What if we have only one data point and many DOM elements
</p>
<p>
Or the other way around
</p>
<p>
What if we have more than one data point and only one DOM element
</p>
<br>
<p>
Make sure when the HTML is reloaded that we have highlighted the P in the bar of HTML elements
</p>
<br>
<p>First, let's attach an array of 1 number to a selection of two paragraph elements
</p>
<br>
<p>Insert a Paragraph Element
</p>
<p>
<pre><code class="javascript">d3.select("body").insert("p");</code></pre>
// Arrow up to get the same command
d3.select("body").insert("p");</code></pre>
</p>
<p>
BROWSER - Click on the body tag to expand it
</p>
<p>
Using the bare bones HTML file
</p>
<p>
We select the body and insert a paragraph element
</p>
<p>
then we insert another paragraph
</p>
<p>
and you can see, two paragraph elements has been inserted into the HTML document body	
</p>
<br>
<p>
Let's look at the properties of the "p" elements
</p>
<p>
<pre><code class="javascript">d3.selectAll("p");</code></pre>
</p>
<p>
BROWSER - Click on the Array in the command line
</p>
<p>
BROWSER - Click on the zero index element
</p>
<p>
BROWSER - Highlight the accessKey: "" as the first property
</p>
<p>
BROWSER - Click on the one index element
</p>
<p>
BROWSER - Highlight the accessKey: "" as the first property
</p>
<p>
BROWSER - Highlight the length: 2
</p>
<p>
As you can see, the selection Array contains the two paragraphs that were inserted
</p>
<p>
When we click into each paragraph, you can see that the first property element is the accessKey
</p>
<p>
Also - notice that the selectAll Selection provides the length of the array which is the number of elements selected
</p>
<br>
<p>
Now, let's attach an array of 1 number to the selection containing two paragraph elements
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").data([1]);</code></pre>
</p>
<p>
First, selectAll the paragraph elements
</p>
<p>
Then chain the data command to the selection
</p>
<p>
With an array that contains one data element
</p>
<p>
BROWSER - Click on the Array in the command line
</p>
<p>
BROWSER - Click on the zero index element
</p>
<p>
BROWSER - Highlight the __data__: 1
</p>
<p>
This command returned a selection containing the one paragraph element
</p>
<p>
When we click into the paragraph, you can see that the first property is now the data property
</p>
<p>
And this data property contains the number 1
</p>
<p>
So you can see that the first data point gets bound to the first element
</p>
<p>
That said, what happened to the second paragraph in the selection?
</p>
<p>
The result of the data operation is the update selection
</p>
<p>
This selection represents the selected DOM elements that were successfully bound to the specified data elements.
</p>
<p>
Which in this case, because there was only one data point and it got bound to the first paragraph means that the second paragraph is ignored.		
</p>
<p>
This is incredibly important and we'll cover this in great detail in the next video.
</p>
<br>
<p>
For now, let's look at the other scenario
</p>
<p>
Let's attach an array of 2 numbers to a selection of one paragraph element
</p>
<br>
<p>
Reload the page for a new fresh page
</p>
<p>
BROWSER - reload the page
</p>
<p>
BROWSER - Click on the Boy element
</p>
<br>
<p>
Insert one Paragraph Element
</p>
<p>
<pre><code class="javascript">d3.select("body").insert("p");</code></pre>
</p>
<p>
BROWSER - Click on the body tag to expand it
</p>
<p>
First, let's take a look at having one DOM element and more than one data point
</p>
<p>
We select the body and insert a paragraph element
</p>
<br>
<p>
Let's look at the properties of the "p" element
</p>
<p>
<pre><code class="javascript">d3.select("p");</code></pre>
</p>
<p>
BROWSER - Click on the Array in the command line
</p>
<p>
BROWSER - Click on the zero index element
</p>
<p>
BROWSER - Highlight the accessKey: "" as the first property
</p>
<p>
The first property of the paragraph element is the accessKey so we are working with a clean paragraph element
</p>
<br>
<p>
Now, let's attach an array of 2 numbers to this paragraph element
</p>
<p>
<pre><code class="javascript">d3.select("p").data([1, 2]);</code></pre>
</p>
<p>
First, select the paragraph element
</p>
<p>
Then chain the data command to the selection
</p>
<p>
With an array that contains the two data element
</p>
<p>
BROWSER - Click on the Array in the command line
</p>
<p>
BROWSER - Click on the zero index element
</p>
<p>
BROWSER - Highlight the __data__: 1
</p>
<p>
This command returned a selection containing the one paragraph element
</p>
<p>
When we click into the paragraph, you can see that the first property is now the data property
</p>
<p>
And this data property contains the number 1
</p>
<p>
So you can see that the first data point gets bound to the first element
</p>
<p>
That said, what happened to the second data point?
</p>
<p>
Look at the length property of the selection array
</p>
<p>
BROWSER - Highlight the length: 2
</p>
<p>
This says 2 even though we only see one paragraph element.
</p>
<p>
Keep this in the back of your mind, we will come back to explore what happened to the second data point in the next video.
</p>
<br>
<p>
In each of these cases, there was a mismatch between the number of DOM elements in the selection
</p>
<p>
and the Data Points we were passing into the Data operator
</p>
<p>
While the Data Operator attached the first data point to the first DOM element like we would expect
</p>
<p>
Some strange things happened when there were either extra data points or extra DOM elements.
</p>
<p>
We will cover what happened to these extras data points and extra DOM elements in the next Video.
</p>
        </div>
      </div>

</div>


<hr>

<h3 id="lesson11">D3 Update Selection<h3> 
    <div>
         <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>
The D3 Data Operator binds data to a DOM element's __data__ property
</li>
<li>
This "data" persists after the data operation, so that it is available on re-selection
</li>
<li>
The D3 Update Selection represents the DOM elements from the prior selection that were successfully bound to the specified data elements (remember - unless a key-function is specified, it's done left to right)
</li>
<li>
The D3 Exit Selection represents the DOM elements from the prior selection that were not successfully bound to the specified data elements
</li>
<li>
The D3 Enter Selection represents the data for which no corresponding existing DOM element was found
</li>
<li>
The D3 Enter Selection returns a selection of placeholder JavaScript objects
</li>
<li>
The D3 Enter Selection only allows the .append, .insert, and .select operators at this time
</li>
<li>
The D3 Enter Selection is only defined on selections returned by the D3 Data Operator
</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lesson:
</strong>
</p>
<p>
<ul>
<li>
<a href="https://www.dashingd3js.com/lessons/d3-data-operator">D3 Data Operator</a>
</li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 Update Selection
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
D3 Data Operator Revisited
</strong>
</p>
<p>
<pre><code class="javascript">d3.selection.data([values[, key]])</code></pre>
</p>
<p>
The D3 Data Operator joins the specified array of data with the current selection.
</p>
<p>
The specified value is an array of data values, such as an array of numbers or objects, or a function.
</p>
<p>
If a key function is not specified, then the first datum in the specified array is assigned to the first element in the current selection, the second datum to the second selected element, and so on.
</p>
<p>
When data is assigned to an element, it is stored in the property __data__, thus making the data "sticky" so that the data is available on re-selection.
</p>
<br>
<p>
Insert a Paragraph Element
</p>
<p>
<pre><code class="javascript">d3.select("body").insert("p");</code></pre>
</p>
<p>
Using a new bare bones HTML file
</p>
<p>
We select the body
</p>
<p>
And insert a paragraph element
</p>
<p>
BROWSER - Click on the body tag to expand it
</p>
<p>
as you can see, the paragraph element has been inserted into the HTML document.	
</p>
<br>
<p>
Let's attach an array of 3 numbers to this paragraph element
</p>
<p>
<pre><code class="javascript">d3.select("body").select("p").data([[1,2,3]]);</code></pre>
</p>
<p>
BROWSER - Click on the Array in the command line
</p>
<p>
BROWSER - Click on the zero index element
</p>
<p>
BROWSER - Highlight the __data__: Array[3]
</p>
<p>
BROWSER - Click on __data__ arrow
</p>
<p>
BROWSER - Highlight the three numbers and the length of the array
</p>
<p>
You can see that the first property of the paragraph element (the data property ) is Array brackets 3
</p>
<p>
When we click into the array
</p>
<p>
You can see the three numbers from our array as well as their respective indices
</p>
<br>
<br>
<p>
<strong>
D3 Update Selection
</strong>
</p>
<p>
<pre><code class="javascript">d3.selection.data([values[, key]])</code></pre>
</p>
<p>
returns the Update Selection
</p>
<p>
This Selection represents the DOM elements from the prior selection that were successfully bound to the specified data elements.
</p>
<p>
Again - this selection represents the DOM elements that were successfully bound to the specified data elements.
</p>
<p>
The Update selection also contains a references to both the enter selection and the exit selection
</p>
<p>
Which are both covered later in this video
</p>
<br>
<p>
Revisiting the example from the D3 Data Operator Video,
</p>
<p>
let's attach an array of 1 number to a selection of two paragraph elements
</p>
<br>
<p>
First we insert a Paragraph Element
</p>
<p>
<pre><code class="javascript">d3.select("body").insert("p").attr("class","p_one");
// Arrow up to get the same command
d3.select("body").insert("p").attr("class","p_two");</code></pre>
</p>
<p>
BROWSER - Click on the body tag to expand it
</p>
<p>
Using the bare bones HTML file
</p>
<p>
We select the body and insert a paragraph element with class p_one
</p>
<p>
Then we insert another paragraph with class p_two
</p>
<p>
And as you can see, two paragraph elements have been inserted into the HTML document body
</p>
<br>
<p>
Now, let's attach an array of 1 number to the selection containing two paragraph DOM elements
</p>
<p>
<pre><code class="javascript">d3.select("body").selectAll("p").data([1]);</code></pre>
</p>
<p>
First, selectAll the paragraph elements
</p>
<p>
Then chain the data command to the selection with an array that contains the one data element
</p>
<p>
BROWSER - Click on the Array in the command line
</p>
<p>
BROWSER - Click on the zero index element
</p>
<p>
BROWSER - Highlight the __data__: 1
</p>
<p>
This command returned a selection array containing the one paragraph element
</p>
<p>
This selection is called the Update Selection
</p>
<p>
When we click into the array
</p>
<p>
You can see the paragraph p_one is the only paragraph in the selection
</p>
<p>
When we click into the paragraph, you can see that the first property is now the data property
</p>
<p>
And this data property contains the number 1
</p>
<p>
Since there was only one data point, it was bound to the first DOM element.
</p>
<p>
So the selection returned is that of the first DOM element because it was the only DOM element successfully bound to data.
</p>
<p>
The DOM element that was not bound now exists in the EXIT selection.
</p>
<p>
We cover the Exit Selection next.
</p>
<br>
<br>
<p>
<strong>
D3 Exit Selection
</strong>
</p>
<p>
<pre><code class="javascript">d3.selection.data(...).exit()</code></pre>
</p>
<p>
Once the Data Operator returns the Update Selection.
</p>
<p>
We can follow the reference to the Exit Selection.
</p>
<p>
The Exit Selection returns the DOM elements from the prior selection that were not successfully bound to the specified data elements in the Data Operator.
</p>
<p>
Note - the exit selection method is only defined on selections returned by the Data Operator
</p>
<br>
<p>
We revisit the example of attaching an array of 1 number to a selection of two paragraph elements
</p>
<br>
<p>
First, insert a Paragraph Element
</p>
<p>
<pre><code class="javascript">d3.select("body").insert("p").attr("class","p_one");
// Arrow up to get the same command
d3.select("body").insert("p").attr("class","p_two");</code></pre>
</p>
<p>
We insert two paragraph DOM elements
</p>
<p>
BROWSER - click to show they are there
</p>
<p>
BROWSER - click back on the command line
</p>
<br>
<p>
Next let's attach the array of 1 number to the selection containing two paragraph elements
</p>
<p>
<pre><code class="javascript">var updateSelection = d3.select("body").selectAll("p").data([1]);</code></pre>
</p>
<p>
This time, we assign the selection returned (the update selection) to a variable called updateSelection
</p>
<p>
<pre><code class="javascript">updateSelection;</code></pre>
</p>
<p>
BROWSER - Click on the Array in the command line
</p>
<p>
BROWSER - Highlight index 0 element
</p>
<p>
This selection is called the Update Selection
</p>
<p>
This command returned a selection containing the one paragraph element
</p>
<p>
We check to see what is in the updateSelection variable by clicking into the array
</p>
<p>
BROWSER - Click on the zero index element
</p>
<p>
BROWSER - Highlight the __data__: 1
</p>
<p>
When we click into the array
</p>
<p>
You can see the paragraph p_one is the only paragraph in the selection
</p>
<p>
This is expected
</p>
<br>
<p>
Now, let's follow the reference from the UPDATE selection to the EXIT Selection
</p>
<p>
<pre><code class="javascript">updateSelection.exit();</code></pre>
</p>
<p>
To follow the reference we use the chain syntax to select the exit selection.
</p>
<p>
The selection that is returned is the selection of DOM elements that were not successfully bound to the data in the Data Operator.
</p>
<p>
When we click into the array
</p>
<p>
You can see the paragraph p_two is the only paragraph in the selection
</p>
<p>
BROWSER - Highlight p.p_two
</p>
<p>
This makes sense.
</p>
<p>
The first data point that was bound to the first DOM element in the prior selection was p_one
</p>
<p>
So p_two did not get any data points.
</p>
<p>
Which is why it is in the EXIT selection
</p>
<p>
BROWSER - Highlight accessKey
</p>
<p>
Which you can see by the fact that the first property of the paragraph is the access key
</p>
<p>
Now we've covered what happened to the second paragraph element when there were more DOM elements than data points
</p>
<br>
<p>
And that is the basics of the D3 Exit Selection
</p>
<p>
Next we cover what happens when there are more data points than DOM elements.
</p>
<br>
<br>
<p>
<strong>
D3 Enter Selection
</strong>
</p>
<p>
<pre><code class="javascript">d3.selection.data(...).enter()</code></pre>
</p>
<p>
Once the Data Operator returns the Update Selection.
</p>
<p>
We can follow the reference to the Enter Selection.
</p>
<p>
The Enter Selection returns the placeholder elements for each data element for which no corresponding existing DOM element was found
</p>
<p>
Note - the enter selection method is only defined on selections returned by the Data Operator
</p>
<p>
Also - the enter selection only defines the append, insert and select operators.
</p>
<p>
Once one of these three operators has been used, you can modify the contents of the selection.
</p>
<br>
<p>
Let's attach an array of 2 numbers to a selection of one paragraph element
</p>
<p>
Insert a Paragraph Element
</p>
<p>
<pre><code class="javascript">d3.select("body").insert("p").attr("class","p_one");</code></pre>
</p>
<p>
We insert one paragraph DOM element with a class of p_one.
</p>
<p>
BROWSER - click to show they are there
</p>
<br>
<p>
Next, let's attach an array of 2 numbers to this paragraph element selection
</p>
<p>
<pre><code class="javascript">var updateSelection = d3.select("body").select("p").data([1, 2]);</code></pre>
</p>
<p>
This time, we assign the selection returned (the update selection) to a variable called updateSelection
</p>
<p>
<pre><code class="javascript">updateSelection;</code></pre>
</p>
<p>
BROWSER - Click on the Array in the command line
</p>
<p>
BROWSER - Click on the zero index element
</p>
<p>
BROWSER - Highlight the __data__: 1
</p>
<p>
This command returned a selection containing the one paragraph element
</p>
<p>
This selection is called the Update Selection
</p>
<p>
We check to see what the updateSelection variable is
</p>
<p>
When we click into the array
</p>
<p>
You can see the paragraph p_one is the only paragraph in the selection
</p>
<p>
This is expected
</p>
<p>
Where did the second data point go?
</p>
<br>
<p>
Now, let's follow the reference from the UPDATE selection to the ENTER Selection
</p>
<p>
<pre><code class="javascript">updateSelection.enter();</code></pre>
</p>
<p>
To follow the reference we use the chain syntax to select the ENTER selection.
</p>
<p>
The Enter Selection returns the placeholder elements for each data element for which no corresponding existing DOM element was found
</p>
<p>
When we click into the array
</p>
<p>
We see a JavaScript Object
</p>
<p>
When we click into the JavaScript Object
</p>
<p>
We see the data point that we were missing - the number 2!
</p>
<p>
This second data point was bound to a JavaScript object to serve as a placeholder element since no corresponding existing DOM element was found.
</p>
<br>
<p>
Lastly, let's take a look at how most D3 visualizations are constructed.
</p>
<p>
BROWSER - Reload
</p>
<p>
<pre><code class="javascript">var updateSelection = d3.select("body").selectAll("p").data([1, 2,3,4,5]);</code></pre>
</p>
<p>
Usually, they start with an empty HTML document that contains no DOM elements other than the HTML, head and body tags and a JavaScript link to the D3 library.
</p>
<p>
In this case, we select all the paragraph elements.
</p>
<p>
As there are none, we are attaching our data array to empty the paragraph selection.
</p>
<p>
<pre><code class="javascript">updateSelection;</code></pre>
</p>
<br>
<p>
Now, let's follow the reference from the UPDATE selection to the ENTER Selection
</p>
<p>
<pre><code class="javascript">updateSelection.enter();</code></pre>
</p>
<p>
BROWSER - Click on the Array in the command line
</p>
<p>
BROWSER - Starting from the bottom click into each Object and leave them open
</p>
<p>
As you can see, D3 created 5 placeholder elements for each of the 5 data points that were not bound to any existing DOM elements.
</p>
<br>
<p>
And that is the basics of the D3 Enter Selection
</p>
        </div>
      </div>

</div>
  
<hr>

<h3 id="lesson12">Binding Data to DOM Elements<h3> 
    
    <div>
    <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>
The D3 Data Operator returns the placeholder elements for each data element for which no corresponding existing DOM element was found
</li>
<li>
The Basic D3 Visualization Pattern is .select, .data, .enter, and .append
</li>
<li>
The D3 Append Operator appends a new element with the specified name as the last child of each element in the current selection
</li>
<li>
Each new element inherits the data of the current elements in the selection, if it's available
</li>
<li>
To Bind Data to DOM elements that do not yet exist - first do the .data join, then select the .enter selection, finally append elements so that each element inherits data from the placeholder elements in the enter selection
</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<ul>
<li>
<a href="https://www.dashingd3js.com/lessons/d3-data-operator">D3 Data Operator</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/d3-update-selection">D3 Update Selection</a>
</li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            Binding Data to DOM Elements
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
D3 Enter Selection Revisited
</strong>
</p>
<p>
<pre><code class="javascript">d3.selection.data(...).enter()</code></pre>
</p>
<p>
The Enter Selection returns the placeholder elements for each data element for which no corresponding existing DOM element was found
</p>
<p>
Note - the enter selection method is only defined on selections returned by the Data Operator
</p>
<p>
Also - the enter selection only defines the append, insert and select operators.
</p>
<p>
Once one of these three operators has been used, you can modify the contents of the selection.
</p>
<br>
<p>
First, let's insert a Paragraph Element
</p>
<p>
<pre><code class="javascript">d3.select("body").insert("p");</code></pre>
</p>
<p>
BROWSER - Click on the body tag to expand it
</p>
<p>
Using a new barebones html file
</p>
<p>
We select the body and insert a paragraph element
</p>
<p>
As you can see, the paragraph element has been inserted into the HTML document.
</p>
<br>
<p>Next, let's attach an array of 3 numbers to this paragraph element
</p>
<p>
<pre><code class="javascript">updateSelection = d3.select("body").select("p").data([1,2]);
updateSelection.enter();</code></pre>
</p>
<p>
BROWSER - Click on the Array in the command line
</p>
<p>
BROWSER - Click on the one index element
</p>
<p>
BROWSER - Highlight the object and __data__: 2
</p>
<p>
This is the Enter Selection referenced from the D3 Update Selection.
</p>
<p>
You can see the placeholder JavaScript Object for the data element for which no corresponding existing DOM element was found
</p>
<p>
This is where the second data point, the number 2, was stored.
</p>
<br>
<p>
Next we review the D3 Visualization Pattern to see where we are and what we still need to cover
</p>
<br>
<br>
<p>
<strong>
D3 Visualization Pattern Revisited
</strong>
</p>
<p>
The Basic D3 Visualization Pattern is
</p>
<p>
<ol>
<li>.select</li>
<li>.data</li>
<li>.enter()</li>
<li>.append</li>
</ol>
</p>
<p>
This selects the elements that you are going to use, attaches data to them and creates them on the screen.
</p>
<br>
<p>
Picture of the Bubble Chart
<br>
We saw this pattern in the Bubble Chart
</p>
<br>
<p>
Picture of the Sunburst Partition
<br>
We saw this pattern in the Sunburst Partition
</p>
<br>
<p>
Picture of the Choropleth
<br>
We saw this pattern in the Choropleth
</p>
<br>
<p>
Picture of the Click-to-Zoom via Transform Map
<br>
and lastly, we saw this pattern in the Click-to-Zoom via Transform Map
</p>
<br>
<p>
As you can see, no matter how varied the visualization, the main pattern is .select, .data, .enter, and .append.
</p>
<br>
<p>
Next we review the append operator.
</p>
<br>
<br>
<p>
<strong>
D3 Append Operator Revisited
</strong>
</p>
<p>
<pre><code class="javascript">d3.selection.append(name)</code></pre>
</p>
<p>
The D3 Append Operator appends a new element with the specified name as the last child of each element in the current selection.
</p>
<p>
Each new element inherits the data of the current elements in the selection, if any.
</p>
<br>
<p>
Picture of the place holder elements.
</p>
<p>
This is important because in the case of the ENTER SELECTION, this allows the appended elements to inherit the data of our place holder elements.
</p>
<p>
Then, it returns a new selection containing the APPENDED ELEMENTS.
</p>
<br>
<p>
Next we cover how Binding Data to DOM Elements happens.
</p>
<br>
<br>
<p>
<strong>
Binding Data to DOM Elements
</strong>
</p>
<p>
First, we create a variable with the update Selection
</p>
<p>
<pre><code class="javascript">var updateSelection = d3.select("body").selectAll("p").data([1,2,3,4,5]);</code></pre>
</p>
<p>
Using a new barebones html file
</p>
<p>
We define the updateSelection variable as a selection of all the paragraphs that we have attached the data elements to.
<p>
<pre><code class="javascript">updateSelection;</code></pre>
</p>
<br>
<p>
Next, we look at the enter selection to see the placeholder elements
</p>
<p>
<pre><code class="javascript">updateSelection.enter();</code></pre>
</p>
<p>
BROWSER - Click into the array
</p>
<p>
BROWSER - Click into element zero 
</p>
<p>
BROWSER - Click into element four
</p>
<p>
You can see all of the place holder JavaScript Object elements created to hold each of the data points
</p>
<p>
BROWSER - Close each element and then close the array
</p>
<p>
BROWSER - Click on the command line
</p>
<br>
<p>
Next, let's append a paragraph element to the ENTER selection
</p>
<p>
<pre><code class="javascript">var paragraphElements = updateSelection.enter().append("p");</code></pre>
</p>
<p>
This command appends a paragraph element for each of the JavaScript Object Place Holder Elements in the Enter Selection
</p>
<p>
BROWSER - Click on the <body> tag to show the 5 paragraph elements
</p>
<p>
BROWSER - Click on each of the 5 paragraph elements
</p>
<p>
As you can see, this has appended 5 paragraph elements to the HTML document Body
</p>
<p>
BROWSER - highlight d3.select("body")
</p>
<p>
It attached them to the HTML Document body because that was the initial selection we did.
</p>
<p>
The d3.select("body")
</p>
<br>
<p>
Now, let's take a look at what is inside of the paragraphElements variable
</p>
<p>
<pre><code class="javascript">paragraphElements;</code></pre>
</p>
<p>
As you can see the paragraphElements variable contains an array of length 5
</p>
<p>
BROWSER - Click into the array
</p>
<p>
When we click into the array, you can see the 5 paragraph elements
</p>
<p>
BROWSER - Click into the first element
</p>
<p>
BROWSER - Highlight the __data__: 1
</p>
<p>
When we click into one of the paragraph elements, you can see the data point that has been attached.
</p>
<p>
BROWSER - Close element one
</p>
<p>
BROWSER - Click into the second element
</p>
<p>
BROWSER - Highlight the __data__: 2
</p>
<p>
Each paragraph element now contains the data points that were in the initial data array
</p>
<p>
Each paragraph element inherited the data property from the JavaScript Object placeholder elements
</p>
<br>
<p>
Note, this works with any element, not only paragraphs.
</p>
<p>
Let's try it this time with HTML DIV elements
</p>
<p>
Arrow up and change the "p" to div and add DIV in the variable name
</p>
<p>
<pre><code class="javascript">var updateDivSelection = d3.select("body").selectAll("div").data([1,2,3,4,5]);</code></pre>
</p>
<br>
<p>
First, we define the updateDivSelection
</p>
<p>
Start typing, press the right hand key, then type the .enter()
</p>
<p>
<pre><code class="javascript">updateDivSelection.enter();</code></pre>
</p>
<p>
Then we look at the enter selection
</p>
<p>
BROWSER - Click into the array
</p>
<p>
BROWSER - Click into the first element
</p>
<p>
BROWSER - Close first element
</p>
<p>
BROWSER - Close the array
</p>
<br>
<p>
Next, let's append the html DIV elements to the enter selection
</p>
<p>
<pre><code class="javascript">var divElements = updateDivSelection.enter().append("div");</code></pre>
</p>
<p>
BROWSER - Click on the <body> tag to show the 5 DIV elements
</p>
<p>
BROWSER - Click on each of the 5 DIV elements
</p>
<p>
As you can see, this has appended 5 div elements to the HTML document Body
</p>
<p>
It attached them to the HTML Document body because that was the initial selection we did.
</p>
<p>
BROWSER - Highlight d3.select("body")
</p>
<br>
<p>
Finally, let's take a look at what is inside of the divElements variable
</p>
<p>
<pre><code class="javascript">divElements;</code></pre>
</p>
<p>
BROWSER - Click into the array
</p>
<p>
BROWSER - Click into the first element
</p>
<p>
BROWSER - Highlight the __data__: 1
</p>
<p>
BROWSER - Close element one
</p>
<p>
BROWSER - Click into the second element
</p>
<p>
BROWSER - Highlight the __data__: 2
</p>
<p>
When we click into the array, you can see the 5 DIV elements
</p>
<p>
When we click into one of the DIV elements, you can see the data point that has been attached.
</p>
<p>
As you can see, each DIV element now contains the data points that were in the initial data array
</p>
<p>
Each DIV element inherited the data property from the JavaScript Object placeholder elements
</p>
<br>
<p>
And that is how you do basic binding of data to DOM elements when those DOM elements did not exist before
</p>
<p>
First you do a select, then you attach data, then you select the enter selection from the update selection, and finally
</p>
<p>
you append elements so that each element inherits data from the placeholder elements in the enter selection.
        </div>
      </div>

</div>
        
    
<hr>

<h3 id="lesson13">JavaScript Functions<h3> 
    <div>
    <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>
A JavaScript function is a block of code that will be executed when you call it
</li>
<li>
A JavaScript function is written as a code block inside curly { } braces, preceded by the function keyword
</li>
<li>
A JavaScript function can take zero or more arguments or parameters
</li>
<li>
An anonymous JavaScript function is a JavaScript function that has not been given a name
</li>
<li>
Anonymous JavaScript functions are commonly used when the function is used immediately after being defined
</li>
<li>
JavaScript functions are first-class objects in JavaScript so you can assign a function to a JavaScript variable
</li>
<li>
Because JavaScript functions can be assigned to variables, it means you can pass functions as parameters or arguments to other functions
</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<ul>
<li>
<a href="https://www.dashingd3js.com/lessons/introduction-to-javascript">Introduction to JavaScript</a>
</li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            JavaScript Functions
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
Named JavaScript Functions
</strong>
</p>
<p>
<pre><code class="javascript">function functionName() {
    // some code	
}</code></pre>
</p>
<p>
This is a JavaScript Function
</p>
<p>
A function is a block of code that will be executed when you call it
</p>
<p>
A function is written as a code block inside curly { } braces, preceded by the function keyword
</p>
<p>
The code inside the function will be executed when you call the function
</p>
<br>
<p>
<pre><code class="javascript">functionName();</code></pre>
</p>
<p>
To call the JavaScript Function,
</p>
<p>
You have to type the functionName with open close parenthesis into the console or put it inside of a JavaScript script.
</p>
<br>
<p>
<pre><code class="javascript">function functionName(var1, var 2) {
    // some code
}
functionName(argument1, argument2);</code></pre>
</p>
<p>
When you call a function, you can pass along some values to it, these values are called arguments or parameters.
</p>
<p>
These arguments can then be used inside of the function.
</p>
<p>
You can send as many arguments as you like, separated by commas (,)
</p>
<p>
To use the arguments inside of the function, you must declare the arguments as variables when defining the function
</p>
<p>
The variables and arguments must be in expected order.
</p>
<p>
That is, The first argument gets assigned to the first variable.
</p>
<br>
<p>
<pre><code class="javascript">function functionName() {
    // some code
    return x;
}</code></pre>
</p>
<p>
Sometimes you may want your function to return a value back to where the function was called.
</p>
<p>
This is possible by using the return statement.
</p>
<p>
When the return statement is executed inside of the function two things happen:
</p>
<p>
One - the function will stop executing
</p>
<p>
and Two - the specified value, in this case x, is returned;
</p>
<br>
<p>
<pre><code class="javascript">function functionName() {
    // some code
    return x;
}
var returnVal = functionName();</code></pre>
</p>
<p>
You can assign the return value of a function to a variable.
</p>
<p>
In this case, when functionName returns the value x
</p>
<p>
It will be assigned to the variable returnedValue
</p>
<br>
<p>
Let's look at some examples:
</p>
<p>
First let's define a function
</p>
<p>
<pre><code class="javascript">function myFunction() {
    var a = 1 + 2;
}</code></pre>
</p>
<p>
This function is called myFunction
</p>
<p>
Note that it does not return any values
</p>
<br>
<p>
Next, let's evaluate the function
</p>
<p>
<pre><code class="javascript">myFunction();</code></pre>
</p>
<p>
Note that it returns undefined.
</p>
<p>
This is because we did not specify a return value
</p>
<br>
<p>
Now, let's re-define the function, and this time have it return a value
</p>
<p>
<pre><code class="javascript">function myFunction() {
    var a = 1 + 2;
    return a;
}
myFunction();</code></pre>
</p>
<p>
This time you can see that it has returned the value of three
</p>
<p>
Which is what we expect from the addition of one plus two.
</p>
<br>
<p>
Next, let's assign this return value to another variable
</p>
<p>
<pre><code class="javascript">var returnValue = myFunction();
returnValue;</code></pre>
</p>
<p>
First, we assign the myFunction return value to the returnValue variable
</p>
<p>
Then when we check the returnValue variable, we see that it is the number 3.
</p>
<br>
<p>
If we type myFunction into the command line without parentheses, we can see the function code
</p>
<p>
<pre><code class="javascript">myFunction;</code></pre>
</p>
<p>
This is useful when you are using a library like D3 or when you are writing your own functions
</p>
<p>
This lets you peer deep into the code of the function.
</p>
<br>
<p>
Next, let's take a look at Anonymous JavaScript Functions
</p>
<br>
<br>
<p>
<strong>
Anonymous JavaScript Functions
</strong>
</p>
<p>
<pre><code class="javascript">function () {
    // some code
    return x;
}</code></pre>
</p>
<p>
An anonymous function is a function that does not have a functionName
</p>
<p>
An anonymous function is commonly used when the function is used immediately after being defined
</p>
<br>
<p>
<pre><code class="javascript">var anonFunction = function () {
    // some code
};</code></pre>
</p>
<p>
You can assign an anonymous function to a JavaScript variable
</p>
<p>
You can then pass this variable to other functions or call the variable as a function itself
</p>
<br>
<p>
<pre><code class="javascript">var anonFunction = function () {
    // some code
};
anonFunction();</code></pre>
</p>
<p>
To call an anonymous function that has been assigned to a variable, you just call it by using the open and closing parentheses.	
</p>
<br>
<p>
<pre><code class="javascript">anonFunction;</code></pre>
</p>
<p>
To see what the function is, you can type out the function name but not use open and closing parentheses.
</p>
<p>
This will return the function code.
</p>
<br>
<p>
Let's look at some examples:
</p>
<br>
<p>
Let's define an anonymous functions that returns the number 3
</p>
<p>
<pre><code class="javascript">function () { return 3; }</code></pre>
</p>
<p>
When we type this in, it returns an error.
</p>
<p>
An error is returned because the function does not have a name that we can call.
</p>
<br>
<p>
To fix this, we assign the anonymous function to a variable
</p>
<p>
<pre><code class="javascript">var anonFunction = function () { return 3; };</code></pre>
</p>
<p>
In addition to allowing us to define an anonymous function, 
</p>
<p>
This also allows us to pass the function to other functions as a variable;
</p>
<br>
<p>
To call and evaluate the anonymous function in the anonFunction variable
</p>
<p>
we just use the parenthesis
</p>
<p>
<pre><code class="javascript">anonFunction();</code></pre>
</p>
<p>
As you can see, the number 3 is returned.
</p>
<br>
<p>
We can also see the function code if we leave off the parenthesis
</p>
<p>
<pre><code class="javascript">anonFunction;</code></pre>
</p>
<p>
And thus you can see the function code for the anonymous function
</p>
<br>
<p>
Next, let's take a look at passing JavaScript Functions as Variables
</p>
<br>
<br>
<p>
<strong>
Passing JavaScript Functions as Variables
</strong>
</p>
<p>
<pre><code class="javascript">function functionTwo(var1) {
    // some code
}
functionTwo(arg1);</code></pre>
</p>
<p>
Earlier we covered how you could call a function with an argument which would then be assigned to a value inside of the function.
</p>
<p>
In this case, we are passing argument one which is assigned to var1 inside of the function.
</p>
<br>
<p>
Highlight in green the functionOne name
</p>
<p>
<pre><code class="javascript">function functionOne() { return x; };
function functionTwo(var1) {
    // some code
}
functionTwo(functionOne);
</code></pre>
</p>
<p>
Because you can assign functions to variables, you can pass functions to other functions as variables
</p>
<p>
Which means that in this case, we are passing functionOne as a variable to be used inside of functionTwo
</p>
<p>
Inside of functionTwo, var1's value will be the functionOne
</p>
<br>
<p>
Let's look at some examples:
</p>
<br>
<p>
First, let's make the functionOne
</p>
<p>
<pre><code class="javascript">function functionOne() { return 7; };
functionOne;
functionOne();</code></pre>
</p>
<p>
You can see that we created a named JavaScript function that returns the number 7.
</p>
<br>
<p>
Next, let's make a function that takes in one variable.
</p>
<p>
<pre><code class="javascript">function functionTwo(functionVariable) {
    alert (functionVariable);
}</code></pre>
</p>
<p>
To show you that you can pass functions around as a variable, 
</p>
<p>
This function will take one argument
</p>
<p>
And then create an alert that tells us the argument's value.
</p>
<br>
<p>
First, let's test it with the number 5:
</p>
<p>
<pre><code class="javascript">functionTwo(5);</code></pre>
</p>
<p>From the alert, you can see that the functionTwo alerted us that the value we passed in was 5.
</p>
<br>
<p>
Next, let's test it with the function functionOne
</p>
<p>
<pre><code class="javascript">functionTwo(functionOne);</code></pre>
</p>
<p>
As you can see, we were able to pass in the functionOne function and have functionTwo alert us of the code of functionOne.
</p>
<br>
<p>
Now the important part...
</p>
<p>
Note, earlier we said that you had to assign the anonymous function to a variable to use it.
</p>
<p>
This is true for the most part.
</p>
<p>
When we can get away with not assigning an anonymous function to a variable is when it is passed directly to another function as an argument of the function.
</p>
<br>
<p>
<pre><code class="javascript">functionTwo( function(d) { return d; });</code></pre>
</p>
<p>
When we evaluate this expression, we see the anonymous function in the alert.
</p>
<p>
As you can see, we were able to pass an anonymous function to another function as a variable without having to assign to a name or a variable
</p>
<p>
This is because the function definition assigns the argument to a variable inside of the function for us.
</p>
<p>
This will come in very hand when we start using JavaScript functions inside of D3 Operators
</p>
<br>
<p>
And that is the basics of what you need to know right now of Passing JavaScript Functions as Variables.
</p>
        </div>
      </div>

</div>
        

<hr>

<h3 id="lesson14">Using Data Bound to DOM Elements<h3> 
    <div>
<!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>
The D3 Data Operator joins a specified array of data with the current selection
</li>
<li>
If the D3 Data Operator is called without an arguments, then it returns the __data__ property for each element in the selection
</li>
<li>
The D3 Text Operator is a shortcut for setting the text content of all selected elements to the specified value
</li>
<li>
If the value passed into the D3 Text Operator is a constant, then all the elements in the selection are given the same text content
</li>
<li>
If the value passed into the D3 Text Operator is a function, then the function is evaluated for each element in order they exist in the selection
</li>
<li>
Because JavaScript functions are first-class objects, we can pass JavaScript functions into D3 Operators
</li>
<li>
If the value passed into the D3 Text Operator is a function, then the value returned from the function evaluation of each selection element is set as the text content for that specific element.
</li>
<li>
Almost all D3 operators give you three variables you can use with functions passed into the operator - d (for __data__), i (for index of element in the selection), this (which refers to the actual selection element), and j (if you are working with nested data)
</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<ul>
<li>
<a href="https://www.dashingd3js.com/lessons/introduction-to-javascript">Introduction to JavaScript</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/d3-update-selection">D3 Update Selection</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/binding-data-to-dom-elements">Binding Data to DOM Elements</a>
</li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            Using Data Bound to DOM Elements
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
D3 Data Operator Revisited
</strong>
</p>
<p>
<pre><code class="javascript">d3.selection.data([values[, key]])</code></pre>
</p>
<p>
This is the D3 Data Operator
</p>
<br>
<p>
We have seen it before when we gave it values to bind to the selection
</p>
<p>
The Data Operator joins the specified array of data with the current selection	
</p>
<p>
<pre><code class="javascript">d3.selection.data()</code></pre>
</p>
<p>
What we did not cover was what happened if you called the data operator
</p>
<p>
Without any values inside.
</p>
<p>
When the Data Operator is called without any values, 
</p>
<p>
It returns the __data__ property for each element in the selection
</p>
<p>
In the same order that the elements in the selection are currently in.
</p>
<br>
<p>
Let's try it to see how it works.
</p>
<br>
<p>
We start with a bare bones HTML File
</p>
<br>
<p>
Let's attach a number to a paragraph element
</p>
<p>
<pre><code class="javascript">var pData = d3.select("body").selectAll("p").data([1]).enter().append("p");</code></pre>
</p>
<p>
This command should make sense to you now.
</p>
<p>
We select the body
</p>
<p>
We select the paragraph element
</p>
<p>
We bind Data to the paragraph element
</p>
<p>
We use the UPDATE selection to select the ENTER Selection
</p>
<p>
Then we append the paragraph element
</p>
<p>
So that it inherits the __data__ property from the placeholder element.
</p>
<p>
And by doing this we have bound data to the paragraph element.
</p>
<br>
<p>
When we look at pData
</p>
<p>
<pre><code class="javascript">pData;</code></pre>
</p>
<p>
BROWSER - Click into the array
</p>
<p>
BROWSER - Click into the first element
</p>
<p>
BROWSER - Highlight the __data__: 1
</p>
<p>
We can see that the number 1 was attached to the data property		
</p>
<br>
<p>
Now, let's call the D3 Data Operator without any values on the pData variable
</p>
<p>
<pre><code class="javascript">pData.data(); </code></pre>
</p>
<p>
You can see that this command returned the number 1 in an array.
</p>
<p>
D3 provides an easy way to get data out of the element or elements which contain the __data__ property.
</p>
<br>
<p>
Let's see what happens if we attach several numbers to several paragraph elements
</p>
<p>
<pre><code class="javascript">var manyPData = d3.select("body").selectAll("p").data([9,0,2,1,0]).enter().append("p");</code></pre>
</p>
<p>
This command should make sense to you as well.
</p>
<p>
We create 5 paragraph elements based on our array of 5 data points		
</p>
<br>
<p>
Now, let's look at manyPData
</p>
<p>
<pre><code class="javascript">manyPData;</code></pre>
</p>
<p>
BROWSER - Click into the array
</p>
<p>
BROWSER - Click into the first element
</p>
<p>
BROWSER - Click into the second element
</p>
<p>
BROWSER - Click into the third element
</p>
<p>
BROWSER - Click into the fourth element
</p>
<p>
BROWSER - Click into the fifth element
</p>
<p>
We can see that our data was attached to the data property of each paragraph element.	
</p>
<br>
<p>
Now, let's call the D3 Data Operator without any values on the manyPData variable
</p>
<p>
<pre><code class="javascript">manyPData.data();</code></pre>
</p>
<p>
You can see that this command returned the number attached to the selection's paragraph elements in an array.		
</p>
<br>
<p>
Finally, let's select the first paragraph in the HTML document
</p>
<p>
<pre><code class="javascript">var firstP = d3.select("body").select("p");</code></pre>
</p>
<br>
<p>
Because we use the select operator, we are grabbing the first Paragraph element in the document
</p>
<p>
<pre><code class="javascript">firstP;</code></pre>
</p>
<p>
BROWSER - click into the array and into the P element
</p>
<p>
Highlight the number 9
</p>
<p>
<pre><code class="javascript">firstP.data();</code></pre>
</p>
<p>
You can see that it returns an array that contains the number 9
</p>
<p>
Which is the data element from the first paragraph element in the document.	
</p>
<br>
<p>
Next we look at the D3 Text Operator
</p>
<br>
<br>
<p>
<strong>
D3 Text Operator
</strong>
</p>
<p>
<pre><code class="javascript">d3.selection.text([value])</code></pre>
</p>
<p>
This is the D3 Text Operator
</p>
<p>
If a value is specified, then it sets the text content of all the selected elements to the specified value.
</p>
<p>
If the value is constant, then all the elements are given the same text content.
</p>
<p>
If the value is a function, then the function is evaluated for each element in order.
</p>
<p>
We come back to passing functions to the text operator in the next section.
</p>
<br>
<p>
For now, let's look what happens when the value is constant.
</p>
<br>
<p>
Let's start with a single paragraph element which is given a data value.
</p>
<p>
<pre><code class="javascript">var pData = d3.select("body").selectAll("p").data([1]).enter().append("p");</code></pre>
</p>
<p>
This inserts a paragraph into the html document that has a data property of 1.
</p>
<p>
BROWSER - click into the HTML ELEMENTS BODY to expand it
</p>
<p>
BROWSER - Highlight the paragraph element.		
</p>
<br>
<p>
Now let's use the D3 Text Operator to give this paragraph some text.
</p>
<br>
<p>
<pre><code class="javascript">pData.text("Paragraph Power!");</code></pre>
</p>
<p>
We give it a constant value - the text string of "Paragraph Power!"
</p>
<p>
BROWSER - click into the paragraph Element
</p>
<p>
BROWSER - highlight the "Paragraph Power!" text
</p>
<p>
As you can see, D3 attached the "Paragraph Power!" text to the paragraph element in the selection.
</p>
<p>
Again - for the D3 Text Operator, if the value is constant then all of the elements in the selection are given the same text content.
</p>
<br>
<p>If we look at the pData variable
</p>
<p>
<pre><code class="javascript">pData;</code></pre>
</p>
<p>
And click into the arrays
</p>
<p>
BROWSER - Click into the array and the 0 index paragraph element
</p>
<p>
BROWSER - Scroll down to textContent
</p>
<p>
BROWSER - Highlight textContent
</p>
<p>
You can see that the D3 Text Operator sets the textContent property of the paragraph element for us.
</p>
<br>
<p>Let's reload the page and see what happens if we have more than 1 data point
</p>
<p>
<pre><code class="javascript">var fivePData = d3.select("body").selectAll("p").data([1,2,3,4,5]).enter().append("p");</code></pre>
</p>
<p>
BROWSER - click into the body element to show the 5 paragraphs
</p>
<br>
<p>
Next, let's use the D3 Text Operator to give the paragraphs some text
</p>
<p>
<pre><code class="javascript">fivePData.text("Paragraph Power!");</code></pre>
</p>
<p>
And with that you can see that each of the 5 paragraphs now has the text "Paragraph Power"
</p>
<p>
As was mentioned before, for the D3 Text Operator, if the value is constant then all of the elements in the selection are given the same text content.
</p>
<br>
<p>Let's look at the fivePData variable
</p>
<p>
<pre><code class="javascript">fivePData;</code></pre>
</p>
<p>
And click into the arrays
</p>
<p>
BROWSER - Click into the array and the 4 index paragraph element
</p>
<p>
BROWSER - Scroll down to textContent
</p>
<p>
BROWSER - Highlight textContent
</p>
<p>
As you can see, the D3 Text Operator set the textContent property of the paragraph element for us.
</p>
<p>
Which is the same for all of the elements.		
</p>
<br>
<p>
Next we take a look at using JavaScript Functions in D3 Operators.
</p>
<br>
<br>
<p>
<strong>
Using JavaScript Functions in D3 Operators
</strong>
</p>
<p>
<pre><code class="javascript">d3.selection.text([value])</code></pre>
</p>
<p>
This is the D3 Text Operator
</p>
<p>
If a value is specified, then it sets the text content of all selected elements to the specified value.
</p>
<p>
In the previous section, we saw that if the value is constant, then all the elements are given the same text content.
</p>
<p>
However, if the value is a function, then the function is evaluated for each element in order.
</p>
<p>
<pre><code class="javascript">d3.selection.text([function])</code></pre>
</p>
<p>
In the JavaScript Functions Video, we covered how you could pass a function to another function.
</p>
<p>
This is exactly what is happening here.
</p>
<p>
We are going to pass a function to the D3 Text Operator which itself is a function.
</p>
<p>
The D3 Text Operator then applies the function that we passed to each element in the selection
</p>
<p>
The function's return value is then used to set each element's inner HTML content.	
</p>
<br>
<p>
Let's try some simple examples to see how it works.
</p>
<br>
<p>
Let's start with the earlier 5 paragraph element example:
</p>
<p>
<pre><code class="javascript">var fivePData = d3.select("body").selectAll("p").data([1,2,3,4,5]).enter().append("p");</code></pre>
</p>
<p>
This gives inserts 5 paragraphs into the html document where each one has a data property.
</p>
<p>
BROWSER - click into the HTML ELEMENTS BODY to expand it
</p>
<p>
BROWSER - Mouse over the paragraph Elements
</p>
<br>
<p>
Next, let's define a simple function that returns the string "Function Power!"
</p>
<p>
<pre><code class="javascript">function myFunction () { return "Function Power!"; };
myFunction();</code></pre>
</p>
<p>
This function, when called returns the string "Function Power"	
</p>
<br>
<p>
Now, let's try passing the myFunction into the D3 Text Operator
</p>
<p>
<pre><code class="javascript">fivePData.text(myFunction);</code></pre>
</p>
<p>
As you can see, the myFunction function was applied to each of the 5 paragraph elements.
</p>
<p>
For each paragraph element, the function's return value was used to set each element's inner HTML content.
</p>
<p>
Since the return value of our function was the string "Function Power", each paragraph element got the string "Function Power"	
</p>
<br>
<p>
Let's reload the page and get the 5 paragraph element example loaded again:
</p>
<p>
<pre><code class="javascript">var fivePData = d3.select("body").selectAll("p").data([1,2,3,4,5]).enter().append("p");</code></pre>
</p>
<p>
This gives inserts 5 paragraphs into the html document where each one has a data property.
</p>
<p>
BROWSER - click into the HTML ELEMENTS BODY to expand it
</p>
<p>
BROWSER - Mouse over the paragraph Elements
</p>
<br>
<p>
As we covered in the JavaScript Function Video, we can also pass anonymous functions into other functions as arguments.
</p>
<p>
So instead of defining myFunction and then passing it into the D3 Text Operator,
</p>
<p>
Let's try to do it with an anonymous Function
</p>
<p>
<pre><code class="javascript">fivePData.text(function () { return "Anonymous Function Power!"; });</code></pre>
</p>
<p>
It works exactly the same way as when we passed in a named function into the D3 Text Operator
</p>
<p>
The function's return value is then used to set each element's inner HTML content.		
</p>
<br>
<p>
So now we are using JavaScript Functions within the Text Operator.
</p>
<p>
Since we are passing a function into the D3 Text Operator, does D3 tell us anything about the elements in the selection?
</p>
<br>
<br>
<p>
<strong>
Variables Available inside D3 Operators
</strong>
</p>
<p>
<pre><code class="javascript">d3.selection.text([function])</code></pre>
</p>
<p>
When you pass a function to a D3 Operator
</p>
<p>
The D3 operator applies the function that was passed to each element in the selection
</p>
<p>
It turns out that the D3 Operator also gives you three different variables to play with 
</p>
<p>
when you pass it a function
</p>
<br>
<p>
<pre><code class="javascript">d3.selection.text([function])
// d - the __data__ property of the element
// i - the index of the element
// this - the this context of the current DOM element</code></pre>
</p>
<p>
The three variables that D3 Operators give us are d, i and this.
</p>
<p>
The d is the data property of the element currently being evaluated
</p>
<p>
The i is the current index of the element being evaluated
</p>
<p>
Note, because D3 uses arrays, this index is zero based
</p>
<p>
And this - which is the THIS context of the current DOM element.
</p>
<p>
For now we focus on the d and i and leave the this for later.
</p>
<br>
<p>
<pre><code class="javascript">d3.selection.text([function])
// d - the __data__ property of the element
// i - the index of the element</code></pre>
</p>
<p>
What this means is that when we pass a function to the D3 Operator
</p>
<p>
We can assume that the d variable and the i variable will be passed as arguments to the function we pass in
</p>
<p>
Which means that we can use these d and i variables inside of the function.
</p>
<br>
<p>
Let's try some simple examples to see how it works.
</p>
<br>
<p>
We start with the earlier 5 paragraph element example:
</p>
<p>
<pre><code class="javascript">var fivePData = d3.select("body").selectAll("p").data([1,2,3,4,5]).enter().append("p");</code></pre>
</p>
<p>
BROWSER - click into the HTML ELEMENTS BODY to expand it
</p>
<p>
BROWSER - Mouse over the paragraph Elements
</p>
<br>
<p>
Next, let's define a simple function that takes in two arguments and returns a string telling us what those arguments were.
</p>
<p>
<pre><code class="javascript">function myFunction (d, i) {
    return "argument d: " + d + " ... argument i: " + i;
}</code></pre>
</p>
<p>
This function, when called with two arguments then returns a string.
</p>
<p>
<pre><code class="javascript">myFunction("Cup","Cake");</code></pre>
</p>
<p>
As you can see, the function took in two arguments and returned the string telling us what those arguments were.			
</p>
<br>
<p>
Now, let's try passing the myFunction into the D3 Text Operator
</p>
<p>
<pre><code class="javascript">fivePData.text(myFunction);</code></pre>
</p>
<p.
As you can see, the myFunction function was applied to each of the 5 paragraph elements.
</p>
<p.
For each paragraph element, the function's return value was used to set each element's inner HTML content.
</p>
<p.
Since the return value of our function was a string telling us the two arguments passed to it
</p>
<p.
We can see the data attribute for each paragraph element
</p>
<p.
As well as the index for each paragraph element within the D3 selection	
</p>
<br>
<p>
Let's reload the page and get the 5 paragraph element example loaded again:
</p>
<p>
<pre><code class="javascript">var fivePData = d3.select("body").selectAll("p").data([1,2,3,4,5]).enter().append("p");</code></pre>

</p>
<br>
<p>
This time, let's try it with an anonymous function.
</p>
<p>
So instead of defining myFunction and then passing it into the D3 Text Operator,
</p>
<p>
Let's try to do it with an anonymous Function
</p>
<p>
<pre><code class="javascript">fivePData.text(function (d,i) { return "argument d: " + d + " ... argument i: " + i; });</code></pre>
</p>
<p>
It worked exactly the same way as when we passed in a named function into the D3 Text Operator
</p>
<p>
The function's return value is used to set each element's inner HTML content.
</p>
<p>
And because we know the D3 Operator gives us the D and I variables to play with
</p>
<p>
We know that we can write an anonymous function that takes in these two values
</p>
<p>
Which means that we can write the code inside of the anonymous function to use these two values.
</p>
<br>
<p>
And with that - you can see how we can use the Data bound to DOM elements with D3
</p>
        </div>
      </div>    
        
    </div>


<hr>

<h3 id="lesson15">Creating SVG Elements from Data<h3> 
    <div>
         <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>
Because SVG graphics are written in XML, we can use D3 to create SVG tags and set their attributes with values
</li>
<li>
The SVG Basic Shapes are rectangle, circle, ellipse, straight line, polyline, polygon, and path
</li>
<li>
The SVG XML tags must live inside of an SVG &lt;svg&gt; tag to be properly interpreted by the browser as being SVG
</li>
<li>
The D3 Data Operator joins a specified array of data with the current selection
</li>
<li>
Because SVG is understood by the browser and lives in the DOM, we can bind data to the SVG elements using D3
</li>
<li>
Because SVG can have data bound to it with D3, it means we can use the data bound to the SVG elements to set their attributes and values
</li>
<li>
The D3 Style Operator, if a name and value are specified, sets the CSS style property for the given selection with the given specified value (whether constant or return value from a function)
</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<ul>
<li>
<a href="https://www.dashingd3js.com/lessons/fundamentals-of-svg">Fundamentals of SVG</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/adding-an-svg-element">Adding an SVG Element</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/binding-data-to-dom-elements">Binding Data to DOM Elements</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/using-data-bound-to-dom-elements">Using Data Bound to DOM Elements</a>
</li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            Creating SVG Elements from Data
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
SVG Revisited
</strong>
</p>
<p>
<pre><code class="html">&lt;svg&gt; ... &lt;/svg&gt;</code></pre>
</p>
<p>
SVG is a Vector Based Graphics system
</p>
<p>
The SVG system creates DOM objects for each graphical element.
</p>
<p>
The SVG element is commonly referred to as the SVG Viewport.
</p>
<p>
Things within the SVG Viewport dimension's are visible
</p>
<p>
Things inside the SVG tags though outside the Viewport dimensions are not visible.
</p>
<br>
<p>
SVG Basic Shapes
</p>
<ul>
<li>Rectangle</li>
<li>Circle</li>
<li>Ellipse</li>
<li>Straight Line</li>
<li>Polyline</li>
<li>Polygon</li>
<li>Path</li>
</ul
</p>
<br>
<p>
SVG comes with these basic shapes predefined so as to make it easy to draw them.
</p>
<p>
<pre><code class="html">&lt;svg width="50" height="50"&gt;
    &lt;circle cx="25" cy="25" r="25" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
Because SVG graphics is written in XML, which is very close to HTML, we can use D3 to create SVG tags and set their attributes with values.
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").attr("width","50").attr("height","50").append("circle").attr("cx","25").attr("cy","25").attr("r","25");</code></pre>
</p>
<p>
Which means we can write D3 code to simulate writing SVG code manually.
</p>
<p>
We can do this with all of the basic SVG shapes.
</p>
<br>
<p>
Now that we've refreshed our memory of SVG, SVG basic shapes, the SVG Viewport and how to use D3 to create the SVG Basic shapes, next we look at the D3 Data Operator Revisited.
</p>
<br>
<br>
<p>
<strong>
D3 Data Operator Revisited
</strong>
</p>
<p>
<pre><code class="javascript">d3.selection.data([values[, key]])</code></pre>
</p>
<p>
This is the D3 Data Operator
</p>
<p>
We have seen it before when we gave it values to bind to the selection
</p>
<p>
The Data Operator joins the specified array of data with the current selection
</p>
<p>
<pre><code class="javascript">d3.selection.data([1,2,3,4,5]);</code></pre>
</p>
<p>
So far we have defined our data inside of the D3 Data Operator
</p>
<p>
Though when we first talked about the D3 Data Operator
</p>
<p>
We covered that the values passed in could be an array of data values, such as an array of numbers or objects, or even a function that returns an array of values.
</p>
<p>
<pre><code class="javascript">var myData = [...];
d3.selection.data(myData);</code></pre>
</p>
<p>
From now to make things more modular and easier to read
</p>
<p>
We will define a myData variable and then use that variable
</p>
<p>
To feed the D3 Data Operator.
</p>
<p>
For now we will just use a single array of many numbers
</p>
<p>
Later we cover associative arrays, JSON, and other types of data
</p>
<br>
<p>
Next we look at Binding Data to SVG Elements
</p>
<br>
<br>
<p>
<strong>
Binding Data to SVG Elements
</strong>
</p>
<p>
In the Video Binding Data To DOM Elements, we bound data to DOM elements
</p>
<p>
<pre><code class="javascript">var myData = [1,2,3,4,5];
var updateSelection = d3.select("body").selectAll("p").data(myData);
var paragraphElements = updateSelection.enter().append("p");</code></pre>
</p>
<p>
BROWSER - Click on the <body> tag to show the 5 paragraph elements.
</p>
<p>
Using a new barebones HTML file, the update selection was created
</p>
<p>
Then the enter selection was referenced and an HTML paragraph element
</p>
<p>
Was appended to each JavaScript Object Element created to hold each of the data points.
</p>
<br>
<p>
Because SVG is written in XML, we can do the same thing as we did with the paragraph element.
</p>
<p>
Though instead of using the Paragraph Element,
</p>
<p>
we use the SVG keyword for creating a circle.
</p>
<p>
<pre><code class="javascript">var myData = [1,2,3,4,5];
var circleSelection = d3.select("body").selectAll("circle").data(myData);
var circleElements = circleSelection.enter().append("circle");
circleElements.data();</code></pre>
</p>
<p>
BROWSER - Click on the <body> tag to show the 5 circle elements.
</p>
<p>
As you can see, we were able to bind data to 5 SVG circle Elements		
</p>
<br>
<p>
An important thing to remember, is that SVG definitions must live inside of SVG tags to be able to be read and understood by the browser
</p>
<p>
<pre><code class="javascript">var myData = [1,2,3,4,5];
var svgViewport = d3.select("body").append("svg").attr("width","400").attr("height","400");
var circleSelection = svgViewport.selectAll("circle").data(myData);
var circleElements = circleSelection.enter().append("circle");
circleElements.data();</code></pre>
</p>
<p>
BROWSER - Arrow up through the commands.
</p>
<p>
Which means that instead of appending the circles to the body element selection,
</p>
<p>
We have to append an SVG tag, inside of which we create the SVG elements.
</p>
<p>
We give the SVG tag viewport dimensions to make sure it fits inside of the screen
</p>
<p>
When we hover over the SVG tag in the elements section of the developer tools
</p>
<p>
You can see the highlighted dimensions on the actual HTML document
</p>
<p>
As you can see, the circle elements still have the right data bound to them
</p>
<p>
And now they live inside of the SVG viewport. 		
</p>
<br>
<p>
Recalling that we can add attributes to SVG Basic shapes,
</p>
<p>
We can give the circles some attributes.
</p>
<p>
<pre><code class="javascript">circleElements.attr("cx","100").attr("cy","100").attr("r","25");</code></pre>
</p>
<p>
BROWSER - In the elements section, hover over all the circles
</p>
<p>
As you can see, by adding attributes to the circles,
</p>
<p>
The web browser was able to draw the SVG circles for us
</p>
<p>
However, as you can also see, each circle received the exact same attribute.
</p>
<p>
This is because we passed to the attribute operator a constant value.
</p>
<p>
Which means that the constant value is given to every element in the selection.			
</p>
<br>
<p>
The attribute operator also behaves like most D3 operators in that it is also able to take in a function.		
</p>
<br>
<p>
Next, we look at the using JavaScript Functions to Use Data Bound to SVG Elements
</p>
<br>
<br>
<p>
<strong>
Use Data Bound to SVG Elements
</strong>
</p>
<p>
<pre><code class="javascript">d3.selection.attr(name[, value])</code></pre>
</p>
<p>
Before, we covered that this operator inserts an attribute and a value, if specified, into the elements in the selection.
</p>
<p>
Then it returns a selection.
</p>
<p>
The examples covered used a constant as the value.	
</p>
<p>
<pre><code class="javascript">d3.selection.attr(name, function () {...} )</code></pre>		
</p>
<p>
What we didn't cover is the case where we can pass in a function to the attribute operator.
</p>
<p>
And the return value of the function is used to set the name attribute value.		
</p>
<br>
<p>
Let's try some simple examples to see how it works.
</p>
<br>
<p>
First, we do a simple example using an HTML paragraph element.
</p>
<p>
<pre><code class="javascript">d3.select("body").insert("p").attr("class","first_p");</code></pre>
</p>
<p>
BROWSER - open body and highlight the paragraph
</p>
<p>
As you can see, we set the class attribute of the paragraph to be the constant value "first_p"		
</p>
<br>
<p>
Next, let's write a named function that returns a string
</p>
<p>
<pre><code class="javascript">function myFunction() { return "function_p"; };</code></pre>
</p>
<br>
<p>
Then, let's insert a paragraph with a class attribute.
</p>
<p>
<pre><code class="javascript">d3.select("body").insert("p").attr("class", myFunction);</code></pre>
</p>
<p>
BROWSER - Highlight the newly insert paragraph element
</p>
<p>
As you can see, the myFunction function was applied to the paragraph element
</p>
<p>
and the returned the value function_p as the class attribute value.	
</p>
<br>
<p>
Next, let's write an anonymous function that returns a string
</p>
<p>
and use it directly in the D3 attribute operator
</p>
<br>
<p>
<pre><code class="javascript">d3.select("body").insert("p").attr("class", function () { return "anon_p"; });</code></pre>
</p>
<p>
BROWSER - Highlight the newly insert paragraph element
</p>
<p>
As you can see, the anonymous function was applied to the paragraph element
</p>
<p>
and the return value anon_p was set as the class attribute value.		
</p>
<br>
<p>
Now, let's go back to our SVG circle example.
</p>
<p>
BROWSER - Clear the screen and restart with these variables already typed in.
</p>
<p>
<pre><code class="javascript">var myData = [1,2,3,4,5];
var svgViewport = d3.select("body").append("svg").attr("width","400").attr("height","400");
var circleSelection = svgViewport.selectAll("circle").data(myData);
var circleElements = circleSelection.enter().append("circle");</code></pre>
</p>
<p>
We set the data variable
</p>
<p>
then We create the SVG viewport 
</p>
<p>
then We bind the data to the circle elements
</p>
<p>
Then we append the circle elements.	
</p>
<br>
<p>
Next - instead of setting the attributes as constants,
</p>
<p>
Let's define a named function to set the attribute values.
</p>
<p>
<pre><code class="javascript">function myFunction () { return 25; }
myFunction();</code></pre>
</p>
<p>
We define myFunction to return the value of 25.
</p>
<p>
When evaluated - We see that the function returns the value of 25	
</p>
<br>
<p>
Next let's put it into the circleElements attribute operators.
</p>
<p>
<pre><code class="javascript">circleElements.attr("cx",myFunction).attr("cy",myFunction).attr("r",myFunction);</code></pre>
</p>
<p>
BROWSER - Hover over the circle elements.
</p>
<p>
As you can see this set all of the circleElement attributes we defined ...  to 25
</p>
<br>
<p>
Recall that the D3 operators give us the data attribute of the element as the letter d as well as the selection index number as the letter i.	
</p>
<br>
<p>
Now, let's write a simple named function that takes in these elements and does something with them.
</p>
<p>
<pre><code class="javascript">function functionTwo (d,i) { return d * 25; }
functionTwo(1,2);</code></pre>
</p>
<br>
<p>
Next, let's change the circle Elements attributes by calling the attributes again, though this time with the functionTwo as the function we are passing in.
</p>
<p>
<pre><code class="javascript">circleElements.attr("cx",functionTwo).attr("cy",functionTwo).attr("r",functionTwo);</code></pre>
</p>
<p>
BROWSER - Hover over the SVG circles
</p>
<p>
As you can see, the functionTwo was applied to each element.
</p>
<p>
And the D3 attribute operator provided the D and I arguments to the function.
</p>
<br>
<p>
Next, let's leave the radius constant and play around with the CX and CY variables
</p>
<p>
<pre><code class="javascript">circleElements.attr("cx",functionTwo).attr("cy",functionTwo).attr("r",
		"25");</code></pre>
</p>
<p>
So now we know how to use the data bound to SVG elements.		
</p>
<br>
<p>
Next, we look at how to use JavaScript Functions to style the different SVG elements according to their bound data.
</p>
<br>
<br>
<p>
<strong>
Using Data to Style SVG Elements
</strong>
</p>
<p>
<pre><code class="javascript">selection.style(name[, value[, priority]])</code></pre>
</p>
<p>
The Style Operator, if a name and value are specified, sets the CSS style property for the given selection with the given specified value.
</p>
<p>
Earlier we set the style as a constant.
</p>
<p>
As you can now probably imagine, we can pass a function into the style operator as well.
</p>
<p>
The style operator provides us with the D for data and I for index variables.
</p>
<br>
<p>
Let's try a simple example to see how it works.
</p>
<br>
<p>
Going back to the SVG circle example.
</p>
<p>
BROWSER - Clear the screen and restart with these variables already typed in.
</p>
<p>
<pre><code class="javascript">var myData = [1,2,3,4,5];
var svgViewport = d3.select("body").append("svg").attr("width","400").attr("height","400");
var circleSelection = svgViewport.selectAll("circle").data(myData);
var circleElements = circleSelection.enter().append("circle");</code></pre>
</p>
<p>
We set the data variable
</p>
<p>
We create the SVG viewport 
</p>
<p>
We bind the data to the circle elements
</p>
<p>
Then we append the circle elements.
</p>
<br>
<p>
Next - let's use anonymous functions to set the CX and CY circle attributes
</p>
<p>
While leaving the radius constant.
</p>
<p>
<pre><code class="javascript">circleElements.attr("cx",function(d,i) { return d * 25; })
    .attr("cy",function(d,i) { return d * 25; })
    .attr("r","25");</code></pre>
</p>
<p>
This gives us the 5 circles spread out diagonally towards the bottom right of the screen.
</p>
<br>
<p>
Next, let's write a function that colors the circles green or red
</p>
<p>
Depending on whether the index is odd or even.
</p>
<p>
<pre><code class="javascript">function greenRed(d,i) {
    if (i % 2 === 0) { return "green"; }
    else { return "red"; };
}</code></pre>
</p>
<p>
This function takes in the variable d and i.
</p>
<p>
if i is divisible by two (using the modulus) then we return green
</p>
<p>
if i is not divisible by two then we return red.	
</p>
<br>
<p>
We test it out
</p>
<p>
<pre><code class="javascript">greenRed(1,2);</code></pre>
</p>
<p>
As and expected this returns "green".
</p>
<br>
<p>
Alright - let's style our circles
</p>
<p>
<pre><code class="javascript">var circleStyle = circleElements.style("fill",greenRed);</code></pre>
</p>
<p>
As you can see, the circles are now alternating in color.
</p>
<p>
Also worth noting is that because D3 selections are zero-based arrays
</p>
<p>
The first circle is green.	
</p>
<br>
<p>
There are many ways to style SVG and HTML elements based on functions.		
</p>
<p>
D3 even provides some operators specifically for colors.
</p>
<p>
We will cover that later.
</p>
<p>
And with that, you can see how we can use the Data bound to SVG elements to style them.
</p>
        </div>
      </div>

</div>
    
<hr>
<h3 id="lesson16">Using the SVG Coordinate Space<h3> 
    <div>
    <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>
The SVG element can be thought of as an SVG Viewport window
</li>
<li>
Things within the SVG Viewport's dimensions are visible
</li>
<li>
Things outside of the SVG Viewport's dimensions exist but are not visible
</li>
<li>
Math (Cartesian) Coordinate Space has the origin point (X=0, Y=0) at the bottom left
</li>
<li>
SVG Coordinate Space has the origin point (X=0, Y=0) at the top left
</li>
<li>
SVG Coordinate Space has the Y axis values increasing as it goes from the top of the SVG viewport to the bottom
</li>
<li>
You can use D3 and the knowledge of the SVG Coordinate space to add SVG elements and define their attribute value pairs such that you can place things within the SVG Viewport
</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<ul>
<li>
<a href="https://www.dashingd3js.com/lessons/fundamentals-of-svg">Fundamentals of SVG</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/creating-svg-elements-from-data">Creating SVG Elements from Data</a>
</li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            Using the SVG Coordinate Space
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
SVG Revisited
</strong>
</p>
<p>
<pre><code class="html">&lt;svg&gt; ... &lt;/svg&gt;</code></pre>
</p>
<p>
The SVG element is commonly referred to as the SVG Viewport.
</p>
<p>
Things within the SVG Viewports dimension's are visible
</p>
<p>
Things inside the SVG tags though outside the Viewport dimensions are not visible.
</p>
<br>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;
    &lt;circle cx="25" cy="25" r="25" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
HIGHLIGHT svg width in green
</p>
<p>
The SVG width and height are the width and height of the view port
</p>
<p>
This setup tells the browser to set aside an area of 200 pixels by 200 pixels in the document for SVG Graphics.
</p>
<p>
This way the browser knows how to to place the rest of the elements in the HTML document.
</p>
<p>
This setup also tells the browser that the interior of the SVG viewport is 200 units wide by 200 units tall.
</p>
<br>
<p>
Outside: 200 x 200 pixels
<br>
Inside : 200 x 200 units
</p>
<p>
Why the difference?
</p>
<p>
Two reasons - 
</p>
<p>
One - SVG is based on vector graphics so it's not pixels inside
</p>
<p>
Two - Units depend on the graphic that you are creating.
</p>
<br>
<p>
Think of Maps
<br>
3 x Map Scale Images
</p>
<p>
In maps, the outside of the map can be measured in inches or centimeters
</p>
<p>
Measuring the inside in inches or centimeters completely misses the point with out a scale conversion.
</p>
<p>
On the inside, one unit could be an inch, a kilometer, a mile or something different.
</p>
<br>
<p>
<pre><code class="html">&lt;svg&gt; ... &lt;/svg&gt;</code></pre>
</p>
<p>
So for SVG
</p>
<p>
When we talk about the viewport and what is inside, we will be talking about units.
</p>
<br>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;
    &lt;circle cx="25" cy="25" r="25" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
HIGHLIGHT the 25s
</p>
<p>
So when you look at the SVG circle example
</p>
<p>
It means that the CX, CY and r  are based in units, not pixels.
</p>
<p>
This is what makes them scalable vector graphics- units, not pixels.
</p>
<br>
<br>
<p>
<strong>
Math Coordinate Space
</strong>
</p>
<p>
PICTURE of X / Y axis from DashingD3js.com website
</p>
<p>
This is what the math coordinate space looks like when taught in schools.
</p>
<p>
The graph has a coordinate space where x=0 and y=0 coordinates fall on the bottom left.
</p>
<p>
And the coordinates of X grow as you move to the right
</p>
<p>
And the coordinates of Y grow as you move up.
</p>
<br>
<p>
PICTURE of X / Y axis with green circle from DashingD3js.com website
</p>
<p>
Text on Screen (25,25)
</p>
<p>
Which means when we are given the coordinates of (25,25)
</p>
<p>
We go 25 units from the left to the right
</p>
<p>
and
</p>
<p>
We go 25 units from the bottom to the top.
</p>
<br>
<p>
PICTURE of X / Y axis with green circle from DashingD3js.com website
</p>
<p>
Text on Screen (50,50)
</p>
<p>
If we then went to the coordinates of (50,50)
</p>
<p>
Then we would go 25 more units to the right
<br>
and
<br>
We would go 25 more units up
</p>
<br>
<br>
<p>
<strong>
SVG Coordinate Space
</strong>
</p>
</p>
<p>
Text on Screen
</p>
<p>
PICTURE of SVG Coordiante axis from DashingD3js.com website
</p>
<p>
SVG Coordinate Space works in the same way that mathematical graph coordinate space works except for two important features:
</p>
<p>
GREEN ARROW POINTING TO THE ORIGIN POINT
</p>
<p>
One - SVG Coordinate space has it's origin point (0,0) at the top left
</p>
<p>
Two - SVG Coordinate space has the Y coordinate growing from top to bottom.
</p>
<br>
<p>
PICTURE of X / Y SVG axis with green circle from DashingD3js.com website
</p>
<p>
Text on Screen (25,25)
</p>
<p>
Which means when we are given the coordinates of (25,25)
</p>
<p>
We go 25 units from the left to the right
<br>
and
<br>
We go 25 units from the top to the bottom.
</p>
<br>
<p>
PICTURE of X / Y SVG axis with green circle from DashingD3js.com website
</p>
<p>
Text on Screen (50,50)
</p>
<p>
If we then went to the coordinates of (50,50)
</p>
<p>
Then we would go 25 more units to the right
</p>
<p>
and
</p>
<p>
We would go 25 more units down
</p>
<br>
<p>
Let's try some simple examples to see how it works.
</p>
<br>
<p>
In this HTML document we define the SVG viewport and four different SVG circles
</p>
<p>
<pre><code class="html">&lt!-- HTML Document (coordinate_space.html) --&gt;
&lt;circle cx="0"   cy="0"   r="25" fill="black" /&gt;
&lt;circle cx="75"  cy="75"  r="25" fill="yellow" /&gt;
&lt;circle cx="150" cy="150" r="25" fill="green" /&gt;
&lt;circle cx="225" cy="225" r="25" fill="blue" /&gt;
&lt;br&gt;</code></pre>
</p>
<p>
4 Circles
</p>
<p>
Each circle is defined with a different X and Y center coordinate.
</p>
<p>
Each circle is also defined with a different color.
</p>
<p>
Finally, we also add in a line break
</p>
<p>
A String
</p>
<p>
And another line break		
</p>
<br>
<p>
We save this file and open the file in the browser
</p>
<p>
BROWSER - Hover over and highlight the svg tag
</p>
<p>
As you can see, the Browser created a box for the SVG that is 200px by 200px
</p>
<p>
BROWSER - Hover slowly over the four svg circles
</p>
<p>
As you can also see, the Browser created 4 SVG circles and also shows us where they are.
</p>
<p>
BROWSER - Hover over the black circle
</p>
<p>
Notice that we can only see a quarter of the black circle.
</p>
<p>
This is because this is the only visible part of the black circle in the SVG viewport
</p>
<p>
BROWSER - Hover over the blue circle
</p>
<p>
Notice that we cannot see the blue circle at all.
</p>
<p>
This is because the blue circle coordinates are outside of the coordinates the SVG viewport contains.
</p>
<p>
That said, the Browser still knows where it is and highlights the position for you when you hover over the element.
</p>
<br>
<p>
As you can see from the coordinates
</p>
<p>
BROWSER - Hover over all of the circles
</p>
<p>
As the Center point coordinates, the CX and CY, of the circles grow in size
</p>
<p>
The circles move towards the bottom and the right.
</p>
<p>
Which shows us that in the SVG Coordinate space
</p>
<p>
As X gets bigger, it moves from the left to the right
</p>
<p>
and more importantly
</p>
<p>
As Y gets bigger, it moves from the top to the bottom. 		
</p>
<br>
<p>
And that is the basics of the SVG Coordinate Space
</p>
<br>
<br>
<p>
<strong>
D3 Append SVG Revisited
</strong>
</p>
<p>
<pre><code class="javascript">d3.selection.append("svg");</code></pre>
</p>
</p>
<p>
Just like with HTML elements, we covered how we could append the SVG element to the HTML Document.
</p>
<p>
We also covered how we could append attributes with names and values to the SVG element.	
</p>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;
    ...
&lt;/svg&gt;</code></pre>
</p>
<br>
<p>
<pre><code class="javascript">d3.select("body").append("svg").attr("width","200").attr("height","200");</code></pre>
</p>
</p>
<p>
Which means we could create the SVG statement in D3
</p>
<p>
Like this.		
</p>
<br>
<p>
In the next section we will recreate the four circle example with D3.
</p>
<br>
<br>
<p>
<strong>
D3 & SVG Coordinate Space
</strong>
</p>
<p>
We start with the HTML file that already has the 4 SVG circles in them
</p>
<p>
BROWSER - Hover over the four circles
</p>
<p>
As this file already has D3 loaded, let's check to make sure it loaded correctly
</p>
<p>
<pre><code class="javascript">d3.version;</code></pre>
</p>
<p>
D3 is loaded.
</p>
<br>
<p>
First we want to append an SVG container to the HTML document.
</p>
<p>
<pre><code class="javascript">var svgSelection = d3.select("body").append("svg").attr("width","200").attr("height","200");</code></pre>
</p>
</p>
<p>
BROWSER - hover over the new SVG container
</p>
<p>
We append a new SVG container to the HTML body and assign it to the variable svgSelection.
</p>
<p>
This will let us use this selection later without having to retype everything.
</p>
<p>
Because append appends the element as the last child of the current selection,
</p>
<p>
we can see that D3 appended the SVG container after the text "4 Circles".	
</p>
<br>
<p>
Next we want to append the four circles to the new SVG selection.
</p>
<p>
<pre><code class="javascript">svgSelection.append("circle").attr("cx","0").attr("cy","0").attr("r","25").style("fill","black");</code></pre>
</p>
<p>
BROWSER - Hide the previous SVG
</p>
<br>
<p>
For now, we hide the previous SVG code to make sure we can see the new code.
</p>
<p>
<pre><code class="javascript">svgSelection.append("circle").attr("cx","75").attr("cy","75").attr("r","25").style("fill","yellow");</code></pre>
</p>
<p>
BROWSER - Arrow up
</p>
<p>
Next, we update the command to change the CX, CY and the style fill for the second circle.
</p>
<p>
You can see that as the CX increased, the circle moved from the left to the right
</p>
<p>
And that as the CY increased, the circle moved down from the top to the bottom.
</p>
<br>
<p>
<pre><code class="javascript">svgSelection.append("circle").attr("cx","150").attr("cy","150").attr("r","25").style("fill","green");</code></pre>
</p>
</p>
<p>
BROWSER - Arrow up
</p>
<p>
Next, we update the command to change the CX, CY and the style fill for the third circle.
</p>
<p>
You can see that as the CX increased again, the circle moved from the left to the right
</p>
<p>
And that as the CY increased again, the circle moved down from the top to the bottom.
</p>
<br>
<p>
<pre><code class="javascript">svgSelection.append("circle").attr("cx","225").attr("cy","225").attr("r","25").style("fill","blue");</code></pre>
</p>
</p>
<p>
BROWSER - Arrow up
</p>
<p>
Finally, we update the command to change the CX, CY and the style fill for the fourth circle.
</p>
<p>
You can see that as the CX increased again, the circle moved from the left to the right
</p>
<p>
And that as the CY increased again, the circle moved down from the top to the bottom.
</p>
<p>
Also, notice that this last circle does not appear in the SVG viewport just like the hand-coded SVG example.
</p>
<br>
<p>
Now, we hide the JavaScript console and take a look at the SVG Code side by side.
</p>
<p>
BROWSER - hide the JavaScript console by pressing the button
</p>
<p>
BROWSER - open up the first SVG which had been hidden
</p>
<p>
BROWSER - High light the first circle at the top of the second SVG viewport
</p>
<p>
As you can see the two SVG containers look exactly the same.
</p>
<p>
The only difference you may notice is that the D3 generated SVG does not use the word black
</p>
<p>
Instead of the word black, it uses the HTML Hexadecimal Notation for the color black.	
</p>
<br>
<p>
And with that, you should have a better feel of how the SVG coordinate space works and how it is different from the regular mathematical coordinate space.
</p>
        </div>
      </div>

</div>
    
    </div>
    
    
<hr>
<h3 id="lesson17">JavaScript Data Types<h3>
    <div>
    <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>
JavaScript has three data types - primary data types, composite data types, and special data types
</li>
<li>
Primary Data Types are data types that store primitive values
</li>
<li>
Composite Data Types are data types that reference addresses which store variables
</li>
<li>
Special Data Types are data types that have special uses and cases
</li>
<li>
Primary Data Type examples include strings, numbers, and booleans
</li>
<li>
Composite Data Type examples include Objects and Arrays
</li>
<li>
JavaScript Arrays are a special kind of JavaScript Object
</li>
<li>
JavaScript Arrays have a length property while JavaScript objects do not
</li>
<li>
JavaScript Arrays allow for value selection through passing an index number
</li>
<li>
Special Data Type examples include null and undefined
</li>
<li>
JavaScript null reflects a lack of value
</li>
<li>
JavaScript undefined reflects a lack of type and value
</li>
<li>
JSON, which stands for JavaScript Object Notation, is a text-based open standard designed for human-readable data interchange
</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li>
<a href="https://www.dashingd3js.com/lessons/introduction-to-javascript">Introduction to JavaScript</a>
</li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            JavaScript Data Types
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
JavaScript Data Types
</strong>
</p>
<p>
Data-Driven Documents
</p>
<p>
HIGHLIGHT PURPLE the Data Word
</p>
<p>
D3.js is a JavaScript library for manipulating documents based on data.
</p>
<p>
The key word being Data.	
</p>
<br>
<p>
Data Visualization
</p>
<p>
HIGHLIGHT PURPLE the Data Word
</p>
<p>
For the most part, people use D3.js to do Data Visualizations.
</p>
<p>
The key word being Data.
</p>
<br>
<p>
JavaScript
</p>
<p>
Being that JavaScript is the language of choice for developing in D3.js
</p>
<p>
Let's learn about the 7 different Data types available in JavaScript.	
</p>
<br>
<p>
JavaScript Data Types
</p>
<p>
3 Primary Data Types:
</p>
<p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
</ul>
</p>
<p>
2 Composite Data Types
</p>
<ul>
<li>Object</li>
<li>Array</li>
</ul>
</p>
<p>
2 Special Data Types
</p>
<p>
<ul>
<li>Null</li>
<li>Undefined</li>
</ul>
</p>
<br>
<p>
JavaScript Data Types can be broken into three main categories.
</p>
<p>
Primary Data Types - These data types store primitive values.
</p>
<p>
Composite Data Types - These data types reference addresses which store variables.
</p>
<p>
Special Data Types - These data types have special uses and cases.
</p>
<br>
<p>
Let's start with the Primary Data Types
</p>
<br>
<br>
<p>
<strong>
Primary Data Types
</strong>
</p>
<p>
JavaScript Primary Data Types
</p>
<p>
<ul>
<li>String ** HIGHLIGHTED GREEN **</li>
<li>Number</li>
<li>Boolean</li>
</ul>
</p>
<p>
JavaScript strings are a chain of zero or more Unicode Characters
</p>
<p>
You use a string to represent text in JavaScript
</p>
<p>
You can use double quotations or single quotations to designate strings
</p>
<p>
If you use double quotations, you can use single quotations inside of the string
</p>
<p>
If you use single quotations, you can use double quotations inside of the string
</p>
<p>
JavaScript also provides escape sequence to create characters that cannot be typed directly.	
</p>
<br>
<p>
Let's look at some examples in the JavaScript Console
</p>
<p>
<pre><code class="javascript">"This is a string";

"";

"This string has an interior string 'right here'";

'This ones "does too"';

'This " One will ' not work" ';

'This \" One will \' work \" ';

typeof("stringy");</code></pre>
</p>
<p>
As you can see we can type strings into the JavaScript console
</p>
<p>
You can use the escape sequence to add in quotations into strings where they would normally cause an error.
</p>
<p>
Using the typeof operator in JavaScript tells us the string is a string.
</p>
<br>
<p>
JavaScript Primary Data Types
</p>
<p>
<ul>
<li>String</li>
<li>Number ** HIGHLIGHTED GREEN **</li>
<li>Boolean</li>
</ul>
</p>
<p>
JavaScript numbers are numbers plain and simple - positive, negative or zero.
</p>
<p>
Unlike other programming languages, there is no distinction between integers and floating-point numbers.
</p>
<p>
Internally, JavaScript represents all numbers as floating point numbers.		
</p>
<br>
<p>
Let's look at some examples in the JavaScript Console
</p>
<p>
<pre><code class="javascript">typeof( 0 ); // Zero

typeof( -1e-3 ); // Negative Scientific Number

typeof( 0.0000012 ); // Floating Point

typeof( 0XFFEEEE ); // Hexadecimal Number

typeof( 023 ); // Octal Number

typeof( 21 ); // Integer</code></pre>
</p>
<p>
There are many types and styles of numbers you can write in JavaScript.
</p>
<p>
Using the typeof operator in JavaScript we can check the different examples.
</p>
<p>
We test Zero, Scientific Notation, Floating Point, Hexadecimal, Octal and Integer numbers.
</p>
<br>
<p>
JavaScript Primary Data Types
</p>
<p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean ** HIGHLIGHTED GREEN **</li>
</ul>
</p>
<p>
JavaScript Boolean Data Types can only have two values True or False.
</p>
<p>
Boolean Values, as we have already seen, are very useful in control statements like an if/then/else function.	
</p>
<br>
<p>
Let's look at a few examples in the JavaScript Console
</p>
<p>
<pre><code class="javascript">typeof( true );

typeof( false );

typeof( TRUE );

typeof( False );</code></pre>
</p>
<p>
Using the typeof operator in JavaScript we check the different boolean examples.
</p>
<p>
Very importantly, you should have noticed that true and false are written in all lower case letters.
</p>
<br>
<br>
<p>
<strong>
Composite Data Types
</strong>
</p>
<p>
JavaScript Composite Data Types
</p>
<p>
<ul>
<li>Object ** HIGHLIGHTED GREEN **</li>
<li>Array</li>
</ul>
</p>
<p>
JavaScript Objects are collections of methods and properties.
</p>
<p>
A method is a function that is a member of an object.
</p>
<p>
A property is a value or set of values that is a member of an object.
</p>
<p>
The world of objects in JavaScript is a deep one.
</p>
<p>
The part of that world that we want to look at is Object Literals.
</p>
<p>
Object literal JavaScript Object creation is used when you only want to create one instance of an object.
</p>
<p>
For a very large part of the D3 work that we will do together, we will only ever want one instance of an object.	
</p>
<br>
<p>
Let's look at how to create an Object Literal JavaScript Object
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 50};

margin;

typeof( margin );</code></pre>
</p>
<p>
As you can see this created a JavaScript Object.
</p>
<p>
For now, we won't cover the other ways to create JavaScript Objects.
</p>
<br>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 50};</code></pre>
</p>
<br>
<p>
Given our object we can extract information from the object two ways;
</p>
<p>
<pre><code class="javascript">margin['top'];

margin.top;</code></pre>
</p>
<p>
As you can see, we get back the number 20 both times.
</p>
<br>
<p>
When you type the second one, if we stop at the period, then we can see the methods and values available.
</p>
<p>
<pre><code class="javascript">margin.</code></pre>
</p>
<p>
You can see the properties top, right, bottom, and left as well as several methods available to the object.
</p>
<p>
We can even define our own methods, though we will leave that for later.
</p>
<br>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 50};</code></pre>
</p>
<p>
This is the JavaScript Object we created.
</p>
<p>
JavaScript Objects can also be called associative arrays.
</p>
<p>
Associative arrays are arrays where the key can be a string rather than an integer like in a regular array.
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 30, bottom: 40, left: 50};

margin['top'];</code></pre>
</p>
<p>
In other programming languages this type of data structure can be called a dictionary or map.
</p>
<p>
This data structure consists of keys
</p>
<p>
HIGHLIGHT the top, right, bottom, left
</p>
<p>
and values
</p>
<p>
HIGHLIGHT the 20, 30 , 40 , 50
</p>
<p>
Because they are called, keys and values and are related to each other, they are commonly referred to as key,value pairs.
</p>
<br>
<p>
JavaScript Composite Data Types
</p>
<p>
<ul>
<li>Object</li>
<li>Array ** HIGHLIGHTED GREEN **</li>
</ul>
</p>
<p>
JavaScript Arrays are merely a special kind of JavaScript Object.
</p>
<p>
Both JavaScript Objects and Arrays have properties and methods.
</p>
<p>
There are two key differences
</p>
<p>
One - Arrays have a length property while regular objects do not
</p>
<p>
Two - Arrays allow for value selection through passing an index number
</p>
<p>
These two specific differences make arrays very useful.
</p>
<p>
As we already saw - D3 selections are made up of arrays.	
</p>
<br>
<p>
Let's look at creating Arrays in JavaScript.
</p>
<p>
<pre><code class="javascript">var data = [1,2,3,4,5];

var margin = {top: 20, right: 20, bottom: 30, left: 50};

typeof( data );

typeof( margin );</code></pre>
</p>
<p>
As you can see both data and margin are both objects.
</p>
<p>
<pre><code class="javascript">data.length;

margin.length;</code></pre>
</p>
<p>
However, the data array has a length while the margin object does not.
</p>
<p>
<pre><code class="javascript">data[0];

margin[0];</code></pre>
</p>
<p>
Lastly, we can check to see if we can get data values out using an index.
</p>
<br>
<p>
It works for the data array though it does not work for the margin object.
</p>
<br>
<br>
<p>
<strong>
Special Data Types
</strong>
</p>
<p>
Special Data Types
</p>
<p>
<ul>
<li>null</li>
<li>undefined</li>
</ul>
</p>
<br>
<p>
These two Data types reflect a lack of something.
</p>
<p>
The null type reflects a lack of value
</p>
<p>
While the undefined reflects a lack of type and value.
</p>
<p>
This is another deep subject area that we will leave for another time.
</p>
<br>
<br>
<p>
<strong>
JSON
</strong>
</p>
<p>
JSON = JavaScript Object Notation
</p>
<p>
JSON is a text-based open standard designed for human-readable data interchange.
</p>
<p>
It was initially based on JavaScript Objects
</p>
<p>
It is derived from the JavaScript for representing simple data structures and associative arrays, called objects.
</p>
<p>
It is now an open standard that is programming language independent.
</p>
<br>
<p>
JavaScript Object
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 50};</code></pre>
</p>
<br>
<p>
JSON Object
</p>
<p>
<pre><code class="javascript">var margin = {"top": 20, "right": 20, "bottom": 30, "left": 50};</code></pre>
</p>
<p>
As you can see, the difference comes from double quotes around the keys.
</p>
<br>
<p>
This will come in very handy as we construct more complicated Data Visualizations using D3.
</p>
        </div>
      </div>

</div>
    
    </div>

<hr>
<h3 id="lesson18">D3 and JSON<h3>
    <div>
          <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>JSON, which stands for JavaScript Object Notation, is a text-based open standard designed for human-readable data interchange</li>
<li>JSON is used to represent data structures and associative arrays, called objects</li>
<li>JSON uses double quotes around the keys of the key value pairs</li>
<li>D3 comes with Associative Array Utilities like d3.keys, d3.values, and d3.entries</li>
<li>d3.keys returns an array containing the property key names of the specified associative array</li>
<li>d3.values returns an array containing the property values of the specified associative array</li>
<li>d3.entries returns an array containing the property keys and values of the specified associative array</li>
<li>The D3 Data Operator can take in an array of associative arrays and bind each associative array to a DOM element</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li>
<a href="https://www.dashingd3js.com/lessons/javascript-data-types">JavaScript Data Types</a>
</li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 and JSON
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
JSON Revisited
</strong>
</p>
<p>
JSON = JavaScript Object Notation
</p>
<p>
JSON is a text-based open standard designed for human-readable data interchange.
</p>
<p>
It was initially based on JavaScript Objects
</p>
<p>
It is derived from the JavaScript for representing simple data structures and associative arrays, called objects.
</p>
<p>
It is now an open standard that is programming language independent.
</p>
<br>
<p>
JavaScript Object
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 50};</code></pre>
</p>
<br>
<p>
JSON Object
</p>
<p>
<pre><code class="javascript">var margin = {"top": 20, "right": 20, "bottom": 30, "left": 50};</code></pre>
</p>
<p>
As you can see, the difference comes from double quotes around the keys.
</p>
<p>
This will come in very handy as we construct more complicated Data Visualizations using D3.
</p>
<br>
<p>
Programming Languages able to parse/generate JSON: 
ASP, Ada, Bash, BlitzMax, C, C++, C#, Ciao, Clojure, Cobol, ColdFusion, D, Dart, Delphi, E, Erlang, Fantom, Go, Haskell, haXe, Java, JavaScript, Lisp, LotusScript, Lua, LabVIEW, M, Matlab, Objective C, OCaml, OpenLaszlo, Perl, PHP, Pike, PL/SQL, pljson, PowerShell, Prolog, Puredata, Python, Qt, R, Racket, Rebol, RPG, Ruby, Scala, Scheme, Squeak, Symbian, Tcl, Visual Basic, Visual FoxPro, and many more...
</p>
<br>
<p>
We use JSON to get comfortable with the Data Interchange Format.
</p>
<p>
As of the time of this recording, these are all the programming languages that are able to parse and generate JSON data structures.
</p>
<br>
<br>
<p>
<strong>
D3 Associative Array Operators
</strong>
</p>
<p>
<pre><code class="javascript">var margin = {"top": 20, "right": 20, "bottom": 30, "left": 50};</code></pre>
</p>
<p>
Margin is a JSON object because of the double quotes around the keys.
</p>
<p>
That said, it is still a JavaScript Object Literal.
</p>
<p>
Which also means that it is an Associative Array.
</p>
<br>
<p>
D3 Associative Array Utilities
<ul>
<li>d3.keys(object)</li>
<li>d3.values(object)</li>
<li>d3.entries(object)</li>
</ul>
</p>
<p>
Much like D3 provides additional Methods to the JavaScript Array Methods
</p>
<p>
D3 also provides additional Methods to the JavaScript Associative Array Methods
</p>
<p>
These methods are d3.keys, d3.values and d3.entries.
</p>
<br>
<p>
Basic D3 Associative Array Utilities
<ul>
<li>d3.keys(object) ** HIGHLIGHT GREEN **</li>
<li>d3.values(object)</li>
<li>d3.entries(object)</li>
</ul>
</p>
<p>
D3.keys returns an array containing the property key names of the specified associative array.
</p>
<p>
The order of the returned array is undefined.	
</p>
<br>
<p>
Let's look at an example in the JavaScript Console
</p>
<p>
<pre><code class="javascript">var margin = {"top": 20, "right": 20, "bottom": 30, "left": 50};

d3.keys(margin);</code></pre>
</p>
<p>
First, we define our margin JSON Object / JavaScript Object / Associative Array.
</p>
<p>
Then we pass this object into the D3.Keys operator.
</p>
<p>
As you can see, D3 returns the keys of each key,value pair in the Associative Array.
</p>
<p>
<pre><code class="javascript">var margin = {"top": 20, "right": 20, "bottom": 30, left: 50};

// BROWSER - Arrow up to get command and replace quotations

d3.keys(margin);</code></pre>
</p>
<p>
Note, even if we remove the quotation marks from the left key, making it a regular javascript object,
</p>
<p>
D3.keys still returns each of the keys in quotes inside of an array.
</p>
<br>
<p>
Basic D3 Associative Array Utilities
<ul>
<li>d3.keys(object)</li>
<li>d3.values(object) ** HIGHLIGHT GREEN **</li>
<li>d3.entries(object)</li>
</ul>
</p>
<p.
D3.values returns an array containing the property values of the specified associative array.
</p>
<p.
The order of the returned array is undefined.	
</p>
<br>
<p>
Let's look at an example in the JavaScript Console
</p>
<p>
<pre><code class="javascript">var margin = {"top": 20, "right": 20, "bottom": 30, "left": 50};
d3.values(margin);</code></pre>
</p>
<p>
First, we define our margin JSON Object /"slash" JavaScript Object /"slash" Associative Array.
</p>
<p>
Then we pass this object into the D3.Values operator.
</p>
<p>
As you can see, D3 returns the values of each key,value pair in the Associative Array.
</p>
<p>
<pre><code class="javascript">var margin = {"top": 20, "right": 20, "bottom": 30, "left": "50"};

// BROWSER - Arrow up to get command and add quotations around the number 50

d3.values(margin);</code></pre>
</p>
<p>
Note, if we put quotation marks around the number 50.
</p>
<p>
D3.values will return the array of values with the "50" as a string with quotations.
</p>
<p>
It is worth noting that when you receive a JSON Data Structure, you cannot assume that the values will be strings or numbers.
</p>
<p>
You will have to check the values to make sure they are what you are expecting, and convert if necessary.
</p>
<br>
<p>
Basic D3 Associative Array Utilities
<ul>
<li>d3.keys(object)</li>
<li>d3.values(object)</li>
<li>d3.entries(object) ** HIGHLIGHT GREEN **</li>
</ul>
</p>
<p>
D3.entries returns an array containing the property keys and values of the specified associative array.
</p>
<p>
The order of the returned array is undefined.
</p>
<br>
<p>
Let's look at an example in the JavaScript Console
</p>
<p>
<pre><code class="javascript">var margin = {"top": 20, "right": 20, "bottom": 30, "left": 50};

d3.entries(margin);</code></pre></p>
<p>
First, we define our margin JSON Object / JavaScript Object / Associative Array.
</p>
<p>
Then we pass this object into the D3.Entries Operator.
</p>
<p>
As you can see, each element in the returned Array is an Object.
</p>
<p>
BROWSER - Open the objects
</p>
<p>
D3 returns the values of each key,value pair in the Associative Array inside an object.
</p>
<p>
Each object has two entries
</p>
<p>
An entry called key and an entry called value.
</p>
<p>
<pre><code class="javascript">d3.entries(margin)[0];</code></pre>
</p>
<p>
Because this is an array, let's look at the first object
</p>
<p>
<pre><code class="javascript">d3.entries(margin)[0]["key"];

d3.entries(margin)[0]["value"];</code></pre>
</p>
<p>
Because this object is an Associative Array, we can call the key or values by name to get the data.
</p>
<br>
<br>
<p>
<strong>
D3 Data Operator Revisited
</strong>
</p>
<p>
<pre><code class="javascript">d3.selection.data([values[, key]])</code></pre>
</p>
<p>
This is the D3 Data Operator.
</p>
<p>
We have seen it before when we gave it values to bind to the selection.
</p>
<p>
The Data Operator joins the specified array of data with the current selection.
</p>
<p>
<pre><code class="javascript">d3.selection.data([1,2,3,4,5]);</code></pre>
</p>
<p>
First, we defined the data inside of the D3 Data Operator.
</p>
<p>
Though when we first talked about the D3 Data Operator, we also covered that the values passed in could be an array of data values, such as an array of numbers or objects, or even a function that returns an array of values.
</p>
<p>
<pre><code class="javascript">var myData = [...]

d3.selection.data(myData);</code></pre>
</p>
<p>
Then we moved to make things more modular and easier to read
</p>
<p>
And defined the array of numbers outside the data operator before feeding in the array into the D3 Data Operator.
</p>
<p>
<pre><code class="javascript">obj1 = { ... };

obj2 = { ... };

obj3 = { ... };

var myData = [ obj1, obj2, obj3];

d3.selection.data(myData);</code></pre>
</p>
<p>
Now, instead of filling the array with numbers, we can fill it with objects.
</p>
<p>
The D3 Data Operator can take in an array of data values that contains objects.
</p>
<p>
So we can use objects to store and bind a great deal more data to each of the DOM Elements.
</p>
<br>
<br>
<p>
<strong>
JSON in the D3 Data Operator
</strong>
</p>
<p>
<pre><code class="javascript">obj1 = { ... };

obj2 = { ... };

obj3 = { ... };

var myData = [ obj1, obj2, obj3]

d3.selection.data(myData);</code></pre>
</p>
<p>
What is great about doing this is that we can be very descriptive about the properties in each object
</p>
<p>
Both in the keys of the object as well as the values.
</p>
<p>
<pre><code class="javascript">betterMargins = [ { "direction":"top",    "units":"20" },
                  { "direction":"right",  "units":"20" },
                  { "direction":"bottom", "units":"30" },
                  { "direction":"left",   "units":"50" } ];</code></pre>
</p>
<p>
Let's look at an example in the JavaScript Console
</p>
<p>
We start with an Array of JavaScript Object Literals
</p>
<p>
The array contains 4 JSON objects
</p>
<p>
Each JSON Object contains a direction and a number of units
</p>
<p>
If we look at the first row
</p>
<p>
The keys of that object are direction and units
</p>
<p>
The values of that object are "top" and "20"
</p>
<p>
Also note, that the spaces are added for readability.
</p>
<br>
<p>
Next, let's bind the data to HTML paragraph elements.
</p>
<p>
<pre><code class="javascript">var paragraphs = d3.select("body").selectAll("p").data(betterMargins).enter().append("p");</code></pre>
</p>
<p>
This code should be familiar to you now.
</p>
<p>
We select the body element
</p>
<p>
We select all the paragraph elements
</p>
<p>
Next, we pass in betterMargins - an array of JSON Objects - into the D3 data operator.
</p>
<p>
We grab the .enter() selection with the JavaScript Object placeholder elements for each data element in the array
</p>
<p>
Then we merge the .enter() selection and the .update() selection by appending paragraph elements to each placeholder element.
</p>
<p>
BROWSER - Click on the <body> tag to expand
</p>
<p>
BROWSER - Hover over all the data elements
</p>
<br>
<p>
As you can see, this created 4 paragraph elements.
</p>
<p>
<pre><code class="javascript">paragraphs;</code></pre>
</p>
<p>
BROWSER - Click into the array, then the first element.
</p>
<p>
BROWSER - Highlight the __data__: Object
</p>
<p>
BROWSER - Click into the data object
</p>
<p>
BROWSER - Highlight the direction and units.
</p>
<p>
Each of those paragraph elements now contains a JSON object in the __data__ property. 
</p>
<br>
<p>
Let's play around with the paragraphs now.
</p>
<p>
<pre><code class="javascript">paragraphs.text( function (d,i) { return d; });</code></pre>
</p>
<p>
Using the D3 text operator, we write an anonymous function to return the thing attached to the __Data__ property.
</p>
<p>
As you can see, it returned a JavaScript Object
</p>
<p>
<pre><code class="javascript">paragraphs;</code></pre>
</p>
<p>
BROWSER - HIGHLIGHT the first object in the Webpage
</p>
<p>
If we look at the variable and click into the arrays, we can see that the thing attached to the __Data__ property for each paragraph is indeed a JavaScript Object.
</p>
<p>
<pre><code class="javascript">paragraphs.text( function (d,i) { return d.direction; });</code></pre>
</p>
<p>
BROWSER - User arrow up to get the last command and then add the .direction
</p>
<br>
<p>
Next, we can use the associative array functionality to get the direction from the object.
</p>
<p>
BROWSER - Hover over the paragraph elements in the actual website window
</p>
<p>
As you can see, the paragraphs now contain the text of each of the directions
</p>
<p>
<pre><code class="javascript">paragraphs.text( function (d,i) { return d.units; });</code></pre>
</p>
<p>
BROWSER - User arrow up to get the last command and then add the .units
</p>
<br>
<p>
Next, we can use the associative array functionality to get the units from the object.
</p>
<p>
BROWSER - Hover over the paragraph elements in the actual website window
</p>
<p>
As you can see, the paragraphs now contain the text of each of the units
</p>
<p>
<pre><code class="javascript">paragraphs.text( function (d,i) { return d.direction + ": " + d.units; });</code></pre>
</p>
<p>
BROWSER - User arrow up to get the last command and then add the d.direction + ": " + d.units
</p>
<p>
Because we are writing an anonymous function
</p>
<p>
We can do anything we want inside because it is a JavaScript Function
</p>
<p>
BROWSER - Hover over the paragraph elements in the actual website window
</p>
<p>
As you can see, the paragraphs now contain the text of each of the directions and the number of units for each direction.
</p>
<p>
<pre><code class="javascript">obj1 = { ... };

obj2 = { ... };

obj3 = { ... };

var myData = [ obj1, obj2, obj3]

d3.selection.data(myData);</code></pre>
</p>
<p>
The great thing about this is that you can specify as many key,value pairs inside of an object as you want.
</p>
<p>
Which means you can attach a treasure trove of data to each DOM element.
</p>
<p>
Which you can then get out using the anonymous functions or named functions.
</p>
        </div>
      </div>

</div>
    
  

<hr>
<h3 id="lesson19">D3 and SVG Basic Shapes<h3>
    <div>
   <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>SVG comes with the following Basic Shapes - Rectangle, Circle, Ellipse, Straight Line, Polyline, Polygon, and Path</li>
<li>You can use D3 to define the SVG basic shape tags as well as define all of the attribute value pairs the specific tags need to appear on the screen</li>
<li>SVG basic shape tags must live within an opening &lt;svg&gt; and closing &lt;/svg&gt; tags</li>
<li>The SVG Rectangle takes in four inputs - x, y, width, and height</li>
<li>The SVG Circle takes in three inputs - cx, cy, and r</li>
<li>The SVG Ellipse takes in four inputs - cx, cy, rx, and ry</li>
<li>The SVG Straight Line takes in six inputs - x1, y1, x2, y2, stroke, and stroke-width</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li>
<a href="https://www.dashingd3js.com/lessons/fundamentals-of-svg">Fundamentals of SVG</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/adding-an-svg-element">Adding an SVG Element</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/creating-svg-elements-from-data">Creating SVG Elements from Data</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/using-the-svg-coordinate-space">Using the SVG Coordinate Space</a>
</li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 and SVG Basic Shapes
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
Basic SVG Object Syntax Revisited
</strong>
</p>
<p>
SVG Basic Shapes
</p>
<p>
<ul>
<li>Rectangle</li>
<li>Circle</li>
<li>Ellipse</li>
<li>Straight Line</li>
<li>Polyline</li>
<li>Polygon</li>
<li>Path</li>
</ul>
</p>
<p>
The basic shapes that SVG provides are
</p>
<p>
the rectangle
</p>
<p>
the circle
</p>
<p>
the ellipse
</p>
<p>
the straight line
</p>
<p>
and the polyline, polygon and path.
</p>
<p>
In this video we will not cover polyline, polygon and the path.
</p>
<p>
We will cover them in the next video.
</p>
<br>
<br>
<p>
<strong>
D3 and SVG Rectangle
</strong>
</p>
<p>
A Rectangle
</p>
<p>
<pre><code class="html">&lt;svg width="50" height="50"&gt;
    &lt;rect x="0" y="0" width="50" height="50" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
For us to be able to use an SVG rectangle it must be defined inside of the SVG tags.
</p>
<p>
Note - the SVG key word for the rectangle is rect - r e c t.
</p>
<p>
The SVG rectangle takes in four main inputs.
</p>
<p>
The x and y - which is where the rectangle is drawn from
</p>
<p>
and the height and width.
</p>
<p>
Remember - the SVG coordinate space starts at the top left and goes to the bottom right as x and y coordinates increase.
</p>
<p>
So as the height increases, the rectangle will get longer down
</p>
<p>
And as the width increases, the rectangle will get longer to the right.
</p>
<br>
<p>
A Rectangle
</p>
<p>
<pre><code class="html">&lt;svg width="50" height="50"&gt;
    &lt;rect x="0" y="0" width="50" height="50" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
JSON => { "x":..., "y":..., "width":..., "height":... };
</p>
<p>
Which means that when we are using D3 to create SVG rectangle objects
</p>
<p>
And we are using an array of JSON Objects, 
</p>
<p>
The JSON objects should have the x, y, width and height properties.	
</p>
<br>
<p>
Let's look at an example in the JavaScript Console
</p>
<p>
<pre><code class="javascript">var svgContainer = d3.select("body").append("svg").attr("width","200").attr("height","200");</code></pre>
</p>
<p>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<p>
BROWSER - Expand HTML Section above JavaScript Console
</p>
<br>
<p>
First, we define the SVG Container the rectangles will live in.
</p>
<p>
Note that we define the width and height of the SVG viewport container.
</p>
<br>
<p>
<pre><code class="javascript">var rectangles = [ {"x": 0,   "y":   0, "width": 30, "height": 40},
                   {"x": 50,  "y":  50, "width": 30, "height": 40},
                   {"x": 100, "y": 100, "width": 30, "height": 40},
                   {"x": 150, "y": 150, "width": 30, "height": 40} ];</code></pre>
</p>
<p>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<p>
BROWSER - Expand HTML Section above JavaScript Console
</p>
<p>
Then, we define the rectangle JSON Objects.
</p>
<p>
The rectangles array contains 4 rectangle JSON Objects.
</p>
<p>
This will be the data source used to construct the rectangles
</p>
<br>
<p>
<pre><code class="javascript">var svgRectangles = svgContainer.selectAll("rect").data(rectangles).enter().append("rect");</code></pre>
</p>
<p>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<p>
BROWSER - Expand HTML Section above JavaScript Console
</p>
<p>
Then, we use D3 to suck in the data from the rectangles Array of JSON Objects
</p>
<p>
This follows the same D3 pattern we have seen before
</p>
<p>
This binds each JSON object to an SVG rectangle DOM element
</p>
<br>
<p>
<pre><code class="javascript">svgRectangles
    .attr("x",      function (d,i) { return d.x;  })
    .attr("y",      function (d,i) { return d.y;      })
    .attr("width",  function (d,i) { return d.width;  })
    .attr("height", function (d,i) { return d.height; });</code></pre>
</p>
<p>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<p>
Then, using the JSON object bound to the data property of each SVG rectangle DOM element
</p>
<p>
We use an anonymous function to extract the relevant information from each JSON object
</p>
<p>
For the rectangle, this means the x, y, width and height information.
</p>
<br>
<p>
BROWSER - Highlight / Click on each of the rectangle SVG elements in the ELEMENTS CONSOLE SECTIOn
</p>
<p>
As you can see, this created the 4 SVG rectangles from the array of JSON objects we defined at the start.
</p>
<p>
If we wanted to style the rectangles, we could have added an extra field to each JSON object detailing the color for each rectangle.
</p>
<br>
<br>
<p>
<strong>
D3 and SVG Circles
</strong>
</p>
<p>
A Circle
</p>
<p>
<pre><code class="html">&lt;svg width="50" height="50"&gt;
    &lt;circle cx="25" cy="25" r="25" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
For us to be able to use an SVG circle it must be defined inside of the SVG tags.
</p>
<p>
Note - the SVG key word for the circle is circle.
</p>
<p>
The SVG circle takes in three main inputs.
</p>
<p>
The cx and cy - which is where the center of the circle is drawn from
</p>
<p>
and the r which is the radius of the circle.
</p>
<br>
<p>
A Circle
</p>
<p>
<pre><code class="html">&lt;svg width="50" height="50"&gt;
    &lt;circle cx="25" cy="25" r="25" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
JSON => { "cx":..., "cy":..., "r":... };
</p>
<p>
Which means that when we are using D3 to create SVG circle objects
</p>
<p>
And we are using an array of JSON Objects, 
</p>
<p>
The JSON objects should have the cx, cy and r properties.	
</p>
<br>
<p>
Let's look at an example in the JavaScript Console
</p>
<p>
<pre><code class="javascript">var svgContainer = d3.select("body").append("svg").attr("width","200").attr("height","200");</code></pre>
</p>
<p>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<p>
BROWSER - Expand HTML Section above JavaScript Console
</p>
<p>
First, we define the SVG Container the rectangles will live in.
</p>
<p>
Note that we define the width and height of the SVG viewport container
</p>
<br>
<p>
<pre><code class="javascript">var circles = [ {"cx":  25, "cy":  25, "r": 20},
                {"cx":  75, "cy":  75, "r": 20},
                {"cx": 125, "cy": 125, "r": 20},
                {"cx": 175, "cy": 175, "r": 20} ];</code></pre>
</p>
<p>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<p>
BROWSER - Expand HTML Section above JavaScript Console
</p>
<p>
Then, we define the circle JSON Objects.
</p>
<p>
The circles array contains 4 circle JSON Objects.
</p>
<p>
This will be the data source used to construct the circles
</p>
<br>
<p>
<pre><code class="javascript">var svgCircles = svgContainer.selectAll("circle").data(circles).enter().append("circle");</code></pre>
</p>
<p>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<p>
BROWSER - Expand HTML Section above JavaScript Console
</p>
<p>
Then, we use D3 to suck in the data from the circles Array of JSON Objects
</p>
<p>
This follows the same D3 pattern we have seen before
</p>
<p>
This binds each JSON object to an SVG circle DOM element
</p>
<br>
<p>
<pre><code class="javascript">svgCircles
    .attr("cx", function (d,i) { return d.cx; })
    .attr("cy", function (d,i) { return d.cy; })
    .attr("r",  function (d,i) { return d.r;  });</code></pre>
</p>
<p>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<p>
BROWSER - Expand HTML Section above JavaScript Console
</p>
<p>
Then, using the JSON object bound to the data property of each SVG circle DOM element
</p>
<p>
We use an anonymous function to extract the relevant information from each JSON object
</p>
<p>
For the circle, this means the cx, cy and r information.
</p>
<br>
<p>
BROWSER - Highlight / Click on each of the circle SVG elements in the ELEMENTS CONSOLE SECTION
</p>
<p>
As you can see, this created the 4 SVG circles from the array of JSON objects we defined at the start.
</p>
<p>
If we wanted to style the circles, we could have added an extra field to each JSON object detailing the color for each circle.
</p>
<br>
<br>
<p>
<strong>
D3 and SVG Ellipses
</strong>
</p>
<p>
An Ellipse
</p>
<p>
<pre><code class="html">&lt;svg width="50" height="50"&gt;
    &lt;ellipse cx="25" cy="25" rx="15" ry="10" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
For us to be able to use an SVG ellipse it must be defined inside of the SVG tags.
</p>
<p>
Note - the SVG key word for the ellipse is ellipse.
</p>
<p>
The SVG ellipse takes in four main inputs.
</p>
<p>
The cx and cy - which is where the center of the ellipse is drawn from
</p>
<p>
and the x radius of the ellipse and the y radius of the ellipse.
</p>
<br>
<p>
An Ellipse
</p>
<p>
<pre><code class="html">&lt;svg width="50" height="50"&gt;
    &lt;ellipse cx="25" cy="25" rx="15" ry="10" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
JSON => { "cx":..., "cy":..., "rx":..., "ry":... };	
</p>
<p>
Which means that when we are using D3 to create SVG ellipse objects
</p>
<p>
And we are using an array of JSON Objects, 
</p>
<p>
The JSON object should have the cx, cy, rx and ry properties.	
</p>
<br>
<p>
Let's look at an example in the JavaScript Console
</p>
<p>
<pre><code class="javascript">var svgContainer = d3.select("body").append("svg").attr("width","200").attr("height","200");</code></pre>
</p>
<p>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<p>
BROWSER - Expand HTML Section above JavaScript Console
</p>
<p>
First, we define the SVG Container the ellipses will live in.
</p>
<p>
Note that we define the width and height of the SVG viewport container
</p>
<br>
<p>
<pre><code class="javascript">var ellipses = [ {"cx":  25, "cy":  25, "rx": 15, "ry": 20},
                 {"cx":  75, "cy":  75, "rx": 15, "ry": 20},
                 {"cx": 125, "cy": 125, "rx": 15, "ry": 20},
                 {"cx": 175, "cy": 175, "rx": 15, "ry": 20} ];</code></pre>
</p>
<p>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<p>
BROWSER - Expand HTML Section above JavaScript Console
</p>
<p>
Then, we define the ellipse JSON Objects.
</p>
<p>
The ellipses array contains 4 ellipse JSON Objects.
</p>
<p>
This will be the data source used to construct the ellipses
</p>
<br>
<p>
<pre><code class="javascript">var svgEllipses = svgContainer.selectAll("ellipse").data(ellipses).enter().append("ellipse");</code></pre>
</p>
<p>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<p>
BROWSER - Expand HTML Section above JavaScript Console
</p>
<p>
Then, we use D3 to suck in the data from the ellipses Array of JSON Objects
</p>
<p>
This follows the same D3 pattern we have seen before
</p>
<p>
This binds each JSON object to an SVG ellipse DOM element
</p>
<br>
<p>
<pre><code class="javascript">svgEllipses
    .attr("cx", function (d,i) { return d.cx; })
    .attr("cy", function (d,i) { return d.cy; })
    .attr("rx", function (d,i) { return d.rx; })
    .attr("ry", function (d,i) { return d.ry; });</code></pre>
</p>
<p>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<p>
BROWSER - Expand HTML Section above JavaScript Console
</p>
<p>
Then, using the JSON object bound to the data property of each SVG ellipse DOM element
</p>
<p>
We use an anonymous function to extract the relevant information from each JSON object
</p>
<p>
For the ellipse, this means the cx, cy, rx and ry information.
</p>
<br>
<p>
BROWSER - Highlight / Click on each of the ellipse SVG elements in the ELEMENTS CONSOLE SECTION
</p>
<p>
As you can see, this created the 4 SVG ellipses from the array of JSON objects we defined at the start.
</p>
<p>
If we wanted to style the ellipses, we could have added an extra field to each JSON object detailing the color for each ellipse.
</p>
<br>
<br>
<p>
<strong>
D3 and SVG Straight Lines
</strong>
</p>
<p>
A Straight Line
</p>
<p>
<pre><code class="html">&lt;svg width="50" height="50"&gt;
    &lt;line x1="5" y1="5" x2="40" y2="40" stroke="gray" stroke-width="5" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
For us to be able to use an SVG Straight Line it must be defined inside of the SVG tags.
</p>
<p>
Note - the SVG key word for the Straight Line is line.
</p>
<p>
The SVG Straight Line takes in six main inputs.
</p>
<p>
The x1 and y1 - which is where the line starts
</p>
<p>
The x2 and y2 - which is where the line ends
</p>
<p>
and stroke and stroke-width which is the color of the line and the stroke width.
</p>
<p>
The stroke and stroke-width are necessary because an SVG line is dimensionless.
</p>
<p>
So by applying a stroke-width greater than zero, we can see the line.
</p>
<br>
<p>
A Straight Line
</p>
<p>
<pre><code class="html">&lt;svg width="50" height="50"&gt;
    &lt;line x1="5" y1="5" x2="40" y2="40" stroke="gray" stroke-width="5" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
JSON => { "x1":..., "y1":..., "x2":..., "y2":..., "stroke":..., "stroke-width":... };	
</p>
<p>
Which means that when we are using D3 to create SVG Straight Line objects
</p>
<p>
And we are using an array of JSON Objects, 
</p>
<p>
The JSON object should have the x1, y1, x2, y2, stroke and stroke-width properties.	
</p>
<br>
<p>
Let's look at an example in the JavaScript Console
</p>
<p>
<pre><code class="javascript">var svgContainer = d3.select("body").append("svg").attr("width","200").attr("height","200");</code></pre>
</p>
<p>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<p>
BROWSER - Expand HTML Section above JavaScript Console
</p>
<p>
First, we define the SVG Container the straight lines will live in.
</p>
<p>
Note that we define the width and height of the SVG viewport container
</p>
<br>
<p>
<pre><code class="javascript">var straightLines = [ 
    { "x1":  0, "y1":  0, "x2": 40, "y2": 40, "stroke":"black", "stroke_width":5 },
    { "x1": 50, "y1": 50, "x2": 90, "y2": 90, "stroke":"black", "stroke_width":5 },
    { "x1":100, "y1":100, "x2":140, "y2":140, "stroke":"black", "stroke_width":5 },
    { "x1":150, "y1":150, "x2":190, "y2":190, "stroke":"black", "stroke_width":5 } ];</code></pre>
</p>
<p>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<p>
BROWSER - Expand HTML Section above JavaScript Console
</p>
<p>
Then, we define the straight line JSON Objects.
</p>
<p>
The straight lines array contains 4 straight line JSON Objects.
</p>
<p>
This will be the data source used to construct the straight lines
</p>
<br>
<p>
Note that for the stroke_width, we use an underscore to separate the stroke and width words
</p>
<p>
Why this is important will be seen shortly.
</p>
<p>
<pre><code class="javascript">var svgStraightLines = svgContainer.selectAll("line").data(straightLines).enter().append("line");</code></pre>
</p>
<p>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<p>
BROWSER - Expand HTML Section above JavaScript Console
</p>
<p>
Then, we use D3 to suck in the data from the Straight Lines Array of JSON Objects
</p>
<p>
This follows the same D3 pattern we have seen before
</p>
<p>
This binds each JSON object to an SVG Straight Line DOM element
</p>
<br>
<p>
<pre><code class="javascript">svgStraightLines
    .attr("x1",           function (d,i) { return d.x1;           })
    .attr("y1",           function (d,i) { return d.y1;           })
    .attr("x2",           function (d,i) { return d.x2;           })
    .attr("y2",           function (d,i) { return d.y2;           })
    .attr("stroke",       function (d,i) { return d.stroke;       })
    .attr("stroke-width", function (d,i) { return d.stroke_width; });</code></pre>
</p>
<p>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<p>
BROWSER - Expand HTML Section above JavaScript Console
</p>
<p>
Then, using the JSON object bound to the data property of each SVG Straight Line DOM element
</p>
<p>
We use an anonymous function to extract the relevant information from each JSON object
</p>
<p>
For the straight line, this means the x1, y1, x2, y2, stroke and stroke-width information.
</p>
<p>
Note, the stroke-width anonymous function uses the d.stroke {underscore} width.
</p>
<p>
If we have written stroke {dash} width, then JavaScript would have thought we were trying to do a subtraction.
</p>
<p>
This is very important to keep in mind as this can often cause bugs in the code.
</p>
<br>
<p>
BROWSER - Highlight / Click on each of the straight line SVG elements in the ELEMENTS CONSOLE SECTION
</p>
<p>
As you can see, this created the 4 SVG straight lines from the array of JSON objects we defined at the start.
</p>
        </div>
      </div>

☺</div>  
    

<hr>
<h3 id="lesson20">D3 and SVG Paths<h3>
    <div>
    
    <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>An SVG Polyline is used to create any shape that consists of only straight lines</li>
<li>The SVG Polyline takes in three main inputs: stroke, stroke-width, and list of points to connect</li>
<li>An SVG Polygon is used to create any shape that consists of at least 3 sides, all of which are themselves straight lines</li>
<li>The SVG Polygon takes in four main inputs: stroke, stroke-width, a list of points to connect, and a fill (which is used to fill the enclosing space)</li>
<li>The SVG Path behaves like a pen on a piece of paper - you start with the pen touching only one point and direct how the pen moves around the space (either through straight lines or through curves / arcs)</li>
<li>The SVG Path relies on the "d" attribute to define how it moves</li>
<li>The SVG Path has a specific mini-language, used in the "d" attribute" that defines all of the ways the "pen" can move around the space</li>
<li>D3 includes a set of Path Data Generator helper classes for generating SVG Path instructions</li>
<li>The most common D3 Path Generator is d3.svg.line</li>
<li>d3.svg.line takes in an array of objects, where each object has "x" and "y" values defined, and returns the SVG Path mini-language instructions</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li>
<a href="https://www.dashingd3js.com/lessons/fundamentals-of-svg">Fundamentals of SVG</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/adding-an-svg-element">Adding an SVG Element</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/creating-svg-elements-from-data">Creating SVG Elements from Data</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/using-the-svg-coordinate-space">Using the SVG Coordinate Space</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/d3-and-svg-basic-shapes">D3 and SVG Basic Shapes</a>
</li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 and SVG Paths
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
D3 and Basic SVG Line Shapes
</strong>
</p>
<p>
SVG Basic Shapes
</p>
<p>
<ul>
<li>Rectangle</li>
<li>Circle</li>
<li>Ellipse</li>
<li>Straight Line</li>
<li>Polyline</li>
<li>Polygon</li>
<li>Path</li>
</ul>
</p>
<p>
These are all of the SVG Basic Shapes.
</p>
<p>
This video covers the Polyline, Polygon and Path Shapes.
</p>
<br>
<p>
A Polyline
</p>
<p>
<pre><code class="html">&lt;svg width="50" height="50"&gt;
    &lt;polyline stroke="blue" stroke-width="2" 
              points="05,30 15,30 15,20
                      25,20 25,10 35,10" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
A Polyline is used to create any shape that consists of only straight lines.
</p>
<p>
In the example on the screen, we have a list of points defined.
</p>
<p>
A straight line is drawn from each point pair to the next point pair.
</p>
<p>
Note the spacing between the points.
</p>
<p>
For us to be able to use an SVG Polyline it must be defined inside of the SVG tags.
</p>
<p>
Note - the SVG key word for the polyline is polyline.
</p>
<p>
The SVG Polyline takes in three main inputs.
</p>
<p>
The stroke and stroke-width - the same as the SVG Line
</p>
<p>
and the points list of points.
</p>
<br>
<p>
A Polygon
</p>
<p>
<pre><code class="html">&lt;svg width="50" height="50"&gt;
    &lt;polygon fill="yellow" stroke="blue" stroke-width="2" 
             points="05,30 15,10 25,30" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
A Polygon is used to create any shape that consists of at least 3 sides, which are themselves straight lines.
</p>
<p>
In the example on the screen, we have a list of points defined.
</p>
<p>
A straight line is drawn from each point pair to the next point pair.
</p>
<p>
At the end, a straight line is drawn from the last point to the beginning point to close the shape.
</p>
<p>
The enclosing space is filled with the color specified in the fill attribute.
</p>
<p>
Note the spacing between the points.
</p>
<p>
For us to be able to use an SVG Polygon it must be defined inside of the SVG tags.
</p>
<p>
Note - the SVG key word for the Polygon is Polygon.
</p>
<p>
The SVG Polygon takes in four main inputs.
</p>
<p>
The stroke, stroke-width, and a points list - just the same as the SVG Polyline
</p>
<p>
and the fill which is used to fill the enclosing space.
</p>
<br>
<p>
A Polyline
</p>
<p>
<pre><code class="html">&lt;svg width="50" height="50"&gt;
    &lt;polyline stroke="blue" stroke-width="2" 
              points="05,30 15,30 15,20
              25,20 25,10 35,10" /> &lt;/svg&gt;

d3.selection.attr(...)</code></pre>
</p>
<p>
D3 is very good at adding attributes and their values to DOM Tags.
</p>
<p>
So in both cases, it is very easy for D3 to add in
</p>
<p>
the width and width value,
</p>
<p>
the height and height value, 
</p>
<p>
the stroke and stroke value and
</p>
<p>
the stroke-width and stroke-width value.
</p>
<p>
D3 can also add in the points and the points value.
</p>
<p>
However, if we look at the list of points, it looks like it is cumbersome to generate a string which contains the points in the correct format.
</p>
<br>
<p>
<pre><code class="javascript">myData = [ { "x":05, "y":30 },{ "x":15, "y":30 },
           { "x":15, "y":20 },{ "x":25, "y":20 },
           { "x":25, "y":10 },{ "x":35, "y":10 }];

d3.selection.attr("points",.....);

points="05,30 15,30 15,20 25,20 25,10 35,10"</code></pre>
</p>
<p>
Somehow, we have to be able to convert the myData array into a string that contains the list of points.
</p>
<p>
Such that when D3 attaches it to the points attribute, it looks like SVG would expect it.
</p>
<p>
Yes, we could write functionality to take out the necessary information and convert it to a string.
</p>
<p>
Luckily for us, D3 does that for us, so we don't need to worry about it.
</p>
<p>
How does it do it?
</p>
<p>
Through SVG Paths.
</p>
<br>
<p>
SVG Path - The Shape to Make All Shapes
</p>
<p>
<ul>
<li>rectangles</li>
<li>circles</li>
<li>ellipses</li>
<li>polylines</li>
<li>polygons</li>
<li>straight lines</li>
<li>curves</li>
</ul>
</p>
<p>
The SVG Path is the shape to make all shapes.
</p>
<p>
W3 provides the following analogy:
</p>
<p>
Imagine that a pen is put on a piece of paper.
</p>
<p>
The pen will touch the paper in only one point.
</p>
<p>
The pen is now moved to another point.
</p>
<p>
The path between the two points can be a straight line or a curve.
</p>
<p>
The curve can be an arc, a cubic Bézier curve or a quadratic Bézier curve.
</p>
<p>
In this way we are able to draw any type of shape that we want in SVG.
</p>
<br>
<br>
<p>
<strong>
SVG Path
</strong>
</p>
<p>
<pre><code class="html">&lt;rect x="0" y="0" width="50" height="50" /&gt;

&lt;path d="M0,0 50,0 50,50 0,50" /&gt;</code></pre>
</p>
<p>
The SVG Path is the shape to make all shapes.
</p>
<p>
Here you can see how we can use the path to create a rectangle
</p>
<p>
<pre><code class="html">&lt;line x1="5" y1="5" x2="40" y2="40" stroke="gray" stroke-width="5"  /&gt;

&lt;path d="M5,5 40,40" stroke="gray" stroke-width="5" /&gt;</code></pre>
</p>
<br>
<p>
Here you can see how we can use the path to create a straight line
</p>
<p>
<pre><code class="html">&lt;circle cx="100" cy="100" r="75" /&gt;

&lt;path 
      d="
      M 100, 100
      m -75, 0
      a 75,75 0 1,0 150,0
      a 75,75 0 1,0 -150,0
      "
/&gt;</code></pre>
</p>
<br>
<p>
The SVG Path is the shape to make all shapes.
</p>
<p>
Here you can see how we can use the path to create a circle using two arcs.
</p>
<p>
<pre><code class="html">&lt;path 
      d="
      M 100, 100
      m -75, 0
      a 75,75 0 1,0 150,0
      a 75,75 0 1,0 -150,0
      "
/&gt;</code></pre>
</p>
<p>
HIGHLIGHT the d="...."
</p>
<p>
The SVG path can make any shape.
</p>
<p>
However, if we look at how it is doing it, it has a d equals and then a long string inside of quotes.
</p>
<p>
These letters are the SVG Path Mini Language.
</p>
<p>
Source:
</p>
<ul>
<li><a href="http://jsfiddle.net/crazytonyi/mNt2g/">http://jsfiddle.net/crazytonyi/mNt2g/</a></li>
<li><a href="http://stackoverflow.com/questions/5737975/circle-drawing-with-svgs-arc-path">http://stackoverflow.com/questions/5737975/circle-drawing-with-svgs-arc-path</a></li>
</ul>
</p>
<br>
<p>
SVG Path Mini-Language
</p>
<p>
<ul>
<li>moveto</li>
<li>lineto</li>
<li>horizontal lineto</li>
<li>vertical lineto</li>
<li>curveto</li>
<li>smooth curveto</li>
<li>quadratic Bézier curveto</li>
<li>smooth quadratic Bézier curveto</li>
<li>elliptical arc</li>
<li>closepath</li>
</ul>
</p>
<p>
The SVG Path Mini-Language describes how to do all of these things.
</p>
<p>
It describes things as simple as a horizontal line
</p>
<p>
To things as complicated as a smooth quadratic Bézier curve from one point to another.
</p>
<br>
<p>
Picture of SVG Car
</p>
<p>
This is an example SVG Graphic made with only SVG Paths.
</p>
<p>
Which tells us two things:
</p>
<p>
One - the SVG Path really is the SVG Shape to Make All Shapes
</p>
<p>
Two - this can get incredibly complicated quickly.
</p>
<p>
Luckily, D3 provides functions that take in data points and output SVG Path Instructions.
</p>
<br>
<br>
<p>
<strong>
D3 Path Data Generator
</strong>
</p>
<p>
D3 Path Data Generator
</p>
<ul>
<li>d3.svg.line</li>
<li>d3.svg.line.radial</li>
<li>d3.svg.area</li>
<li>d3.svg.area.radial</li>
<li>d3.svg.arc</li>
<li>d3.svg.symbol</li>
<li>d3.svg.chord</li>
<li>d3.svg.diagonal</li>
<li>d3.svg.diagonal.radial</li>
</ul>
</p>
<p>
D3 includes a set of Path Data Generators helper classes for generating SVG Path instructions.
</p>
<p>
D3 helps with things as simple as a line
</p>
<p>
And as complicated as a arcs, chords and diagonals.
	
</p>
<br>
<p>
D3 Path Data Generator
<ul>
<li>d3.svg.line  ** HIGHLIGHT GREEN **</li>
<li>d3.svg.line.radial</li>
<li>d3.svg.area</li>
<li>d3.svg.area.radial</li>
<li>d3.svg.arc</li>
<li>d3.svg.symbol</li>
<li>d3.svg.chord</li>
<li>d3.svg.diagonal</li>
<li>d3.svg.diagonal.radial</li>
</ul>
</p>
<p>
For now we will only look at the d3.svg.line generator
</p>
<p>
This is simple enough for us to get our heads around how it works
</p>
<p>
As well as to be able to easily verify that it does what we think it should do.
</p>
<p>
This function takes in the data and generates the necessary SVG Path commands.
</p>
<p>
Because it is a line function, it takes in a series of x and y coordinates.
</p>
<p>
<pre><code class="javascript">d3.svg.line()
    .x(function(d) { return d.x; })
    .y(function(d) { return d.y; })
    .interpolate("linear");</code></pre>
</p>
<p>
In order to convert our data to the SVG Path Commands, we need to tell the line Path Data Generator how to access the x and y coordinates from our data.
</p>
<p>
We do this by providing an accessor function to return the x,y coordinates from our data.
</p>
<p>
An accessor function is the name of a function that accesses a specific value from the data structure.
</p>
<p>
In this case, for each x and y combination, we need to provide an accessor function to return the x,y coordinates from our data.
</p>
<p>
This accessor function will take in the data array that is passed to D3 and extract the set x,y coordinates.
</p>
<p>
It will then do a linear interpolation between each point.
</p>
<p>
The result is a string of SVG Path mini-language instructions. 
</p>
<br>
<p>
Let's look at an example in the JavaScript Console
</p>
<p>
<pre><code class="javascript">myData = [ { "x":05, "y":30   },{ "x": 75, "y":30  },
           { "x":75, "y":90   },{ "x":150, "y":90  },
           { "x":150, "y":150 },{ "x":190, "y":150 }];</code></pre>
</p>
<p>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<p>
First, we define the myData array which is full of JSON objects.
</p>
<p>
Each JSON object contains an X and Y coordinate.
</p>
<p>
BROWSER - Click into the first object in the array to see to see the X, Y and Object
</p>
<p>
BROWSER - HIGHLIGHT the x, y and proto object.
</p>
<br>
<p>
Next, we define the D3 Path Data Generator Function 
</p>
<p>
<pre><code class="javascript">var lineFunction = d3.svg.line()
    .x(function(d) { return d.x; })
    .y(function(d) { return d.y; })
    .interpolate("linear");</code></pre>
</p>
<p>
</p>
<p>
This will take in the data set and using anonymous functions, get the X and Y coordinates.
</p>
<p>
It will then tell the D3 Path Data Generator Function to do a linear interpolation.
</p>
<br>
<p>
We can see the D3 Path Data Generator Function
</p>
<p>
<pre><code class="javascript">lineFunction;</code></pre>
</p>
<p>
</p>
<p>
By typing the function name without the open and close parentheses.
</p>
<br>
<p>
Let's now pass in the myData array into the lineFunction to see what it generates.
</p>
<p>
<pre><code class="javascript">lineFunction(myData);</code></pre>
</p>
<p>
</p>
<p>
The D3 Path Data Generator Function generated a string with SVG path instructions from the myData Array of Objects.
</p>
<br>
<p>
Let's copy and paste this string into the next line and add some spaces between commands.
</p>
<p>
<pre><code class="javascript">"M5,30 L75,30 L75,90 L150,90 L150,150 L190,150"</code></pre>
</p>
<p>
</p>
<p>
Ignoring the Alphabet Letters, you can see that the data points are still there.
</p>
<p>
The first point is 5 comma 30 and the last point is 190 comma 150
</p>
<p>
The M in the SVG path mini language means put the pen down
</p>
<p>
The L in the SVG path mini language means draw a line from the previous point to this point.
</p>
<br>
<p>
Next, let's create an SVG Viewport container that is 200 units by 200 units
</p>
<p>
<pre><code class="javascript">var svgContainer = d3.select("body").append("svg").attr("width","200").attr("height","200");</code></pre>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<p>
BROWSER - Expand HTML Section above JavaScript Console
</p>
<p>
We define the SVG Container the path will live in.
</p>
<p>
Note that we define the width and height of the SVG viewport container.
</p>
<br>
<p>
Now, let's append a path to this container
</p>
<p>
<pre><code class="javascript">svgViewport.append("path").attr("d","M5,30 L75,30 L75,90 L150,90 L150,150 L190,150").attr("stroke", "blue").attr("stroke-width", 2).attr("fill", "none");</code></pre>
</p>
<p>
Note that we pasted in the SVG Path the D3 Path Data Generator Function generated for us.
</p>
<p>
We put it in as the value for the D attribute.
</p>
<p>
We also give the path a color, a stroke width and no fill.
</p>
<p>
As you can see this generated a path line.
</p>
<p>
BROWSER - Highlight the Element in the element section.
</p>
<p>
And that is how we can use the D3 Path Data Generator Function to generate a path for us.
</p>
<br>
<p>
However, we still had to cut and paste the SVG Path Mini-language string into the command.
</p>
<p>
This time, let's put the named function with the data straight into the D3 attr operator.
</p>
<p>
BROWSER - Clear screen for a while.
</p>
<p>
<pre><code class="javascript">myData = [ { "x":05, "y":30   },{ "x": 75, "y":30  },
           { "x":75, "y":90   },{ "x":150, "y":90  },
           { "x":150, "y":150 },{ "x":190, "y":150 }];

var lineFunction = d3.svg.line()
    .x(function(d) { return d.x; })
    .y(function(d) { return d.y; })
    .interpolate("linear");

var svgContainer = d3.select("body").append("svg").attr("width","200").attr("height","200");</code></pre>
</p>
<p>
BROWSER - Cut in, when all of these things are typed and entered.
</p>
<p>
We define the data array, the line function and the SVG container that will contain the path.
</p>
<br>
<p>
We put the named function lineFunction with the data array straight into the D3 attr operator.
</p>
<p>
<pre><code class="javascript">svgViewport.append("path").attr("d",lineFunction(myData)).attr("stroke", "blue").attr("stroke-width", 2).attr("fill", "none");</code></pre>
</p>
<p>
As you can see, this generated the same line path as before without us having to cut and paste the result of the lineFunction.
</p>
<br>
<p>
Finally, let's create this path line using the D3 Pattern.
</p>
<p>
First, we define the data, linefunction and SVG container.
</p>
<p>
<pre><code class="javascript">myData = [ { "x":05, "y":30   },{ "x": 75, "y":30  },
           { "x":75, "y":90   },{ "x":150, "y":90  },
           { "x":150, "y":150 },{ "x":190, "y":150 }];

var lineFunction = d3.svg.line()
    .x(function(d) { return d.x; })
    .y(function(d) { return d.y; })
    .interpolate("linear");

var svgContainer = d3.select("body").append("svg").attr("width","200").attr("height","200");</code></pre>
</p>
<p>
BROWSER - Cut in, when all of these things are typed and entered.
</p>
<p>
Next, we use the D3 pattern - selection, bind data, append DOM elements and their attributes
</p>
<br>
<p>
Before we press enter, let's look at a few things
</p>
<p>
<pre><code class="javascript">svgViewport.append("path").datum(myData).attr("d",lineFunction).attr("stroke", "blue").attr("stroke-width", 2).attr("fill", "none");</code></pre>
</p>
<p>
One - we are using datum instead of data.
</p>
<p>
This tells D3 that we want to bind the data to a single SVG element
</p>
<p>
Two - because we are telling D3 we are going to use a single SVG element,
</p>
<p>
D3 does not compute a JOIN on the data, so there are no enter() or update() or exit() selections.
</p>
<p>
This is why the command does an append, binds data and then goes straight into defining attributes for the appended DOM Element.
</p>
<p>
The rest of the attributes you should be familiar with.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, this generated the same line path as before and we were able to use the D3 Data operator.
</p>
<br>
<p>
We have now covered three ways to make the SVG path line using D3.
</p>
<p>
Which one should you use?
</p>
<p>
You should use the one that binds the data to the DOM element.
</p>
<p>
After all, that's what using D3 is all about - data-driven documents.
</p>
<p>
if we type in d3 dot select path
</p>
<p>
<pre><code class="javascript">d3.select("path");</code></pre>
</p>
<p>
And we click into the interior array and look at the first element which is the path
</p>
<p>
We can see that the data property contains an array with each of the six JSON data point objects we passed in.
</p>
<p>
This data is very useful to keep around.
</p>
<p>
The two other ways to create SVG path lines do not keep the data around.
</p>
<p>
So that is why you should use the D3 Data Operator to create SVG Paths.
</p>
<br>
<p>
And that is the basics of generating a simple SVG path line with D3.
</p>
        </div>
      </div>

</div>


<hr>
<h3 id="lesson21">Dynamic SVG Coordinate Space<h3>
    <div>
    <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>The SVG element can be thought of as an SVG Viewport - things within the SVG Viewport's dimensions are visible, things outside of the dimensions are not visible</li>
<li>The SVG element dimensions are defined using the attribute value pairs of "height" and "width"</li>
<li>D3 Array utilities include d3.min, d3.max, d3.extent, d3.sum, d3.mean, d3.median and others</li>
<li>An Accessor function is a function that accesses the content of an object but does not modify that object</li>
<li>One way to adjust the SVG coordinate Space is to set the width and height to be that maximum and minimum of the X variables and Y variables</li>
<li>SVG Coordinate Space Margins are used in D3 examples to make sure that parts of the data visualization marks are not cut off because of the SVG Viewport edges</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li>
<a href="https://www.dashingd3js.com/lessons/fundamentals-of-svg">Fundamentals of SVG</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/using-the-svg-coordinate-space">Using the SVG Coordinate Space</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/d3-arrays">D3 Arrays</a>
</li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            Dynamic SVG Coordinate Space
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
SVG Coordinate Space Revisited
</strong>
</p>
<p>
<pre><code class="html">&lt;svg&gt; ... &lt;/svg&gt;</code></pre>
</p>
<p>
The SVG element is commonly referred to as the SVG Viewport.
</p>
<p>
Things within the SVG Viewports dimension's are visible
</p>
<p>
Things inside the SVG tags though outside the Viewport dimensions are not visible.
</p>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;
    &lt;circle cx="25" cy="25" r="25" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
HIGHLIGHT SVG width in green
</p>
<p>
The SVG width and height are the width and height of the view port
</p>
<p>
This setup tells the browser to set aside an area of 200 pixels by 200 pixels in the document for SVG Graphics.
</p>
<p>
This way the browser knows how to to place the rest of the elements in the HTML document.
</p>
<p>
This setup also tells the browser that the interior of the SVG viewport is 200 units wide by 200 units tall.
</p>
<p>
Outside: 200 x 200 pixels
</p>
<p>
Inside : 200 x 200 units
</p>
<br>
<p>
Why the difference?
</p>
<p>
Two reasons - 
</p>
<p>
One - SVG is based on vector graphics so it's not pixels inside
</p>
<p>
Two - Units depend on the graphic that you are creating.
</p>
<p>
<pre><code class="html">&lt;svg&gt; ... &lt;/svg&gt;</code></pre>
</p>
<br>
<p>
So for SVG
</p>
<p>
When we talk about the viewport and what is inside, we will be talking about units.
</p>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;

&lt;svg width="400" height="600"&gt;

&lt;svg width="100" height="100"&gt;

&lt;svg width="960" height="500"&gt;</code></pre>
</p>
<p>
The width and height that we choose are completely under our control.
</p>
<p>
We can make it as big or small as we want.
</p>
<p>
There are two ways to think about how to choose the dimensions of the SVG Viewport.
</p>
<p>
One - is to let the data tell you how big to make it.
</p>
<p>
Two - is to choose hard numbers and to scale the data up or down accordingly.
</p>
<p>
In this video we look at way number one - letting the data tell us how big to make the SVG Viewport.
</p>
<br>
<br>
<p>
<strong>
Basic D3 Array Utilities Revisited
</strong>
</p>
<p>
Basic D3 Array Utilities
</p>
<p>
<ul>
<li>d3.min</li>
<li>d3.max</li>
<li>d3.extent</li>
<li>d3.sum</li>
<li>d3.mean</li>
<li>d3.median</li>
</ul>
</p>
</p>
<p>
These basic D3 Array utilities told us the min, max, extent, sum, mean and median of JavaScript Arrays.
</p>
<p>
Accessor Function
</p>
<p>
<pre><code class="javascript">myData = [ { "x":05, "y":30   },{ "x": 75, "y":30  },
           { "x":75, "y":90   },{ "x":150, "y":90  },
           { "x":150, "y":150 },{ "x":190, "y":150 }];

function(d) { return d.x; }</code></pre>
</p>
<p>
An accessor function is a function that accesses the contents of an object but does not modify that object.
</p>
<p>
The anonymous function on the screen is an accessor function.
</p>
<p>
It can be applied to each JSON object in the myData array to access the contents of the "x" key or "y" key
</p>
<br>
<p>
Basic D3 Array Utilities
<p>
<ul>
<li>d3.min</li>
<li>d3.max</li>
<li>d3.extent</li>
<li>d3.sum</li>
<li>d3.mean</li>
<li>d3.median</li>
</ul>
</p>
<p>
<pre><code class="javascript">myData = [ { "x":05, "y":30   },{ "x": 75, "y":30  },
           { "x":75, "y":90   },{ "x":150, "y":90  },
           { "x":150, "y":150 },{ "x":190, "y":150 }];</code></pre>
</p>
<p>
What we did not cover before was that you could pass an Associative Arrays to these functions as long as you provided an accessor function.
</p>
<p>
Which means that we can pass the myData array of JSON objects and it will give us the right answer.
</p>
<br>
<p>
Let's look at an examples of the d3.min, d3.max, and d3.extent in the JavaScript Console
</p>
<p>
First, we define the myData array which is full of JSON objects.
</p>
<p>
<pre><code class="javascript">var myData = [ { "x":05, "y":30   },{ "x": 75, "y":30  },
               { "x":75, "y":90   },{ "x":150, "y":90  },
               { "x":150, "y":150 },{ "x":190, "y":150 }];</code></pre>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<p>
BROWSER - Click into the first object in the array to see to see the X, Y and Object
</p>
<p>
BROWSER - HIGHLIGHT the x, y and proto object.
</p>
<p>
Each JSON object contains an X and Y coordinate.
</p>
<br>
<p>
Next, let's call the Basic D3 Array Utility d3.min on the myData array
</p>
<p>
Remember - for an Associative Array, we have to pass in an accessor function
</p>
<p>
<pre><code class="javascript">d3.min(myData, function(d) { return d.x; });</code></pre>
</p>
<p>
As you can see, this returned the number 5
</p>
<p>
Which is the min x of all the JSON Objects in the myData Array.
</p>
<p>
One way to think about this is as follows:
</p>
<p>
One - D3 iterates through all of the JSON objects
</p>
<p>
Two - For each object, it pulls out the relevant data using the accessor function
</p>
<p>
Three - Each time it looks at a new object, it compares the new data to the running minimum
</p>
<p>
and Four - when it runs out of objects, it returns what was the minimum number at the end.
</p>
<br>
<p>
Next, let's call the Basic D3 Array Utility d3.Max on the myData array
</p>
<p>
Remember - for an Associative Array, we have to pass in an accessor function
</p>
<p>
This time, we want to look at the Y key.
</p>
<p>
<pre><code class="javascript">d3.max(myData, function(d) { return d.y; });</code></pre>
</p>
<p>
As you can see, this returned the number 150
</p>
<p>
Which is the max y of all the JSON Objects in the myData Array.
</p>
<p>
One way to think about this is as follows:
</p>
<p>
One - D3 iterates through all of the JSON objects
</p>
<p>
Two - For each object, it pulls out the relevant data using the accessor function
</p>
<p>
Three - Each time it looks at a new object, it compares the new data to the running maximum
</p>
<p>
Four - when it runs out of objects, it returns what was the maximum number at the end.
</p>
<br>
<p>
Next, let's call the Basic D3 Array Utility d3.Extent on the myData array
</p>
<p>
Remember - for an Associative Array, we have to pass in an accessor function
</p>
<p>
This time, we want to look at the X key.
</p>
<p>
<pre><code class="javascript">d3.extent(myData, function(d) { return d.x; });</code></pre>
</p>
<p>
As you can see, this returned the array containing the minimum 5 and the maximum 190
</p>
<p>
Which is the min and max x of all the JSON Objects in the myData Array.
</p>
<br>
<br>
<p>
<strong>
Adjusting SVG Coordinate Space
</strong>
</p>
<p>
<pre><code class="html">&lt;svg width="200" height="200">....&lt;/svg&gt;

&lt;svg width="400" height="600">....&lt;/svg&gt;

&lt;svg width="100" height="100">....&lt;/svg&gt;

&lt;svg width="960" height="500">....&lt;/svg&gt;</code></pre>
</p>
<p>
One way to set the correct width and height of the SVG Coordinate Space is to set the width to the max x and the height to the max y.
</p>
<p>
We just saw how we could do this with with the D3 Array utilities.  
</p>
<p>
<pre><code class="javascript">myData = [....];

maxX = d3.max(myData, function(d) { return d.x; })

maxY = d3.max(myData, function(d) { return d.y; })

d3.select("body")
    .append("svg")
    .attr("width" , maxX)
    .attr("height", maxY);</code></pre>
</p>
<p>
Which means we could rewrite the D3 creation of the SVG Coordinate space as follows.
</p>
<p>
First, we define the myData array which is full of JSON objects.
</p>
<p>
<pre><code class="javascript">var myData = [ { "x":05, "y":30   },{ "x": 75, "y":30  },
               { "x":75, "y":90   },{ "x":150, "y":90  },
               { "x":150, "y":150 },{ "x":190, "y":150 }];</code></pre>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<br>
<p>
Each JSON object contains an X and Y coordinate.
</p>
<br>
<p>
Next we get the maxX
</p>
<p>
<pre><code class="javascript">var maxX = d3.max(myData, function(d) { return d.x; });

maxX;</code></pre>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<br>
<p>
This gives us the maxX variable which we will use for the width.
</p>
<p>
<pre><code class="javascript">var maxY = d3.max(myData, function(d) { return d.y; });

maxY;</code></pre>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<br>
<p>
This gives us the maxY variable which we will use for the height.
</p>
<p>
<pre><code class="javascript">var svgViewport = d3.select("body").append("svg").attr("width", maxX).attr("height", maxY);</code></pre>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<br>
<p>
This created the SVG Viewport that contains the exact dimensions we need according to the data.
</p>
<br>
<br>
<p>
<strong>
SVG Coordinate Space Margins
</strong>
</p>
<p>
<a href="https://d3js.org/">https://d3js.org/</a>
</p>
<p>
Basic Examples
</p>
<p>
If you look at the D3 website examples and look at the basic examples.
</p>
<p>
You often see the margins being defined as follows.
</p>
<p>
As well as the SVG Container being defined as follow. 
</p>
<br>
<p>
</p>
<p>
Why margins?
</p>
<p>
The reason you apply margins is to leave room around the data points.
</p>
<p>
<pre><code class="javascript">var myData = [ { "x":05, "y":30   },{ "x": 75, "y":30  },
               { "x":75, "y":90   },{ "x":150, "y":90  },
               { "x":150, "y":150 },{ "x":190, "y":150 }];

// maxX = 190

// maxY = 150</code></pre>
</p>
<p>
In this instance, the max X is 190 and max y is 150.
</p>
<p>
If we were drawing circles around each of these points
</p>
<p>
This would be the CX and CY of the circle.
</p>
<p>
If we had a radius of 25, we would only be able to see 1/4 of the circle.
</p>
<p>
Because the center of the circle would be the very lower right hand corner.
</p>
<p>
For this reason, margins are typically specified.
</p>
<br>
<p>
Let's look at what happens in the JavaScript Console.
</p>
<br>
<p>
First, we define the myData array which is full of JSON objects.
</p>
<p>
<pre><code class="javascript">var myData = [ { "x":05, "y":30   },{ "x": 75, "y":30  },
               { "x":75, "y":90   },{ "x":150, "y":90  },
               { "x":150, "y":150 },{ "x":190, "y":150 }];</code></pre>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<br>
<p>
Each JSON object contains an X and Y coordinate.
</p>
<p>
<pre><code class="javascript">var maxX = d3.max(myData, function(d) { return d.x; });

var maxY = d3.max(myData, function(d) { return d.y; });</code></pre>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<br>
<p>
Then, we define the maxX and maxY data from the objects.
</p>
<p>
<pre><code class="javascript">var svgViewport = d3.select("body").append("svg").attr("width", maxX).attr("height", maxY);</code></pre>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<br>
<p>
Next, we create the svgViewport based on the max x and max y data points.
</p>
<p>
<pre><code class="javascript">var circles = svgViewport.selectAll("circle").data(myData).enter().append("circle");</code></pre>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<br>
<p>
Then we select all the circle elements, bind the data, choose the enter selection and append circles
</p>
<p>
<pre><code class="javascript">var circleAttributes = circles.attr("cx", function(d,i) { return d.x;})
    .attr("cy", function(d,i) { return d.y;})
    .attr("r",  "10");</code></pre>
</p>
<p>
BROWSER - Cut in, when this is already typed and press enter.
</p>
<p>
Finally, we add attributes to each circle.
</p>
<br>
<p>
As you can see, Some of the circles were cut off because we did not specify margins.
</p>
<p>
Which is why you need to specify margins when making data visualization.
</p>
        </div>
      </div>
    
    ☺☺</div>


<hr>
<h3 id="lesson22">D3 Scales<h3>
    <div>
    
    <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>Quantitative Scales are for continuous input domains, such as numbers</li>
<li>Ordinal Scales are for discrete input domains, such as names or categories</li>
<li>Time Scales are for time domains</li>
<li>D3 Time Scales are extension of Quantitative Scales that use JavaScript Data Objects</li>
<li>The most commonly used D3 Quantitative Scale is the D3 Linear Scale</li>
<li>The D3 Linear Scale is does a linear mapping from an input domain to an output range</li>
<li>The best way to think about the domain and range is that the left most point of the domain goes to the left most point of the range and the right most point of the domain goes to the right most point of the range</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li>
<a href="https://www.dashingd3js.com/lessons/fundamentals-of-svg">Fundamentals of SVG</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/javascript-functions">JavaScript Functions</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/d3-arrays">D3 Arrays</a>
</li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 Scales
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
SVG Coordinate Space Revisited
</strong>
</p>
<p>
<pre><code class="html">&lt;svg&gt; ... &lt;/svg&gt;</code></pre>
</p>
<p>
The SVG element is commonly referred to as the SVG Viewport.
</p>
<p>
Things within the SVG Viewports dimension's are visible
</p>
<p>
Things inside the SVG tags though outside the Viewport dimensions are not visible.
</p>
<p>
When we talk about the viewport and what is inside, we will be talking about units, not pixels.
</p>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;
    &lt;circle cx="25" cy="25" r="25" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
HIGHLIGHT SVG width in green
</p>
<p>
The SVG width and height are the width and height of the view port
</p>
<p>
This setup tells the browser to set aside an area of 200 pixels by 200 pixels in the document for SVG Graphics.
</p>
<p>
This way the browser knows how to to place the rest of the elements in the HTML document.
</p>
<p>
This setup also tells the browser that the interior of the SVG viewport is 200 units wide by 200 units tall.
</p>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;

&lt;svg width="400" height="600"&gt;

&lt;svg width="100" height="100"&gt;

&lt;svg width="960" height="500"&gt;</code></pre>
</p>
<p>
The width and height for the SVG Element that we choose are completely under our control.
</p>
<p>
We can make it as big or small as we want.
</p>
<p>
There are two ways to think about how to choose the dimensions of the SVG Viewport.
</p>
<p>
One - is to let the data tell you how big to make it.
</p>
<p>
Two - is to choose hard numbers and to scale the data up or down accordingly.
</p>
<p>
In this video we look at way number two - choosing hard numbers and scaling the data up and down accordingly.
</p>
<br>
<br>
<p>
<strong>
D3 Scales
</strong>
</p>
<p>
Quantitative Scales - for continuous input domains, such as numbers.
</p>
<p>
Ordinal Scales - for discrete input domains, such as names or categories.
</p>
<p>
Time Scales - for time domains.
</p>
<p>
D3 provides three types of functions that map an input domain to an output range.
</p>
<p>
The Quantitative scales are for real numbers
</p>
<p>
The Ordinal Scales are Discreet domains, such as letters of the alphabet
</p>
<p>
The Time Scales are an extension of the Quantitative Scales that use the JavaScript Date Objects.
</p>
<p>
All of these scales take in data and convert it to a useable set of output.
</p>
<p>
Sometimes this means scaling up the data and sometimes it means scaling down the data.
</p>
<br>
<p>Think of Maps
</p>
<p>
3 x Map Scale Images
</p>
<p>
In maps, the outside of the map can be measured in inches or centimeters
</p>
<p>
Measuring the inside in inches or centimeters completely misses the point with out a scale conversion.
</p>
<p>
On the inside, one unit could be one inch, a kilometer, a mile or something different.
</p>
<br>
<p>
Quantitative Scales - for continuous input domains, such as numbers.
</p>
<p>
Ordinal Scales - for discrete input domains, such as names or categories.
</p>
<p>
Time Scales - for time domains.
</p>
<br>
<p>
So D3 provides the way for us to take advantage of this type of scaling.
</p>
<p>
It's the equivalent of us telling D3 that 1 inch equals 1 mile and then having it calculate all the relevant information for us.
</p>
<p>
Obviously, you could do the math yourself.
</p>
<p>
I prefer to let D3 do the math for me.
</p>
<br>
<p>
D3 Scales
</p>
<p>
Quantitative Scales
</p>
<p>
<ul>
<li>Linear Scales</li>
<li>Power Scales</li>
<li>Log Scales</li>
<li>Quantize Scales</li>
<li>Quantile Scales</li>
<li>Threshold Scales</li>
</ul>
</p>
<p>
Ordinal Scales
</p>
<p>
<ul>
<li>Ordinal Scales</li>
<li>Categorical Colors</li>
<li>ColorBrewer</li>
</ul>
</p>
<p>
Time Scales
</p>
<p>
<ul>
<li>Time Scales</li>
</ul>
</p>
<p>
D3 provides many kinds of ways to transform data through Scales.
</p>
<p>
This video will focus on the Linear Scales
</p>
<p>
This allows us to explore the basic concepts of D3 Scales
</p>
<p>
Once we understand those, the rest will be easier to comprehend.
</p>
<br>
<br>
<p>
<strong>
D3 Linear Scale
</strong>
</p>
<p>
Quantitative Scales
</p>
<p>
<ul>
<li>
Linear Scales
</li>
</ul>
</p>
<br>
<p>
y = mx + b
</p>
<br>
<p>
D3 Quantitative Scales are for continuous input domains, such as numbers.
</p>
<p>
The mapping is linear in that the output range value y can be expressed as a linear function of the input domain value x.
</p>
<p>
So we get y = mx + b
</p>
<p>
Before we get into the math, let's take a step back.
</p>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;&lt;/svg&gt;

myData = [ { "n":  0, "p":  0 },{ "n":200, "p":200 },
           { "n":300, "p":300 },{ "n":400, "p":400 }];</code></pre>
</p>
<p>
We start with the SVG Container.
</p>
<p>
It has to be 200 pixels wide by 200 pixels tall.
</p>
<p>
This is the room it has in the HTML web page.
</p>
<p>
We cannot change the size.
</p>
<p>
Then we have the myData array.
</p>
<p>
The data process we are visualizing produces 4 n,p coordinates.
</p>
<p>
For the data snapshot we are currently looking at, it has produced numbers bigger than 200 for both N and P.
</p>
<p>
Why does 200 matter?
</p>
<br>
<p>
1 : 1 Scale?
</p>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;

myData = [ { "n":  0, "p":  0 },{ "n":200, "p":200 },
           { "n":300, "p":300 },{ "n":400, "p":400 }];</code></pre>
</p>
<p>
It matters, because if we use a 1 to 1 scale, 
</p>
<p>
All the points that have n or p values greater than 200 will not be visible in the SVG Viewport.
</p>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;</code></pre>
</p>
<p>
Going back to the SVG Viewport
</p>
<p>
Things within the SVG Viewports dimension's are visible
</p>
<p>
Things inside the SVG tags though outside the Viewport dimensions are not visible.
</p>
<p>
So anything inside of the box defined by 0,0, 0,200, 200,0 and 200,200 are visible
</p>
<p>
and anything outside of the box defined by 0,0, 0,200, 200,0 and 200,200 are not visible
</p>
<br>
<p>
1 : x Scale
</p>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;

myData = [ { "n":  0, "p":  0 },{ "n":200, "p":200 },
           { "n":300, "p":300 },{ "n":400, "p":400 }];</code></pre>
</p>
<p>
What we want to find is what 1 unit is equal to such that all of the data fits into the SVG Container Viewport.
</p>
<p>
This way, all of the data will be visible within of the 200 by 200 viewport.
</p>
<p>
<pre><code class="javascript">&lt;svg width="200" height="200"&gt;

myData = [ { "n":  0, "p":  0 },{ "n":200, "p":200 },
           { "n":300, "p":300 },{ "n":400, "p":400 }];</code></pre>

</p>
<p>
Y = mX + b
</p>
<p>
This is where the math comes in
</p>
<p>
The X's that we take in from our data
</p>
<p>
Have to fit into the 200 by 200 box
</p>
<p>
Which means that maximum that the Y can be is 200.
</p>
<p>
<pre><code class="javascript">myData = [ { "n":  0, "p":  0 },{ "n":200, "p":200 },
           { "n":300, "p":300 },{ "n":400, "p":400 }];

// minP =   0

// maxP = 400

// minN =   0

// maxN = 400</code></pre>
</p>
<p>
So we want to translate our data so that the maxP and maxN are 200 instead of 400.
</p>
<p>
Scale - 1:2 ... one new unit = 2 old units
</p>
<p>
<pre><code class="javascript">myData_old = [ { "n":  0, "p":  0 },{ "n":200, "p":200 },
               { "n":300, "p":300 },{ "n":400, "p":400 }];

myData_new = [ { "n":  0, "p":  0 },{ "n":100, "p":100 },
               { "n":150, "p":150 },{ "n":200, "p":200 }];</code></pre>
</p>
<p>
To do that we could divide the data by two
</p>
<p>
Such that every new unit is equal to two old units.
</p>
<p>
This does the trick in that the new data fits into the SVG Viewport.
</p>
<br>
<p>
Scale - 1:2 ... one new unit = 2 old units
</p>
<p>
y = ( 1/2 ) * x
</p>
<p>
And this is the math.
</p>
<p>
Take an old unit and divide it by two to get a new unit.
</p>
<p>
Notice that the b disappeared because we are not adding or subtracting anything to go from old units to new units.
</p>
<p>
<pre><code class="javascript">d3.scale.linear()
    .domain( [0,400] )
    .range( [0,200] );</code></pre>
</p>
<p>
Rather than having to do this math, we can get D3 to do the math for us.
</p>
<p>
Using the D3 Scale Linear
</p>
<p>
We can tell D3 that the initial data covers 0 to 400
</p>
<p>
and we want it to cover 0 to 200 after it has been scaled.
</p>
<p>
This figures out what the correct math for the right m and b should be.
</p>
<br>
<p>
Let's take a look at the domain operator for the D3 linear scale first.
</p>
<br>
<br>
<p>
<strong>
D3 Linear Scale Domain
</strong>
</p>
<p>
<pre><code class="javascript">d3.scale.linear()
    .domain( [0,400] ) ** HIGHLIGHT GREEN **
    .range( [0,200] );</code></pre>
</p>
<p>
In this example, the domain takes in 1 array that contains two numbers in it.
</p>
<p>
Note - these numbers can be anything you want.
</p>
<p>
These numbers should cover all the possible values of the data you are using.
</p>
<br>
<p>
ℝ - Real Numbers
<br>
LINE 1:
<br>
----------A---------B---------C---------  ** LINE OF NUMBERS **
</p>
<p>
D3 scale linear maps a real number line to a second real number line
</p>
<p>
To visualize this, imagine a line that has numbers
</p>
<p>
If we do this, then we can talk about numbers to being to the left or to the right of each other.
</p>
<p>
In this instance, A is to the left of B
</p>
<p>
B is to the left of C
</p>
<p>
and A is to the left of C
</p>
<p>
We can also say that C is to the right of B
</p>
<p>
B is to the right of A
</p>
<p>
and C is to the right of A

</p>
<br>
<p>
ℝ - Real Numbers
<br>
Line 1:
<br>
----------A---------B---------C---------  ** LINE OF NUMBERS **
<br>
Domain of Line 1 = [A,C].
</p>
<p>
If the data we get exists only between A and C
</p>
<p>
Including A and C
</p>
<p>
Then we can say that the domain of Line 1 is [A,C].
</p>
<p>
Which if we use directions means all of the numbers to the Right of A up to and including C, but nothing to the right of C.

</p>
<br>
<p>
ℝ - Real Numbers
<br>
Line 1:
<br>
----------A---------B---------C---------  ** LINE OF NUMBERS **
<br>
Domain of Line 1 = [A,C].
</p>
<p>
Both valid: [0,400] and [400,0] ** HIGHLIGHT Both Valid orange. **
</p>
<p>
Why do we use directions instead of bigger than or less than?
</p>
<p>
Because the domains [0,400] and [400,0] are both valid.
</p>
<p>
The domain [0,400] specifies that as we go to the right the numbers increase
</p>
<p>
The domain [400,0] specifies that as we go to the right the numbers decrease
</p>
<p>
Most people think of number lines where numbers increase as you go to the right.
</p>
<p>
However, there is nothing to stop us from describing a number line where numbers decrease as you go to the right.
</p>
<p>
After all, in non-SVG coordinate space as Y increases you go up but in SVG coordinate space as Y increases you go down.
</p>
<p>
So it's best to think of domains as all the numbers to the right of the first number up to and including the second number, but nothing to the right of the second number.
</p>
<p>
<pre><code class="javascript">d3.scale.linear()
    .domain( [0,400] ) // ** HIGHLIGHT GREEN **
    .range( [0,200] );</code></pre>
</p>
<p>
So the domain is just telling D3 all the possible values that the data will cover.
</p>
<p>
From the left most value to the right most value.
</p>
<p>
Next we cover the range.
</p>
<br>
<br>
<p>
<strong>
D3 Linear Scale Range
</strong>
</p>
<p>
<pre><code class="javascript">d3.scale.linear()
    .domain( [0,400] ) 
    .range( [0,200] ); //** HIGHLIGHT GREEN **</code></pre>
</p>
<p>
In this example, the range takes in 1 array that contains two numbers in it.
</p>
<p>
Note - these numbers can be anything you want.
</p>
<p>
These numbers should cover all of the possible values that you want the data to be mapped to.
</p>
<br>
<p>
ℝ - Real Numbers
<br>
LINE 1:
<br>
----------A---------B---------C---------  ** LINE OF NUMBERS **
<br>
LINE 2:
<br>
----------D---------E---------F---------  ** LINE OF NUMBERS **
</p>
<p>
D3 scale linear maps a real number line to a second real number line
</p>
<p>
To visualize this, imagine a line that has numbers
</p>
<p>
Just like we did with line 1,
</p>
<p>
We can talk about the numbers on line two being to the left or to the right of each other.
</p>
<p>
In this instance, D is to the left of E
</p>
<p>
E is to the left of F
</p>
<p>
and D is to the left of F
</p>
<p>
We can also say that F is to the right of E
</p>
<p>
E is to the right of D
</p>
<p>
and F is to the right of D
</p>
<br>
<p>
ℝ - Real Numbers
<br>
LINE 1: Domain
<br>
----------A---------B---------C---------  ** LINE OF NUMBERS **
<br>
LINE 2: Range
<br>
----------D---------E---------F---------  ** LINE OF NUMBERS **
</p>
<p>
The Range is thus the result of the transformation from Line 1 to Line 2
</p>
<p>
The left most element in Line 1 gets transformed to the left most element in Line 2
</p>
<p>
And the right most element in Line 1 gets transformed to the right most element in Line 2
</p>
<p>
And a middle elements in line 1 gets transformed to a middle elements in line 2.
</p>
<p>
<pre><code class="javascript">d3.scale.linear()
    .domain( [0,400] ) 
    .range( [0,200] ); ** HIGHLIGHT GREEN **</code></pre>

  LINE 2: Range
  ----------D---------E---------F---------  ** LINE OF NUMBERS **
</p>
<p>
When we tell D3 what the range is, we are defining what the left most and right most elements are in line 2.
</p>
<p>
<pre><code class="javascript">d3.scale.linear()
    .domain( [0,400] ) 
    .range( [200,0] ); //** HIGHLIGHT GREEN **</code></pre>
</p>
<p>
Why directions for the range as well?
</p>
<p>
Because the scale on the screen is also valid.
</p>
<p>
This means that as we move from 0 to 400 on Line 1
</p>
<p>
We want to move from 200 to 0 in Line 2.
</p>
<p>
When would we want this to happen?
</p>
<p>
On the SVG Coordinate Y axis.
</p>
<p>
For a Data Visualization, people will expect that as Y-axis variable grows that it will go up.
</p>
<p>
So as the Y-Axis variable goes from 0 to 400,
</p>
<p>
The SVG coordinates drawn should go from 200 to 0.
</p>
<p>
Which in SVG Coordinate space means that they will go from the bottom of the graph to the top.
</p>
<br>
<p>
And that is the domain and range of the D3 linear scale.
</p>
        </div>
      </div>

</div>☺

<hr>
<h3 id="lesson23">D3 Scales Part Two<h3>
    <div>
         <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>D3 provides three types of scale functions that map an input domain to an output range - Quantitative Scales, Ordinal Scales, and Time scales</li>
<li>The best way to think about the domain and range is that the left most point of the defined domain goes to the left most point of the defined range and the right most point of the defined domain goes to the right most point of the defined range</li>
<li>D3 Scales are functions</li>
<li>The D3 Scale function assumes that when you pass it an argument, that you are passing it a value from the domain and are expecting a value from the range in return</li>
<li>By setting the domain and scale of a D3 Scale function, you can use it later to do conversions as you need</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li>
<a href="https://www.dashingd3js.com/lessons/fundamentals-of-svg">Fundamentals of SVG</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/javascript-functions">JavaScript Functions</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/d3-arrays">D3 Arrays</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/d3-scales">D3 Scales</a>
</li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 Scales Part Two
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
D3 Scales Revisited
</strong>
</p>
<p>
Quantitative Scales - for continuous input domains, such as numbers.
</p>
<p>
Ordinal Scales - for discrete input domains, such as names or categories.
</p>
<p>
Time Scales - for time domains.
</p>
<br>
<p>
D3 provides three types of functions that map an input domain to an output range.
</p>
<p>
The Quantitative scales are for real numbers
</p>
<p>
The Ordinal Scales are Discreet domains, such as letters of the alphabet
</p>
<p>
The Time Scales are an extension of the Quantitative Scales that use the JavaScript Date Objects.
</p>
<br>
<p>
All of these scales take in data and convert it to a useable set of output.
</p>
<p>
Sometimes this means scaling up the data and sometimes it means scaling down the data.
</p>
<br>
<p>
D3 Scales
</p>
<p>
Quantitative Scales
</p>
<p>
<ul>
<li>Linear Scales</li>
<li>Power Scales</li>
<li>Log Scales</li>
<li>Quantize Scales</li>
<li>Quantile Scales</li>
<li>Threshold Scales</li>
</ul>
</p>
<br>
<p>
Ordinal Scales
</p>
<p>
<ul>
<li>Ordinal Scales</li>
<li>Categorical Colors</li>
<li>ColorBrewer</li>
</ul>
</p>
<br>
<p>
Time Scales
</p>
<p>
<ul>
<li>Time Scales</li>
</ul>
</p>
<br>
<p>
D3 provides many kinds of ways to transform data through Scales.
</p>
<p>
This video focuses on the Linear Scale
</p>
<p>
This allows us to explore the basic concepts of D3 Scales and
</p>
<p>
Once we understand those, the rest will be easier to comprehend.
</p>
<br>
<p>
Quantitative Scales- Linear Scales
</p>
<p>
y = mx + b
</p>
<p>
D3 Quantitative Scales are for continuous input domains, such as numbers.
</p>
<p>
The mapping is linear in that the output range value y can be expressed as a linear function of the input domain value x.
</p>
<p>
So we get y = mx + b
</p>
<br>
<p>
<pre><code class="javascript">d3.scale.linear()
    .domain( [0,400] )
    .range( [0,200] );</code></pre>
</p>
<p>
Rather than having to do this math ourselves, we can get D3 to do the math for us.
</p>
<p>
Using the D3 Scale Linear
</p>
<p>
We can tell D3 that the initial data covers 0 to 400
</p>
<p>
and we want it to cover 0 to 200 after it has been scaled.
</p>
<p>
This then figures out the correct math for the y=mx+b equation.
</p>
<p>
<pre><code class="javascript">d3.scale.linear().domain(...).range(...);</code></pre>
</p>
<p>  
ℝ - Real Numbers
<br>
LINE 1: Domain
<br>
----------A---------B---------C---------
<br>
LINE 2: Range
<br>
----------D---------E---------F---------
</p>
<p>
The Range is thus the result of the transformation from Line 1, the Domain, to Line 2
</p>
<p>
The left most element in Line 1 gets transformed to the left most element in Line 2
</p>
<p>
And the right most element in Line 1 gets transformed to the right most element in Line 2
</p>
<p>
And a middle elements in line 1 gets transformed to a middle elements in line 2.    
</p>
<p>
y = mx + b
<br>
abs(m) < 1 - then shrinking data
<br>
abs(m) > 1 - then expanding data
<br>
b > 0 - then moving data to the right
<br>
b < 0 - then moving data to the left
</p>
<p>
Lastly, a little bit of math to help our thinking:
</p>
<p>
If the absolute value of m is less than 1, then we are shrinking the data from the domain to the range
</p>
<p>
If the absolute value of m is greater than 1, then we are expanding the data from the domain to the range
</p>
<p>
If the the value of b is greater than 0, then we are moving the data to the right
</p>
<p>
If the the value of b is less than 0, then we are moving the data to the left
</p>
<p>
D3 takes care of this math for us with the conversion from domain to range.
</p>
<p>
Alright, so we've covered how the D3 Scale takes in a domain of numbers and figures out the math to convert it to a range of numbers.
</p>
<br>
<p>
What can we do with that?
</p>
<br>
<br>
<p>
<strong>
D3 Scales as Functions
</strong>
</p>
<p>
<pre><code class="javascript">d3.scale.linear().domain(...).range(...);</code></pre>
</p>
<p>
D3 scales are functions.
</p>
<p>
Which means we can use them to generate values useful to generating data and Data Visualizations.
</p>
<p>
The d3.scale linear function assumes that when you pass it values, that you are passing values from the domain line.
</p>
<p>
The d3.scale linear function then will return to you a value from the range line.
</p>
<p>
So it works as a mapping function.
</p>
<p>
Give it a number from line 1 and it will return to you a number from line 2.
</p>
<br>
<p>
Let's take a look at some examples in the JavaScript Console.
</p>
<p>
First we take a look at how the d3.scale.linear can scale data upwards.
</p>
<p>
<pre><code class="javascript">var scaleUp = d3.scale.linear().domain([0,10]).range([0,100]);</code></pre>
</p>
<p>
In this case, we want to transform the line of numbers from 0 to 10 to a line of numbers from 0 to 100.
</p>
<p>
Doing this in your head, this means we want to multiply each number in the domain by 10.
</p>
<p>
BROWSER - PRESS ENTER 
</p>
<br>
<p>
Let's check to see what was assigned to the scaleUp variable
</p>
<p>
<pre><code class="javascript">scaleUp;

typeof(scaleUp);</code></pre>
</p>
<p>
The scaleUp command returns the function while the typeOf(scapeUp) command returns the function string.
</p>
<p>
This means that d3.scale.linear() is a function.
</p>
<br>
<p>
Next, let's test the left end points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">scaleUp(0);</code></pre>
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
As we covered earlier, the function assumes that you are giving it a number from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
We told the function to convert the left most point in line 1 to the left most point in line 2.
</p>
<p>
In this case, both left most points were 0.
</p>
<p>
So we should expect zero.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned zero.
</p>
<br>
<p>
Next, let's test the right end points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">scaleUp(10);</code></pre>
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
As we covered earlier, the function assumes that you are giving it a number from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
We told the function to convert the right most point in line 1 to the right most point in line 2.
</p>
<p>
In this case, we were converting line 1 point 10 to line 2 point 100.
</p>
<p>
So we should expect 100.
</p>
<p>
BROWSER - PRESS ENTER 
</p>
<p>
As you can see, it returned 100.
</p>
<br>
<p>
Next, let's test the middle points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">[scaleUp(1), scaleUp(2), scaleUp(5), scaleUp(8), scaleUp(9)];</code></pre>
</p>
<p>
I put the functions into an array to save space so that we could test a few of them at the same time.
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
As we covered earlier, the function assumes that you are giving it a number from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
The function should multiply every number in the domain by 10 to convert it to a number in the range.
</p>
<p>
So we should expect 10, 20, 50, 80 and 90.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned 10, 20, 50, 80 and 90.
</p>
<br>
<p>
From this we can see that after we define the function with our initial data, we can use it to convert data for later use.
</p>
<br>
<p>
Let's reload the browser and look at how we can scale the data downwards.  
</p>
<br>
<p>
Second, we take a look at how the d3.scale.linear can scale data downwards.
</p>
<p>
<pre><code class="javascript">var scaleDown = d3.scale.linear().domain([0,100]).range([0,10]);</code></pre>
</p>
<p>
In this case, we want to transform the line of numbers from 0 to 100 to a line of numbers from 0 to 10.
</p>
<p>
As you can do in your head, this means we want to divide each number in the domain by 10.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<br>
<p>
Let's check to see what was assigned to the scaleDown variable
</p>
<p>
<pre><code class="javascript">scaleDown;

typeof(scaleDown);</code></pre>
</p>
<p>
The scaleDown command returns the function while the typeOf(scaleDown) command returns the function string.
</p>
<p>
This shows us again that d3.scale.linear() is a function.
</p>
<br>
<p>
Next, let's test the left end points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">scaleDown(0);</code></pre>
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
As we covered earlier, the function assumes that you are giving it a number from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
We told the function to convert the left most point in line 1 to the left most point in line 2.
</p>
<p>
In this case, both left most points were 0.
</p>
<p>
So we should expect zero.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned zero.
</p>
<br>
<p>
Next, let's test the right end points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">scaleDown(100);</code></pre>
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
As we covered earlier, the function assumes that you are giving it a number from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
We told the function to convert the right most point in line 1 to the right most point in line 2.
</p>
<p>
In this case, we were converting line 1 point 100 to line 2 point 10.
</p>
<p>
So we should expect 10.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned 10.
</p>
<br>
<p>
Next, let's test the middle points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">[scaleDown(10), scaleDown(20), scaleDown(50), scaleDown(80), scaleDown(90)];</code></pre>
</p>
<p>
I put the functions into an array to save space so that we could test a few of them at the same time.
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
As we covered earlier, the function assumes that you are giving it a number from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
The function should divide every number in the domain by 10 to convert it to a number in the range.
</p>
<p>
So we should expect 1, 2, 5, 8 and 9.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned 1, 2, 5, 8 and 9.
</p>
<br>
<p>
From this we can see that after we define the function with our initial data, we can use it to convert data for later use.
</p>
<br>
<p>
Let's reload the browser and look at how we can move the data to the right on the number line.   
</p>
<br>
<p>
Third, we take a look at how the d3.scale.linear can move the data to the right on the number line.
</p>
<p>
<pre><code class="javascript">var shiftRight = d3.scale.linear().domain([0,100]).range([100,200]);</code></pre>
</p>
<p>
In this case, we want to transform the line of numbers from 0 to 100 to a line of numbers from 100 to 200.
</p>
<p>
As you can do in your head, this means we want to add 100 to each number in the domain.
</p>
<p>
If you know your algebra and understood the math slide above, then you realize that this means that in the equation y=mx+b
</p>
<p>
we are setting m to be 1 and b to be positive 100.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<br>
<p>
Let's check to see what was assigned to the shiftRight variable
</p>
<p>
<pre><code class="javascript">shiftRight;

typeof(shiftRight);</code></pre>
</p>
<p>
The shiftRight command returns the function while the typeOf(shiftRight) command returns the function string.
</p>
<p>
This shows us again that d3.scale.linear() is a function.  
</p>
<br>
<p>
Next, let's test the left end points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">shiftRight(0);</code></pre>
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
As we covered earlier, the function assumes that you are giving it a number from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
We told the function to convert the left most point in line 1 to the left most point in line 2.
</p>
<p>
In this case, we were converting line 1 point 0 to line 2 point 100.
</p>
<p>
So we should expect 100.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned 100.
</p>
<br>
<p>
Next, let's test the right end points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">shiftRight(100);</code></pre>
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
As we covered earlier, the function assumes that you are giving it a number from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
We told the function to convert the right most point in line 1 to the right most point in line 2.
</p>
<p>
In this case, we were converting line 1 point 100 to line 2 point 200.
</p>
<p>
So we should expect 200.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned 200.
</p>
<br>
<p>
Next, let's test the middle points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">[shiftRight(10), shiftRight(20), shiftRight(50), shiftRight(80), shiftRight(90)];</code></pre>
</p>
<p>
I put the functions into an array to save space so that we could test a few of them at the same time.
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
As we covered earlier, the function assumes that you are giving it a number from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
The function should add 100 to every number in the domain to convert it to a number in the range.
</p>
<p>
So we should expect 110, 120, 150, 180 and 190.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned 110, 120, 150, 180 and 190.
</p>
<br>
<p>
From this we can see that after we define the function with our initial data, we can use it to convert data for later use.
</p>
<br>
<p>
Let's reload the browser and look at how we can move the data to the left on the number line. 
</p>
<br>
<p>
Fourth, we take a look at how the d3.scale.linear can move the data to the left on the number line.
</p>
<p>
<pre><code class="javascript">var shiftLeft = d3.scale.linear().domain([100,200]).range([0,100]);</code></pre>
</p>
<p>
In this case, we want to transform the line of numbers from 100 to 200 to a line of numbers from 0 to 100.
</p>
<p>
As you can do in your head, this means we want to subtract 100 from each number in the domain.
</p>
<p>
If you know your algebra and understood the math slide above, then you realize that this means that in the equation y=mx+b
</p>
<p>
we are setting m to be 1 and b to be negative 100.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<br>
<p>
Let's check to see what was assigned to the shiftLeft variable
</p>
<p>
<pre><code class="javascript">shiftLeft;

typeof(shiftLeft);</code></pre>
</p>
<p>
The shiftLeft command returns the function while the typeOf(shiftLeft) command returns the function string.
</p>
<p>
This shows us again that d3.scale.linear() is a function.
</p>
<br>
<p>
Next, let's test the left end points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">shiftLeft(100);</code></pre>
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
As we covered earlier, the function assumes that you are giving it a number from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
We told the function to convert the left most point in line 1 to the left most point in line 2.
</p>
<p>
In this case, we were converting line 1 point 100 to line 2 point 0.
</p>
<p>
So we should expect 0.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned zero.
</p>
<br>
<p>
Next, let's test the right end points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">shiftLeft(200);</code></pre>
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
As we covered earlier, the function assumes that you are giving it a number from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
We told the function to convert the right most point in line 1 to the right most point in line 2.
</p>
<p>
In this case, we were converting line 1 point 200 to line 2 point 100.
</p>
<p>
So we should expect 100.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned 100.
</p>
<br>
<p>
Now, let's test the middle points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">[shiftLeft(110), shiftLeft(120), shiftLeft(150), shiftLeft(180), shiftLeft(190)];</code></pre>
</p>
<p>
I put the functions into an array to save space so that we could test a few of them at the same time.
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
As we covered earlier, the function assumes that you are giving it a number from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
The function should subtract 100 from every number in the domain to convert it to a number in the range.
</p>
<p>
So we should expect 10, 20, 50, 80 and 90.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned 10, 20, 50, 80 and 90.
</p>
<br>
<p>
From this we can see that after we define the function with our initial data, we can use it to convert data for later use.
</p>
<br>
<p>
Let's reload the browser and look at how we can do two operations at once - an expanding and shifting to the right.
</p>
<br>
<p>
As you can guess, we can expand or contract as well as shift to the right or the left.
</p>
<br>
<p>
Though we only look at one of the four possible combinations, the example should be a guide to the rest.  
</p>
<br>
<p>
Fifth, we take a look at how the d3.scale.linear can scale the data up and move the data to the right on the number line.
</p>
<p>
<pre><code class="javascript">var scaleUpAndShiftRight = d3.scale.linear().domain([0,10]).range([100,200]);</code></pre>
</p>
<p>
In this case, we want to transform the line of numbers from 0 to 10 to a line of numbers from 100 to 200.
</p>
<p>
This transformation implies two things.
</p>
<p>
One - every number in the domain is multiplied by 10
</p>
<p>
Two - that multiplication result then has 100 added to it.
</p>
<p>
If you know your algebra and understood the math slide above, then you realize that this means that in the equation y=mx+b
</p>
<p>
we are setting m to be 10 and b to be positive 100.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<br>
<p>
Let's check to see what was assigned to the scaleUpAndShiftRight variable
</p>
<p>
<pre><code class="javascript">scaleUpAndShiftRight;
typeof(scaleUpAndShiftRight);</code></pre>
</p>
<p>
The scaleUpAndShiftRight command returns the function while the typeOf(scaleUpAndShiftRight) command returns the function string.
</p>
<p>
This shows us again that d3.scale.linear() is a function.
</p>
<br>
<p>
Next, let's test the left end points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">scaleUpAndShiftRight(0);</code></pre>
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
As we covered earlier, the function assumes that you are giving it a number from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
We told the function to convert the left most point in line 1 to the left most point in line 2.
</p>
<p>
In this case, we were converting line 1 point 0 to line 2 point 100.
</p>
<p>
So we should expect 100.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned 100.
</p>
<br>
<p>
Next, let's test the right end points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">scaleUpAndShiftRight(10);</code></pre>
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
As we covered earlier, the function assumes that you are giving it a number from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
We told the function to convert the right most point in line 1 to the right most point in line 2.
</p>
<p>
In this case, we were converting line 1 point 10 to line 2 point 200.
</p>
<p>
So we should expect 200.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned 200.
</p>
<br>
<p>
Next, let's test the middle points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">[scaleUpAndShiftRight(1), scaleUpAndShiftRight(2), scaleUpAndShiftRight(5), scaleUpAndShiftRight(8), scaleUpAndShiftRight(9)];</code></pre>
</p>
<p>
I put the functions into an array to save space so that we could test a few of them at the same time.
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
As we covered earlier, the function assumes that you are giving it a number from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
The function should multiply by 10 and then add 100 to every number in the domain to convert it to a number in the range.
</p>
<p>
So we should expect 110, 120, 150, 180 and 190.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned 110, 120, 150, 180 and 190.
</p>
<br>
<p>
From this we can see that after we define the function with our initial data, we can use it to convert data for later use.
</p>
<br>
<p>
I imagine that you now have the hang of this.
</p>
<br>
<p>
Let's reload the browser and look at what happens if we reserve the domain and range inputs.
</p>
<br>
<p>
Sixth and Lastly, we take a look at how the d3.scale.linear can the reverse the domain.
</p>
<p>
<pre><code class="javascript">var scaleReverse = d3.scale.linear().domain([0,10]).range([10,0]);</code></pre>
</p>
<p>
In this case, we want to transform the line of numbers from 0 to 10 to a line of numbers from 10 to 0.
</p>
<p>
This one is trickier to do in our heads.
</p>
<p>
If you do the math, it means that we want to multiply each domain number by negative 1 and then add 10.
</p>
<p>
If you know your algebra and understood the math slide above, then you realize that this means that in the equation y=mx+b
</p>
<p>
We are setting m to be negative 1 and b to be positive 10.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<br>
<p>
Let's check to see what was assigned to the scaleReverse variable
</p>
<p>
<pre><code class="javascript">scaleReverse;

typeof(scaleReverse);</code></pre>
</p>
<p>
The scaleReverse command returns the function while the typeOf(scaleReverse) command returns the function string.
</p>
<p>
This shows us again that d3.scale.linear() is a function.
</p>
<br>
<p>
Next, let's test the left end points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">scaleReverse(0);</code></pre>
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
As we covered earlier, the function assumes that you are giving it a number from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
We told the function to convert the left most point in line 1 to the left most point in line 2.
</p>
<p>
In this case, we were converting line 1 point 0 to line 2 point 10.
</p>
<p>
So we should expect 10.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned 10.
</p>
<br>
<p>
Next, let's test the right end points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">scaleReverse(10);</code></pre>
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
As we covered earlier, the function assumes that you are giving it a number from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
We told the function to convert the right most point in line 1 to the right most point in line 2.
</p>
<p>
In this case, we were converting line 1 point 10 to line 2 point 0.
</p>
<p>
So we should expect 0.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned 0.
</p>
<br>
<p>
Next, let's test the middle points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">[scaleReverse(1), scaleReverse(2), scaleReverse(5), scaleReverse(8), scaleReverse(9)];</code></pre>
</p>
<p>
I put the functions into an array to save space so that we could test a few of them at the same time.
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
As we covered earlier, the function assumes that you are giving it a number from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
The function should multiply every number in the domain by negative one and then add 10 to convert it to a number in the range.
</p>
<p>
So we should expect 9, 8, 5, 2 and 1.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned 9, 8, 5, 2 and 1.
</p>
<br>
<p>
<pre><code class="javascript">d3.scale.linear()
          .domain( [0,400] )
          .range( [0,200] );</code></pre>
</p>
<p>
And with that, you can see just how powerful the D3 Scale Linear function can be
</p>
<p>
because we can scale one data set to another.
</p>
        </div>
      </div>

☺</div>


<hr>
<h3 id="lesson24">D3 Scales Part Three<h3>
    <div>
        <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>D3 provides three types of scale functions that map an input domain to an output range - Quantitative Scales, Ordinal Scales, and Time scales</li>
<li>The best way to think about the domain and range is that the left most point of the defined domain goes to the left most point of the defined range and the right most point of the defined domain goes to the right most point of the defined range</li>
<li>D3 Scale functions allow us to use D3 to do the math for us when figuring out the scale conversion</li>
<li>D3 Scale functions can be used to scale data (up or down) to fit within an SVG Viewport</li>
<li>The D3 Scale function's range will be decided by the SVG Viewport dimensions</li>
<li>The D3 Scale function's domain will be decided by the data that comes in</li>
<li>The D3 Scale function can be used to create and place SVG basic shapes to represent data</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li>
<a href="https://www.dashingd3js.com/lessons/fundamentals-of-svg">Fundamentals of SVG</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/javascript-functions">JavaScript Functions</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/d3-arrays">D3 Arrays</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/d3-scales">D3 Scales</a>
</li>
<li>
<a href="https://www.dashingd3js.com/lessons/d3-scales-part-two">D3 Scales Part Two</a>
</li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 Scales Part Three
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
D3 Scales Revisited
</strong>
</p>
<br>
<p>
Quantitative Scales - for continuous input domains, such as numbers.
</p>
<p>
Ordinal Scales - for discrete input domains, such as names or categories.
</p>
<p>
Time Scales - for time domains.
</p>
<br>
<p>
D3 provides three types of functions that map an input domain to an output range.
</p>
<p>
The Quantitative scales are for real numbers
</p>
<p>
The Ordinal Scales are Discreet domains, such as letters of the alphabet
</p>
<p>
The Time Scales are an extension of the Quantitative Scales that use the JavaScript Date Objects.
</p>
<br>
<p>
All of these scales take in data and convert it to a useable set of output.
</p>
<p>
Sometimes this means scaling up the data and sometimes it means scaling down the data.
</p>
<br>
<p>
D3 Scales
</p>
<p>
Quantitative Scales
</p>
<p>
<ul>
<li>Linear Scales</li>
<li>Power Scales</li>
<li>Log Scales</li>
<li>Quantize Scales</li>
<li>Quantile Scales</li>
<li>Threshold Scales</li>
</ul>
</p>
<br>
<p>
Ordinal Scales
</p>
<p>
<ul>
<li>Ordinal Scales</li>
<li>Categorical Colors</li>
<li>ColorBrewer</li>
</ul>
</p>
<br>
<p>
Time Scales
</p>
<p>
<ul>
<li>Time Scales</li>
</ul>
</p>
<br>
<p>
D3 provides many kinds of ways to transform data through Scales.
</p>
<p>
This video focuses on the Linear Scale
</p>
<p>
This allows us to explore the basic concepts of D3 Scales and
</p>
<p>
Once we understand those, the rest will be easier to comprehend.
</p>
<br>
<p>
Quantitative Scales - Linear Scales
</p>
<p>
y = mx + b
</p>
<br>
<p>
D3 Quantitative Scales are for continuous input domains, such as numbers.
</p>
<p>
The mapping is linear in that the output range value y can be expressed as a linear function of the input domain value x.
</p>
<p>
So we get y = mx + b
</p>
<br>
<p>
<pre><code class="javascript">d3.scale.linear()
    .domain([0,400] )
    .range( [0,200] );</code></pre>
</p>
<p>
Rather than having to do this math ourselves, we can get D3 to do the math for us.
</p>
<p>
Using the D3 Scale Linear
</p>
<p>
We can tell D3 that the initial data covers 0 to 400
</p>
<p>
and we want it to cover 0 to 200 after it has been scaled.
</p>
<p>
This then figures out the correct math for the y=mx+b equation.	
</p>
<br>
<p>
<pre><code class="javascript">d3.scale.linear().domain(...).range(...);</code></pre>
</p>
<p>
ℝ - Real Numbers
<br>
LINE 1: Domain
<br>
----------A---------B---------C--------- 
<br>
LINE 2: Range
<br>
----------D---------E---------F--------- 
</p>
<p>
The Range is thus the result of the transformation from Line 1, the Domain, to Line 2
</p>
<p>
The left most element in Line 1 gets transformed to the left most element in Line 2
</p>
<p>
And the right most element in Line 1 gets transformed to the right most element in Line 2
</p>
<p>
And a middle elements in line 1 gets transformed to a middle elements in line 2.		
</p>
<br>
<p>
<pre><code class="javascript">var lineScale = d3.scale.linear().domain(...).range(...);</code></pre>
</p>
<p>
D3 scales are functions.
</p>
<p>
Which means we can use them to generate values useful to generating data and Data Visualizations.
</p>
<p>
The d3.scale linear function assumes that when you pass it values, that you are passing values from the domain line.
</p>
<p>
The d3.scale linear function then will return to you a value from the range line.
</p>
<p>
So it works as a mapping function.
</p>
<p>
Give it a number from line 1 and it will return to you a number from line 2.
</p>
<br>
<p>
At this point you should understand what a linear scale is, what the domain is and what the range is.
</p>
<p>
Now let's take a look at how we can use them in a data visualization.
</p>
<br>
<br>
<p>
<strong>
SVG Container and D3 Scales
</strong>
</p>
<br>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;

myData = [ { "n":  0, "p":  0 },{ "n":200, "p":200 },
           { "n":300, "p":300 },{ "n":400, "p":400 }];</code></pre>
</p>
<p>
We come back to the SVG viewport that is 200 units by 200 units.
</p>
<p>
There are two ways to make sure the myData data fits into the SVG Viewport
</p>
<p>
One - scale up the dimensions of the SVG Viewport so that it contains the max n and max p variables.
</p>
<p>
Two - scale down the data so that it fits into the SVG Viewport with hardcoded numbers.
</p>
<p>
Using the knowledge we have now acquired about d3.scale.linear, the domain and the range
</p>
<p>
We have all the tools necessary to do the second option - scale down the data to fit into the SVG Viewport.
</p>
<br>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;
	
myData = [ { "n":  0, "p":  0 },{ "n":200, "p":200 },
           { "n":300, "p":300 },{ "n":400, "p":400 }];</code></pre>
</p>
<p>
Because we know the SVG Viewport is 2-dimensional And the myData set is two-dimensional
</p>
<p>
We can choose to map N values to the x-coordinates
</p>
<p>
And choose to map P values to the y-coordinates On the SVG Coordinate Space.
</p>
<p>
This means that we will need two linear scale functions:
</p>
<p>
One for the X axis
</p>
<p>
and One for the Y Axis.
</p>
<br>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;

myData = [ { "n":  0, "p":  0 },{ "n":200, "p":200 },
           { "n":300, "p":300 },{ "n":400, "p":400 }];</code></pre>
	What has to fit into what?
</p>
<p>
We are going to do two linear scale transformations
</p>
<p>
The first thing we have to figure out is what is the domain and what is the range for each one.
</p>
<p>
That is, what data is on Line 1 and what data is on Line 2.
</p>
<p>
The way I think about it is asking myself the questions - what has to fit into what?
</p>
<p>
The first WHAT is the domain and the second WHAT is the range.
</p>
<p>
In this case, the myData values have to fit into the SVG Container.
</p>
<p>
So the myData values will provide the domain and the SVG Container will provide the range. 
</p>
<br>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;

myData = [ { "n":  0, "p":  0 },{ "n":200, "p":200 },
           { "n":300, "p":300 },{ "n":400, "p":400 }];</code></pre>
	What has to fit into what?
</p>
<p>
So myData values are the domain.
</p>
<p>
We also know that we need a linear scale function for the X axis and one for the Y axis.
</p>
<p>
In this data set, we have two variables - the N and the P.
</p>
<p>
The N will be the x axis values
</p>
<p>
The P will be the y axis values.
</p>
<br>
<p>
<pre><code class="javascript">myData = [ { "n":  0, "p":  0 },{ "n":200, "p":200 },
           { "n":300, "p":300 },{ "n":400, "p":400 }];

// minN

// maxN

// minP

// maxP</code></pre>
</p>
<p>
To get the domain numbers, we have to get the left most and right most points on the lines.
</p>
<p>
Which means we have to get the minimum N and the minimum P for the left most points
</p>
<p>
And we have to get the maximum N and the maximum P for the right most points.
</p>
<br>
<p>
<pre><code class="javascript">minN = d3.min(myData, function(d) { return d.n })

minP = d3.min(myData, function(d) { return d.p });

maxN = d3.max(myData, function(d) { return d.n });

maxN = d3.max(myData, function(d) { return d.p });</code></pre>
</p>
<p>
To get the min and max P and Ns, we can use the functions D3 provides to us for Arrays.
</p>
<p>
We make sure to use the accessor functions, since we are dealing with objects.
</p>
<br>
<p>
<pre><code class="javascript">domainN = d3.extent(myData, function(d) { return d.n });

domainP = d3.extent(myData, function(d) { return d.p });</code></pre>
</p>
<p>
Because the domain takes in an array with the low point and high point
</p>
<p>
We can actually just use the D3 Array Extent functionality to have it return the min and the max in a single array.
</p>
<p>
This saves us from creating 2 variables for the min and 2 variables for the max.
</p>
<br>
<p>
So far...
</p>
<p>
<pre><code class="javascript">domainN = d3.extent(myData, function(d) { return d.n });

domainP = d3.extent(myData, function(d) { return d.p });

var xLine = d3.scale.linear().domain(domainN);

var yLine = d3.scale.linear().domain(domainP);</code></pre>
</p>
<p>
Which means we can use the domainN and domainP variables right in the domain part of the linear scale function.
</p>
<p>
So far we have figured out what the domain of the line functions for the x and y axis will be.
</p>
<p>
Next we have to think about what the range will be.
</p>
<br>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;

myData = [ { "n":  0, "p":  0 },{ "n":200, "p":200 },  
           { "n":300, "p":300 },{ "n":400, "p":400 }];</code></pre>
</p>
<p>
What has to fit into what?
</p>
<p>
To figure out what the range will be, think about what we said before.
</p>
<p>
What has to fit into what?
</p>
<p>
The second what is the range.
</p>
<p>
Which in our case, is the 200 by 200 SVG container.
</p>
<br>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;

rangeSVGX = [0,200];

rangeSVGY = [0,200];</code></pre>
</p>
<p>
To figure out the range is easier.
</p>
<p>
Because we know that the SVG container is 200 units wide by 200 units tall,
</p>
<p>
The max SVG X and the max SVG Y are both 200.
</p>
<p>
Also, we know that the left top most point is the origin
</p>
<p>
Which means the min SVG X and the min SVG Y are both 0.
</p>
<p>
Because we know the range part of d3.scale.linear takes in an array of low and high values
</p>
<p>
We can just construct an array out of the min and max SVG X and Y coordinates. 
</p>
<br>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;

myData = [ { "n":  0, "p":  0 },{ "n":200, "p":200 },  
           { "n":300, "p":300 },{ "n":400, "p":400 }];

var xLineScale = d3.scale.linear().domain(domainN).range(rangeSVGX);

var yLineScale = d3.scale.linear().domain(domainP).range(rangeSVGY);</code></pre>
</p>
<p>
Using the data and the SVG Container,
</p>
<p>
we were able to create a linear scale function that will take in any of the myData points
</p>
<p>
and convert them so that they fit into the SVG Container.	
</p>
<br>
<p>
Let's take a look at an example in the JavaScript Console.
</p>
<br>
<p>
First we define the data source
</p>
<p>
<pre><code class="javascript">var myData = [ { "n":  0, "p":  0 },{ "n":200, "p":200 },  
               { "n":300, "p":300 },{ "n":400, "p":400 }];</code></pre>		
</p>
<br>
<p>
Next, because the SVG container is hardcoded, let's define the mins and maxs for the SVG
</p>
<p>
<pre><code class="javascript">var rangeSVGX = [0,200];

var rangeSVGY = [0,200];</code></pre>
</p>
<p>
These can normally be defined at the very top of the visualization since they will only be used once.
</p>
<p>
Sometimes, these aren't even defined as variables and people hardcode them into the actual D3 Scale Linear Functions
</p>
<p>
I prefer to leave all hardcoded numbers at the top in a variable section that is easy to find, see and change.
</p>
<br>
<p>
Next, let's define the domain for N and the domain for P based on the myData data source.
</p>
<p>
<pre><code class="javascript">var domainN = d3.extent(myData, function(d) { return d.n });

domainN;

var domainP = d3.extent(myData, function(d) { return d.p });

domainP;</code></pre>
</p>
<p>
As you can see, the extent function worked great and provided the right min and max numbers.
</p>
<br>
<p>
Next, let's define the d3 linear scale functions.
</p>
<p>
<pre><code class="javascript">var xLineScale = d3.scale.linear().domain(domainN).range(rangeSVGX);

var yLineScale = d3.scale.linear().domain(domainP).range(rangeSVGY);</code></pre>
</p>
<br>
<p>
Just to make sure, let's test the left most and right most points for each D3 Linear Scale Function
</p>
<p>
<pre><code class="javascript">[xLineScale(0),xLineScale(400)];

[yLineScale(0),yLineScale(400)];</code></pre>
</p>
<p>
As you can see, the linear scales are doing the right conversions.
</p>
<br>
<p>
And with these functions, we are now ready to work with the data.
	# We can now convert the original data numbers into numbers that will fit into the 200 unit by 200 unit SVG viewport.
</p>
<br>
<br>
<p>
<strong>
D3 Scales and SVG Data Points
</strong>
</p>
<br>
<p>
<pre><code class="javascript">d3.scale.linear().domain(...).range(...);</code></pre>
</p>
<p>
ℝ - Real Numbers
<br>
LINE 1: Domain
<br>
----------A---------B---------C---------
<br>
LINE 2: Range
<br>
----------D---------E---------F---------
</p>
<p>
Now, we will focus on what happens to the elements in the middle of the number line.
</p>
<p>
That is, the B and the E.
</p>
<p>
The D3 Scale Linear function takes the middle elements in line 1 and transforms them to middle elements in line 2.		
</p>
<br>
<p>
<pre><code class="javascript">myData = [ { "n":  0, "p":  0 },{ "n":200, "p":200 },
           { "n":300, "p":300 },{ "n":400, "p":400 }];</code></pre>
</p>
<p>
We have to convert the middle two JSON objects into something that will fit into the SVG Viewport.
</p>
<p>
We can put these data points into the Linear Scale Function to get the results.
</p>
<br>
<p>
</p>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;

myData = [ { "n":  0, "p":  0 },{ "n":200, "p":200 },  
           { "n":300, "p":300 },{ "n":400, "p":400 }];</code></pre>
</p>
<p>
The linear conversion from the domain to the range is to divide the number by 2.
</p>
<br>
<p>
</p>
<p>
<pre><code class="javascript">var xLineScale = d3.scale.linear().domain(...).range(...);

var yLineScale = d3.scale.linear().domain(...).range(...);

d3.selection.data(myData)).enter().append("circle")
    .attr("cx",function(d,i){ return xLineScale(d.n); })
    .attr("cy",function(d,i){ return yLineScale(d.p); })
    .attr("r","15");</code></pre>
</p>
<p>
What we can do now with these functions is to use them in the D3 Pattern.
</p>
<p>
When we are specifying Data in the attributes.
</p>
<p>
This does the linear scale conversion for us on the fly for each data element created.
</p>
<br>
<p>
Let's see how this works in the JavaScript console.
</p>
<br>
<p>
The linear conversion from the domain to the range is to divide the number by 2.
</p>
<p>
That is, we want to take something that has a maximum of 400 and convert it to something that has a maximum of 200.
</p>
<p>
<pre><code class="javascript">xLineScale(200);

yLineScale(200);</code></pre>
</p>
<p>
As you can see, it does what we thought - it returns 100, which is 200 divided by 2.
</p>
<br>
<p>
Now, let's add an SVG Element to the screen.
</p>
<p>
<pre><code class="javascript">var svgContainer = d3.select("body").append("svg").attr("width",200).attr("height",200);</code></pre>
</p>
<p>
BROWSER - Click on the HTML to expand the body element to see the SVG Container.
</p>
<p>
I hard code the width and height numbers to make it clear what we were doing.
</p>
<br>
<p>
Next, let's create the SVG Circle Elements Selection using the D3 pattern you should now recognize.
</p>
<p>
<pre><code class="javascript">var circleSelection = svgContainer.selectAll("circle").data(myData).enter().append("circle");</code></pre>
</p>
<p>
BROWSER - Click on the HTML to expand the SVG element to see the SVG DOM CIRCLE elements.
</p>
<p>
As you can see, we have created the 5 Circle Elements that will exist inside of the SVG Viewport
</p>
<br>
<p>
Finally, let's add in the attributes based on scaled data.
</p>
<p>
<pre><code class="javascript">var circleAttributes = circleSelection
    .attr("cx",function(d,i){ return xLineScale(d.n) })
    .attr("cy",function(d,i){ return yLineScale(d.p) })
    .attr("r","15");</code></pre>
</p>
<p>
As you can see, we were able to scale the data from the myData data source to be able to fit into the 
</p>
<p>
SVG Container 200 units wide by 200 units tall.
</p>
<p>
You can see that the D3 Linear Scale Functions were used inside of the anonymous function for each attribute.
</p>
<br>
<p>
Now that we have the circles, a very important thing to notice
</p>
<p>
<pre><code class="javascript">d3.selectAll("circle");</code></pre>
</p>
<p>
If we select all the circles and click down to see what data is attached to them.
</p>
<p>
BROWSER - OPEN Circle 4
</p>
<p>
BROWSER - Highlight n = 400 and p = 400.
</p>
<p>
You can see that the data attached to the circle is the actual original data.
</p>
<p>
Why would we want to save the original data?
</p>
<p>
Because this data can be used to construct text or call outs in the Data Visualization
</p>
<p>
It is very important to never change the initial data.
</p>
<p>
This is why the transformation is done in the attributes section.
</p>
<br>
<p>
And with that, we have covered the full basics of the D3 scales.
</p>
<p>
We covered what they are theoretically, what the domain is, what the range is, how we can think of them like a function
</p>
<p>
What values we can pass in and expect to get out and how we can actually use them in a Data Visualization.
</p>
        </div>
      </div>

</div>

<hr>
<h3 id="lesson25">SVG Group Element<h3>
<div>
    
    <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>The SVG Group Element is used to group SVG Elements together (much like a container)</li>
<li>There are two main reasons to use the SVG Group Element - for grouping SVG Elements and for doing transformations to the coordinate space the SVG Elements are in</li>
<li>Any transformation applied to the SVG Group Element is applied to all of the child elements contained inside</li>
<li>The transformations you can perform on the on the SVG Group Element are based on Linear Algebra</li>
<li>The SVG Group Element Translate transformation allows you to move all of the elements inside of the &lt;g&gt; ... &lt;/g&gt; a certain numbers of units in the X direction and a certain number of units in the Y direction</li>
<li>At a deeper level, what the SVG Group Element transform is doing is transforming the SVG Coordinate Space</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/fundamentals-of-svg">Fundamentals of SVG</a></li>
<li><a href="https://www.dashingd3js.com/lessons/adding-an-svg-element">Adding an SVG Element</a></li>
<li><a href="https://www.dashingd3js.com/lessons/creating-svg-elements-from-data">Creating SVG Elements from Data</a></li>
<li><a href="https://www.dashingd3js.com/lessons/using-the-svg-coordinate-space">Using the SVG Coordinate Space</a></li>
<li><a href="https://www.dashingd3js.com/lessons/dynamic-svg-coordinate-space">Dynamic SVG Coordinate Space</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-scales">D3 Scales</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-scales-part-two">D3 Scales Part Two</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-scales-part-three">D3 Scales Part Three</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            SVG Group Element
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
SVG Group Element
</strong>
</p>
<br>
<p>
<pre><code class="html">&lt;g&gt; &lt;/g&gt;</code></pre>
</p>
<p>
The SVG Group Element is used to group SVG Elements together.
</p>
<p>
You can think of the SVG Group as a container.
</p>
<p>
The g tag is the SVG Group Element.
</p>
<p>
Anything inside of the G tag is considered to be inside slash part of the G container.
</p>
<br>
<p>
<pre><code class="html">&lt;g&gt; &lt;/g&gt;</code></pre>
<p>
<ol>
<li>Grouping</li>
<li>Transformation</li>
</ol>
</p>
<p>
There are two main reasons to use the SVG Group Element
</p>
<p>
One - Grouping a set of SVG elements with the same attributes
</p>
<p>
Two - To define a new coordinate system for a set of SVG elements by applying a transformation to each coordinate specified in this set of SVG elements.
</p>
<p>
When you use a Group element, it can be for one reason or the other or both.
</p>
<br>
<p>
<pre><code class="html">&lt;g&gt;
    &lt;g&gt;
    &lt;/g&gt;
&lt;/g&gt;</code></pre>
</p>
<p>
You can also group elements within other group elements.
</p>
<p>
Any transformation applied to the SVG Group Element is applied to all of the child elements contained inside.
</p>
<br>
<p>
<pre><code class="html">&lt;svg width="200" height="200">
    &lt;g&gt;
        &lt;circle cx="20" cy="20" r="20" /&gt;
        &lt;circle cx="70" cy="70" r="20" /&gt;
    &lt;/g&gt;
    &lt;g&gt;
        &lt;rect x="110" y="110" height="30" width="30" /&gt;
        &lt;rect x="160" y="160" height="30" width="30" /&gt;
    &lt;/g&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
One way to organize a visualization is by grouping elements together that have the same attributes.
</p>
<p>
In this case, the circle SVG elements are grouped together.
</p>
<p>
And the rectangle SVG elements are grouped together.
</p>
<p>
This helps to keep things in order and makes it easy to understand when you are building visualizations.
</p>
<br>
<p>
<pre><code class="html">&lt;svg width="200" height="200">
    &lt;g fill="purple">
        &lt;circle cx="20" cy="20" r="20" /&gt;
        &lt;circle cx="70" cy="70" r="20" /&gt;
    &lt;/g&gt;
    &lt;g&gt;
        &lt;rect x="110" y="110" height="30" width="30" /&gt;
        &lt;rect x="160" y="160" height="30" width="30" /&gt;
    &lt;/g&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
Once elements are grouped together, you can apply attributes and values to the G element.
</p>
<p>
These attributes and values then filter down to the rest of the elements contained in the G element.
</p>
<p>
In this case, both SVG Circle Elements will have a fill of purple.
</p>
<p>
This is useful when defining the look and feel in CSS
</p>
<p>
Because we can apply an HTML class and/or HTML ID to a group element
</p>
<p>
which is then applied to all contained SVG Elements.
</p>
<br>
<br>
<p>
<strong>
SVG Group Element Transform
</strong>
</p>
<br>
<p>
&lt;g&gt; &lt;/g&gt;
<p>
<ol>
<li>Grouping</li>
<li>Transformation ** HIGHLIGHT GREEN **</li>
</ol>
</p>
<p>
The other thing you can do to a group element is to apply a set of transformations.
</p>
<p>
This transformation will transform every element inside of the G group.
</p>
<p>
The transformation does not affect elements outside of the specific G group to which the transformation was applied to.
</p>
<p>
This will become important later.
</p>
<br>
<p>
IMAGE FROM WEBSITE TRANSFORMATION
</p>
<p>
These transformations are based on Linear Algebra.
</p>
<p>
You can think of the transformations as being able to do the following:
</p>
<p>
- moving the group of elements up, down, left right or a combination.
</p>
<p>
- being able to skew the elements along the X axis
</p>
<p>
- being able to skew the elements along the Y axis
</p>
<p>
- being able to scale up or scale down the size elements
</p>
<p>
- being able to rotate the elements
</p>
<p>
- Or do a combination of some or all of the things.
</p>
<p>
You can even nest transformations inside of other transformations.
</p>
<br>
<p>
[ Image of "Translate" Transformation ]
</p>
<p>
The easiest transformation to understand is the Translate.
</p>
<p>
This transformation moves the all of the elements inside of the G element
</p>
<p>
A certain number of units of X and a certain number of units Y.
</p>
<br>
<p>
<pre><code class="html">&lt;svg width="200" height="200">
    &lt;g transform="translate(20,0)">
        &lt;circle cx="50" cy="50" r="20" /&gt;
    &lt;/g&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
In this simple example
</p>
<p>
We have an SVG Circle whose center point is at 50, 50 and has a radius of 20.
</p>
<p>
It is inside of an SVG Group Element.
</p>
<p>
The SVG Group element has a transformation applied to it.
</p>
<p>
This transformation is a translation.
</p>
<p>
The first number in the translation is 20.
</p>
<p>
This tells the G element to add 20 units to the x-coordinate of all the elements inside of the g element.
</p>
<p>
Which in the case of this circle, means add 20 units to the cx.
</p>
<p>
This will move the circle to the right.
</p>
<br>
<p>
<pre><code class="html">&lt;svg width="200" height="200">
    &lt;g transform="translate(0,-20)">
        &lt;circle cx="50" cy="50" r="20" /&gt;
    &lt;/g&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
In this simple example
</p>
<p>
We have an SVG Circle whose center point is at 50, 50 and has a radius of 20.
</p>
<p>
It is inside of an SVG Group Element.
</p>
<p>
The SVG Group element has a transformation applied to it.
</p>
<p>
This transformation is a translation.
</p>
<p>
The second number in the translation is -20.
</p>
<p>
This tells the G element to subtract 20 units from the y-coordinate of all the elements inside.
</p>
<p>
Which in the case of this circle, means subtract 20 units from the cy.
</p>
<p>
This will move the circle up.
</p>
<p>
It moves the circle up, because the SVG Coordinate space has the y-axis inverted.
</p>
<br>
<p>
<pre><code class="html">&lt;svg width="200" height="200">
    &lt;g transform="translate(20,-20)">
        &lt;circle cx="50" cy="50" r="20" /&gt;
    &lt;/g&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
We can even apply both X and Y coordinate transformations at the same time.
</p>
<p>
Which in the case of this circle, means adding 20 units to the cx.
</p>
<p>
And means subtracting 20 units from the cy.
</p>
<p>
It is worth noting that though the CX and CY of the circle are within the SVG Viewport, 
</p>
<p>
It is possible to a apply transforms that will move the circle out of the SVG Viewport
</p>
<p>
thus making the circle disappear.
</p>
<br>
<p>
<pre><code class="html">&lt;svg width="200" height="200">
    &lt;g transform="translate(10,10)">
        &lt;circle cx="40" cy="40" r="20" /&gt;
        &lt;circle cx="60" cy="60" r="20" /&gt;
    &lt;/g&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
If we are going to transform the units of the data
</p>
<p>
Why not just change the data to reflect the transformation we want.
</p>
<p>
Two reasons:
</p>
<p>
One - we want to keep the original data clean.
</p>
<p>
Two - by specifying the transform at the G level, we only have to set it once instead of doing it for every element.
</p>
<p>
We can let the SVG specification worry about that.
</p>
<p>
If we are not touching the data, what is really happening at a deeper level?
</p>
<br>
<br>
<p>
<strong>
SVG Coordinate Space Transformation
</strong>
</p>
<br>
<p>
[ Image of SVG Coordinate Space ]
</p>
<p>
At a deeper level, what the G element transform is doing is transforming the SVG Coordinate Space.
</p>
<p>
The Translate functionality can be thought of as moving the (0,0) point of the blue coordinate system to a (0,0) point in the purple coordinate system.
</p>
<p>
So everything inside of the G element is now operating inside of the new purple coordinate space
</p>
<br>
<p>
[ Image of JSFiddle ]
</p>
<p>
For this next part, we use a service called JSFiddle
</p>
<p>
JSFiddle allows us to type in html, JavaScript and CSS code in one screen and then see the output.
</p>
<p>
We will come back to this Service later as it also allows for the D3 library to be loaded inside of it.
</p>
<p>
Back to the G element and the SVG Coordinate Space Transformation.
</p>
<p>
In this case, both circles have the same cx, cy and radius.
</p>
<p>
The first circle, with id outside, has a cx of 40 and cy of 40.
</p>
<p>
This means that we move from the origin 40 units to the right and 40 units down.
</p>
<p>
We move down because the SVG Coordinate Space Y-Axis is inverted.
</p>
<p>
The second circle, with id inside, has a cx of 40 and cy of 40.
</p>
<p>
This means that we move from the origin 40 units to the right and 40 units down.
</p>
<p>
We move down because the SVG Coordinate Space Y-Axis is inverted.
</p>
<p>
The big difference in this picture is that the origin of the second circle is 10 units to the right and 10 units down from the origin of the first circle.
</p>
<br>
<p>
[ Image of New SVG Coordinate Space ]
</p>
<p>
<pre><code class="html">&lt;svg ...>
    &lt;circle ... /&gt;
    &lt;g transform="translate(10,10)">
        &lt;circle ... /&gt;
    &lt;/g&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
The first circle is on the blue coordinate system
</p>
<p>
While the second circle is on the purple coordinate system.
</p>
<p>
Everything in the SVG tags is based off of the blue coordinate system
</p>
<p>
While everything in the G tags is based off of the purple coordinate system.
</p>
<br>
<p>
[ Image of JSFiddle ]
</p>
<p>
In this example, the circles have different CX and CY points from each other.
</p>
<p>
However, because the SVG Group Element has been transformed by a translation 10 units to the right and 10 units down
</p>
<p>
We can see that the circles are sitting exactly on top of each other.
</p>
<p>
In fact, we can't even see the green circle.
</p>
<br>
<p>
[ Image of JSFiddle ]
</p>
<p>
In this example, the circles have different CX and CY points from each other.
</p>
<p>
However, because the SVG Group Element has been transformed by a translation negative 10 units to the right and negative 10 units down
</p>
<p>
We can see the circle sitting exactly on top of each other.
</p>
<br>
<p>
[ Image of D3 Margin Convention ]
</p>
<p>
The picture on the screen is a Mike Bostock block explain the margin convention he uses in D3.
</p>
<p>
Mike uses the translate transformation to move the graph to a new coordinate system.
</p>
<p>
The G element transformation shows up in all kinds of places when using SVG and D3.
</p>
<p>
In fact, of the 14 basic examples found on the D3js.org website, all 14 of them use the SVG Group Element and the SVG Group Element Transform at least once.
</p>
<p>
Some use it as many as 3 times in a single chart.
</p>
        </div>
      </div>

</div>☺


<hr>
<h3 id="lesson26">D3 and the SVG Group Element<h3>
    <div>
         <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>The SVG Group Element is used to group SVG Elements together (much like a container)</li>
<li>There are two main reasons to use the SVG Group Element - for grouping SVG Elements and for doing transformations to the coordinate space the SVG Elements are in</li>
<li>The most common SVG Group element transformation in D3 is the Translate Transformation</li>
<li>The SVG Group Element Translate transformation allows you to move all of the elements inside of the &lt;g&gt; ... &lt;/g&gt; a certain numbers of units in the X direction and a certain number of units in the Y direction</li>
<li>At a deeper level, what the SVG Group Element transform is doing is transforming the SVG Coordinate Space</li>
<li>You can append an SVG Group element just like any other HTML / SVG DOM element</li>
<li>If you create a selection whose parent node is the SVG Group Element, then every element you append to that selection will live within the SVG Group Element</li>
<li>Because you can define / update the attribute value pairs of DOM elements, you can use D3 to define and update the SVG Group Element transform translate attribute value pair</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/creating-svg-elements-from-data">Creating SVG Elements from Data</a></li>
<li><a href="https://www.dashingd3js.com/lessons/using-the-svg-coordinate-space">Using the SVG Coordinate Space</a></li>
<li><a href="https://www.dashingd3js.com/lessons/dynamic-svg-coordinate-space">Dynamic SVG Coordinate Space</a></li>
<li><a href="https://www.dashingd3js.com/lessons/svg-group-element">SVG Group Element</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 and the SVG Group Element
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
SVG Group Element Revisited
</strong>
</p>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;
    &lt;g fill="purple" transform="translate(10,20)"&gt;
        &lt;circle cx="20" cy="20" r="20" /&gt;
        &lt;circle cx="70" cy="70" r="20" /&gt;
    &lt;/g&gt;
    &lt;rect x="110" y="110" height="30" width="30" /&gt;
    &lt;rect x="160" y="160" height="30" width="30" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
The SVG Group Element is used to group SVG Elements together.
</p>
<p>
You can think of the SVG Group as a container.
</p>
<p>
The g tag is the SVG Group Element.
</p>
<p>
Anything inside of the G tag is considered to be inside slash part of the G container.
</p>
<br>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;
    &lt;g fill="purple" transform="translate(10,20)"&gt;
        &lt;circle cx="20" cy="20" r="20" /&gt;
        &lt;circle cx="70" cy="70" r="20" /&gt;
    &lt;/g&gt;
    &lt;rect x="110" y="110" height="30" width="30" /&gt;
    &lt;rect x="160" y="160" height="30" width="30" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
There are two main reasons to use the SVG Group Element
</p>
<p>
One - Grouping a set of SVG elements with the same attributes
</p>
<p>
Which then lets you apply styling like the FILL purple to all the group members.
</p>
<br>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;
    &lt;g fill="purple" transform="translate(10,20)"&gt;
        &lt;circle cx="20" cy="20" r="20" /&gt;
        &lt;circle cx="70" cy="70" r="20" /&gt;
    &lt;/g&gt;
    &lt;rect x="110" y="110" height="30" width="30" /&gt;
    &lt;rect x="160" y="160" height="30" width="30" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
The second main reason to use the SVG Group Element
</p>
<p>
Is for the transform capabilities.
</p>
<p>
You can do transformations like:
</p>
<p>
<ul>
<li>moving the group of elements up, down, left right or a combination</li>
<li>being able to skew the elements along the X axis</li>
<li>being able to skew the elements along the Y axis</li>
<li>being able to scale up or scale down the elements</li>
<li>being able to rotate the elements</li>
<li>Or do a combination of some or all of the things</li>
</ul>
</p>
<br>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;
    &lt;g fill="purple" transform="translate(10,20)"&gt;
        &lt;circle cx="20" cy="20" r="20" /&gt;
        &lt;circle cx="70" cy="70" r="20" /&gt;
    &lt;/g&gt;
    &lt;rect x="110" y="110" height="30" width="30" /&gt;
    &lt;rect x="160" y="160" height="30" width="30" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
The most common and basic transformation we talk about is the translate.
</p>
<p>
This transformation moves the all of the elements inside of the G element a certain number of units of X and a certain number of units Y.
</p>
<p>
The best way to think about this is to think of it as a Coordinate Space Transformation.
</p>
<br>
<p>
<pre><code class="html">&lt;svg ...&gt;
    &lt;circle ... /&gt;
    &lt;g transform="translate(10,10)"&gt;
        &lt;circle ... /&gt;
        &lt;circle ... /&gt;
    &lt;/g&gt;
    &lt;rect ... /&gt;
    &lt;rect ... /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
For instance,
</p>
<p>
Everything in the SVG tags is based off of the blue coordinate system
</p>
<p>
While everything in the G tags is based off of the purple coordinate system.
</p>
<p>
Thus, we have a new coordinate system exclusively for the elements inside of the SVG Group Tag.
</p>
<p>
The interior data doesn't change, just the origin point that we are using.
</p>
<br>
<p>
Alright, let's see what we can do with D3.
</p>
<br>
<br>
<p>
<strong>
Grouping SVG Elements with D3
</strong>
</p>
<br>
<p>
Appending an element to the HTML body should be straightforward for you now.
</p>
<p>
<pre><code class="javascript">d3.select("body").append("p");

d3.select("body").append("p");</code></pre>
</p>
<p>
BROWSER - Click into HTML section and expand
</p>
<p>
This appends two paragraph elements to the body.
</p>
<p>
The append command, appends the paragraph element as the last child element of the body element.
</p>
<p>
These two paragraphs come one right after the other because each time they are being inserted as the last child element.
</p>
<br>
<p>
To insert a paragraph inside of another paragraph, we have to write something like this.
</p>
<p>
<pre><code class="javascript">d3.select("body").append("p").append("p");</code></pre>
</p>
<p>
BROWSER - Click into HTML section and expand
</p>
<p>
This selects the body.
</p>
<p>
Then it appends a paragraph element as the last child element of the body selection.
</p>
<p>
Then it appends a paragraph element as the last child element of the first paragraph selection.
</p>
<p>
In this way, we are able to append one paragraph element inside of the other.
</p>
<br>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;
    &lt;g fill="purple" transform="translate(10,20)"&gt;
        &lt;circle cx="20" cy="20" r="20" /&gt;
        &lt;circle cx="70" cy="70" r="20" /&gt;
    &lt;/g&gt;
    &lt;rect x="110" y="110" height="30" width="30" /&gt;
    &lt;rect x="160" y="160" height="30" width="30" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
Looking again at the hand-coded example, a few things to point out
</p>
<p>
One - the Parent element is the SVG element
</p>
<p>
Two - Child elements to the SVG element are the G element and 2 rectangle elements.
</p>
<p>
Three - The G element and the 2 rectangle elements are Siblings
</p>
<p>
Four - The G element is the parent to 2 circle elements
</p>
<p>
Five - The Circle elements are siblings to each other.
</p>
<br>
<p>
[ Image of DOM Tree ]
</p>
<p>
If we look at it like a DOM Tree
</p>
<p>
Then we can see what elements are parents, which are siblings and which are children.
</p>
<p>
This is important to think about when we are inserting or appending elements using D3.
</p>
<p>
From this, we can see that we want to append the SVG Group Element to the body selection
</p>
<p>
And then we want to append the circle elements to the SVG Group Element selection
</p>
<p>
And finally, we want to append the rectangle elements to the SVG selection.
</p>
<br>
<p>
Let's get back to the JavaScript console to make this work.
</p>
<br>
<p>
We start by defining the SVG Selection
</p>
<p>
<pre><code class="javascript">var svgSelection = d3.select("body").append("svg").attr("width","200").attr("height","200");</code></pre>
</p>
<p>
BROWSER - Open the body to see the SVG
</p>
<p>
This gives us the svgSelection.
</p>
<p>
This selection is the parent element.
</p>
<br>
<p>
Next, we want to add the SVG Group Element.
</p>
<p>
Remembering that the SVG keyword for the group element is the letter G
</p>
<p>
We can append the SVG group element simply as follows:
</p>
<p>
<pre><code class="javascript">var groupSelection = svgSelection.append("g");</code></pre>
</p>
<p>
BROWSER - Open the body to see the G
</p>
<p>
We have added the SVG Group Element to the SVG Body.
</p>
<p>
The append command appended the G element as the last child element of the SVG parent element.
</p>
<p>
This is one of the beautiful things about D3.
</p>
<p>
Appending tags and attributes and their values is the same across the board.
</p>
<br>
<p>
Next, let's add the two circle elements.
</p>
<p>
Keep in mind that the relationship between the two elements is siblings and not parent/child
</p>
<p>
So we want to do two different append commands, not a chained append append command.
</p>
<p>
<pre><code class="javascript">groupSelection.append("circle").attr("cx",20).attr("cy",20).attr("r",20);

groupSelection.append("circle").attr("cx",70).attr("cy",70).attr("r",20);</code></pre>
</p>
<p>
BROWSER - Open the body to see the Circle Elements
</p>
<p>
The two circles now appear inside of the SVG Group Element
</p>
<p>
Also, because we did the append command twice, instead of chaining the command, the circles are sibling elements.
</p>
<br>
<p>
Next, let's add the rectangle elements.
</p>
<p>
Remember, the rectangle elements are siblings to the Group Element, so we have to add them to the svgSelection
</p>
<p>
Not the groupSelection.
</p>
<p>
Also - remember that the relationship between the two elements is siblings and not parent/child
</p>
<p>
So we want to do two different append commands, not a chained append append command.
</p>
<p>
<pre><code class="javascript">svgSelection.append("rect").attr("x",110).attr("y",110).attr("height",30).attr("width",30);

svgSelection.append("rect").attr("x",160).attr("y",160).attr("height",30).attr("width",30);</code></pre>
</p>
<p>
BROWSER - Highlight the rectangle elements
</p>
<p>
The two rectangles now appear inside of the SVG Element.
</p>
<p>
They show up as children to the SVG element and as siblings to the SVG Group Element.
</p>
<p>
Also - notice that they are below the SVG Group Element.
</p>
<p>
This is because the append commands inserts the elements as the last child element in the selection.
</p>
<p>
So each time we did the svgSelection.append command, it inserted the rectangles last.
</p>
<br>
<p>
We now have the circles, the rectangles and the circles are contained within the SVG Group Element.
</p>
<p>
Next, let's explore how to add attributes and values to the SVG Group Element.
</p>
<p>
It is done the exact same way we added attributes and values to any other element.
</p>
<p>
With the attribute chain syntax.
</p>
<p>
So we write the following:
</p>
<p>
<pre><code class="javascript">groupSelection.attr("fill","purple");</code></pre>
</p>
<p>
BROWSER - Highlight the rectangle elements
</p>
<p>
And now we have purple circles.
</p>
<p>
Notice that the fill purple attribute was added to the SVG Group element and not the circle elements.
</p>
<p>
This is what we were talking about when we covered how the SVG Group element attributes apply to all of it's children.
</p>
<br>
<p>
We showed with the JavaScript console how to add the the SVG Group Element with D3, 
</p>
<p>
As well as how to add attributes and their values to the SVG Group Element.
</p>
<br>
<p>
Next, let's take a look at how D3 works with the SVG Group Element to do transformations..
</p>
<br>
<br>
<p>
<strong>
D3 and SVG Group Element Transform
</strong>
</p>
<br>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;
    &lt;g fill="purple" transform="translate(10,20)"&gt;
        &lt;circle cx="20" cy="20" r="20" /&gt;
        &lt;circle cx="70" cy="70" r="20" /&gt;
    &lt;/g&gt;
    &lt;rect x="110" y="110" height="30" width="30" /&gt;
    &lt;rect x="160" y="160" height="30" width="30" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
The transform="translate(10,20)" is an attribute to the SVG Group Element.
</p>
<p>
Adding attributes to DOM elements is something we know how to do with D3.
</p>
<br>
<p>
</p>
<p>
<pre><code class="html">transform="translate(10,20)"</code></pre>
</p>
<p>
Before we go to the JavaScript console - one thing to notice.
</p>
<p>
The attribute name is transform - that is not a big issue.
</p>
<p>
The attribute value is "translate(10,20)".
</p>
<p>
This is and can cause a problem.
</p>
<p>
Why is this an issue?
</p>
<p>
Because the 10 and 20 here could be data that is generated elsewhere.
</p>
<p>
And we have to pass in the whole statement translate(10,20) as a string.
</p>
<p>
Which means two things
</p>
<p>
One - we have to hardcode the string
<br>
or
<br>
Two - we have to use JavaScript to construct the string.
</p>
<p>
Let's take a look at the JavaScript console for both ways.
</p>
<br>
<p>
We continue where we left off.
</p>
<p>
We have two purple circles inside of the SVG Group element and two black rectangles.
</p>
<p>
We want to apply the transform to the SVG Group Element.
</p>
<p>
Remembering that we already have an SVG Group Element selection, let's apply the translate attribute as a string.
</p>
<p>
<pre><code class="javascript">groupSelection.attr("transform","translate(10,20)");</code></pre>
</p>
<p>
The purple circles moved!
</p>
<p>
Look at the HTMl output, the transform attribute and value show up just as one would expect.
</p>
<p>
We just have to remember how to add attributes and their values to DOM elements using D3.
</p>
<br>
<p>
Let's change the translate values of the string by hand to see how it moves around.
</p>
<p>
<pre><code class="javascript">groupSelection.attr("transform","translate(10,80)");</code></pre>
</p>
<p>
The purple circles move down as the translate y coordinate went up.
</p>
<p>
Once again showing us that the SVG Coordinate Space y-axis is inverted.
</p>
<br>
<p>
Next, let's translate the purple circles out of the SVG Viewport
</p>
<p>
We know the SVG Viewport is 200 by 200, so let's make the Y value 280.
</p>
<p>
<pre><code class="javascript">groupSelection.attr("transform","translate(10,280)");</code></pre>
</p>
<p>
The purple circles move down as the translate y coordinate went up.
</p>
<p>
This time they moved out of the picture.
</p>
<p>
When we hover over the HTML SVG Group element, you can see the browser draw where the group element and the purple circles would be if the SVG viewport were big enough.
</p>
<br>
<p>
Next, let's bring the group element and purple circles back to where they started, with the translate(10,20)
</p>
<p>
<pre><code class="javascript">groupSelection.attr("transform","translate(10,20)");</code></pre>
</p>
<p>
BROWSER - Hover over the SVG Element
</p>
<p>
Notice that when we are changing the attribute of the groupSelection it is overwriting the values.
</p>
<p>
It is not appending more attributes.
</p>
<br>
<p>
Let's change the translate values of the string by hand one more time to see how it behaves when we change the x coordinate.
</p>
<p>
<pre><code class="javascript">groupSelection.attr("transform","translate(80,20)");</code></pre>
</p>
<p>
The purple circles move to the right as the translate x coordinate went up.
</p>
<p>
This works as expected.
</p>
<br>
<p>
Let's look at string concatenation quickly before we go over how to construct the translate string.
</p>
<br>
<p>
Basic JavaScript String Concatenation
</p>
<p>
<pre><code class="javascript">var a = 'Hello world!';

var num = 12;

var myString = a + num;

// myString returns 'Hello world!12'</code></pre>

</p>
<p>
JavaScript is very relaxed about the difference between strings and numbers.
</p>
<p>
Some programming languages require you to state if a variable is a number or a string before doing anything else with it.
</p>
<p>
Not so in JavaScript.
</p>
<p>
You can even add up numbers and strings.
</p>
<p>
a is a string
</p>
<p>
num is number
</p>
<p>
JavaScript solves the problem by assuming 12 is also a string.
</p>
<p>
So the var myString = a + num doesn't break and concatenates the string and number together to give you the result.
</p>
<p>
We can use this to construct the translate string.
</p>
<br>
<p>
Let's go back to the JavaScript Console
</p>
<br>
<p>
We continue where we left off.
</p>
<br>
<p>
First, let's test whether we can indeed add a string to a number.
</p>
<p>
<pre><code class="javascript">var a = 'Hello world!';

typeof(a); // returns "string"

var num = 12;

typeof(num); // returns "number"

var myString = a + num;

myString; // returns "Hello world!12"

typeof(myString); // returns "string"</code></pre>
</p>
<p>
We define a as a string
</p>
<p>
The typeof command tells us a is a string
</p>
<p>
We define num as the number twelve
</p>
<p>
the typeof command tells us num is a number
</p>
<p>
We define myString as a plus num
</p>
<p>
the typeof command tells us that myString is a string.
</p>
<p>
So it worked - we can add a number and a string easily in JavaScript.
</p>
<br>
<p>
Going back to constructing the value string for the transform attribute.
</p>
<p>
<pre><code class="javascript">var whatWeWant = "translate(10,20)";

whatWeWant;</code></pre>
</p>
<p>
Let's define what we want so that we can check for equality.
</p>
<br>
<p>
Next, let's construct the first part of the string
</p>
<p>
<pre><code class="javascript">var valueString = "translate("

valueString;</code></pre>
</p>
<p>
So far so good.
</p>
<br>
<p>
Now, let's add in the number 10
</p>
<p>
<pre><code class="javascript">var valueString = "translate(" + 10;

valueString;</code></pre>
</p>
<p>
It constructed the string for us.
</p>
<br>
<p>
Now that we see how it works, let's construct the rest of the string.
</p>
<p>
<pre><code class="javascript">var valueString = "translate(" + 10 + "," + 20 + ")";

valueString;

whatWeWant === valueString;</code></pre>
</p>
<p>
We construct the string and check to see if it looks right.
</p>
<p>
Then we do a triple equals test to see if the two values are the same.
</p>
<p>
They are.
</p>
<br>
<p>
The last translate we did, left the purple circles with a transform translate of 80,20
</p>
<p>
Let's put the value string into the d3 attribute transform to get it back to translate 10,20.
</p>
<p>
<pre><code class="javascript">groupSelection.attr("transform",valueString);</code></pre>
</p>
<p>
And it worked.
</p>
<p>
You can see that the SVG Group Element transform attribute value is now translate(10,20).
</p>
<br>
<p>
We can even go so far as to put the string construction into the D3 attribute function
</p>
<p>
This time, let's make the x coordinate translate 50 and the y coordinate translate 50
</p>
<p>
<pre><code class="javascript">groupSelection.attr("transform","translate(" + 50 + "," + 50 + ")");</code></pre>
</p>
<p>
It works exactly the same way.
</p>
<br>
<p>
[ Image of Group Element Transform ]
</p>
<p>
As a parting screenshot, here is the SVG Transform Translate from the D3js.org website for the basic bar chart example.
</p>
<p>
You can see that the translate value string is constructed right in the D3 attribute operator.
</p>
<br>
<p>
And those are the basics of how to manipulate the SVG Group Element with D3.
</p>
        </div>
      </div>

</div>


<hr>
<h3 id="lesson27">SVG Text Elements<h3>
    <div>
        <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>One of the most important parts of Data Visualization is text labels and axis</li>
<li>SVG provides a keyword for defining a graphics element consistent of text</li>
<li>The SVG Text Element phase attributes and properties to indicate things like the font specification, writing directions, and attributes for how to exactly render and paint a character</li>
<li>Because SVG Text Elements are rendered using the same rendering methods as the rest of the SVG Graphical Elements, the same coordinate system, transformation, and etc. apply</li>
<li>For the SVG Text Element, you need to provide an X coordinate, a Y coordinate, and the text that you want written in the SVG Viewport</li>
<li>Because SVG Text Elements are DOM elements, you can use D3 to append SVG Text tags as well as define and update their attribute value pairs</li>
<li>Because you can use D3 to append and define the SVG Text tags, it means you can also do it in a data-driven way</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/creating-svg-elements-from-data">Creating SVG Elements from Data</a></li>
<li><a href="https://www.dashingd3js.com/lessons/using-the-svg-coordinate-space">Using the SVG Coordinate Space</a></li>
<li><a href="https://www.dashingd3js.com/lessons/dynamic-svg-coordinate-space">Dynamic SVG Coordinate Space</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            SVG Text Elements
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
SVG Revisited
</strong>
</p>
<br>
<p>
</p>
<p>
<pre><code class="html">&lt;svg&gt; ... &lt;/svg&gt;</code></pre>
</p>
<p>
SVG is a Vector Based Graphics system
</p>
<p>
SVG is a family of specifications for creating vector graphics.
</p>
<p>
Since Vector Graphics are not created out of pixels, they can be scaled up to larger or smaller sizes without losing image quality.
</p>
<p>
The SVG system creates DOM objects for each graphical element.
</p>
<p>
Things within the SVG Viewport dimension's are visible
</p>
<p>
Things inside the SVG tags though outside the Viewport dimensions are not visible.
</p>
<br>
<p>
</p>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;
    &lt;g&gt;
        &lt;circle cx="20" cy="20" r="20" /&gt;
        &lt;circle cx="70" cy="70" r="20" /&gt;
    &lt;/g&gt;
    &lt;g&gt;
        &lt;rect x="110" y="110" height="30" width="30" /&gt;
        &lt;rect x="160" y="160" height="30" width="30" /&gt;
    &lt;/g&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
SVG images and their behaviors are defined in XML text files.
</p>
<p>
Since the DOM includes XML as part of the DOM specification, we can use the DOM to access and update the structure, content and style of SVG Images.
</p>
<p>
This means that SVG elements can be styled using CSS just like HTML.
</p>
<p>
So far we have covered the basic shapes that can be made in SVG.
</p>
<p>
One very important part of Data Visualizations we have not covered yet is text.
</p>
<br>
<br>
<p>
<strong>
SVG Text Elements
</strong>
</p>
<br>
<p>
[ Image: Text a Graphics Elements ]
</p>
<p>
Typography is the art and technique of arranging type in order to make language visible.
</p>
<p>
The arrangement of type involves the selection of typefaces, point size, line length, line spacing, adjusting the spaces between groups of letters and adjusting the space between pairs of letters.
</p>
<p>
Additionally - color, readability and legibility are important parts of Typography.
</p>
<br>
<p>
[ Image: Scatterplot ]
</p>
<p>
One of the most important parts of Data Visualization is text labels and axis.
</p>
<p>
Text labels and axis help to set the ground floor of understanding.
</p>
<p>
It tells us about scale, about relative scale, and it lets us figure out the space we are operating in.
</p>
<br>
<p>
[ Image: Graphic Without A Scale]
</p>
<p>
After all, if the graph or visualization is missing text, then it is very hard to read.
</p>
<p>
This chart could be a great one if we were talking about costs of a business going down.
</p>
<p>
This chart could be a terrible one if we were talking about the number of kids who receive adequate nutrition.
</p>
<p>
This chart could be misleading in that amplitude of the Y axis could be statistically insignificant.
</p>
<p>
This chart could be misleading in that the lowest X and highest X could be millions of years apart where as we only care about hourly increments.
</p>
<p>
This chart could also be completely wrong if we had asked for a chart about the unemployment rate and this chart was about the number of clowns over the last century.
</p>
<p>
Without text on the graph or chart, we are operating blind.
</p>
<p>
Which, as you can imagine, is not the goal of data visualization.
</p>
<br>
<p>
</p>
<p>
<pre><code class="html">&lt;svg&gt;
    &lt;text ... &gt; ... &lt;text&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
SVG provides a keyword for defining a graphics element consisting of text.
</p>
<p>
The SVG Text Element has attributes and properties that indicate things like the font specification, writing direction, and attributes for how to exactly render and paint the characters.
</p>
<p>
Because SVG Text Elements are rendered using the same rendering methods as the rest of the SVG Graphical Elements, the same coordinate system, transformations and etc apply.
</p>
<br>
<p>
</p>
<p>
<pre><code class="html">&lt;svg&gt;
    &lt;text x="50" y="50" font-family="sans-serif" font-size="12px" >&lt;text&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
The SVG Text Element renders the first character at the initial current text position.
</p>
<p>
This position is defined by the 'x' and 'y' attributes of the SVG Text Element.
</p>
<p>
This tells us that the text will start to be drawn at point (50, 50), with the font-family sans-serif and with the font-size of "12px".
</p>
<p>
We can even apply a rotation to each glyph of the text.
</p>
<br>
<br>
<p>
<strong>
Adding SVG Text Elements
</strong>
</p>
<br>
<p>
</p>
<p>
<pre><code class="html">&lt;svg&gt;
    &lt;circle cx="20" cy="20" r="20" /&gt;
    &lt;text x="50" y="50">Circle&lt;text&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
Looking at the example again, let's cover how to build the text element.
</p>
<p>
We compare it with building a circle, something we already know how to do.
</p>
<p>
First, we need to use the keyword "TEXT", just like the circle uses the keyword "CIRCLE"
</p>
<p>
Next, we need to define the x and y coordinates of where the graphics element is drawn from.
</p>
<p>
In the case of the circle, it is the center point.
</p>
<p>
In the case of the text, it is to the bottom left corner.
</p>
<p>
The radius tells us how far the circle goes out.
</p>
<p>
For the text, we do not define this.
</p>
<p>
It goes out as far as the actual words between the text tags go.
</p>
<br>
<p>
</p>
<p>
<pre><code class="html">&lt;svg&gt;
    &lt;circle cx="20" cy="20" r="20" /&gt;
    &lt;text x="50" y="50">Circle&lt;text&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
One important thing to notice is that the text keyword has an opening and closing tag.
</p>
<p>
The text inside of the opening and closing text tags is the actual text that is written out in the SVG image.
</p>
<p>
This is important to key in mind because so far we have just added attributes and values to the keyword and haven't specified anything inside of the opening and closing tags.
</p>
<br>
<p>
</p>
<p>
<pre><code class="html">&lt;svg&gt;
    &lt;circle cx="20" cy="20" r="20" fill="purple"/>
    &lt;text x="50" y="50" font-family="sans-serif" font-size="12px" fill="red">Circle&lt;text&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
Just like we can specify extra attributes to the SVG Circle like the fill color,
</p>
<p>
We can specify extra attributes to the SVG Text.
</p>
<p>
The ones we focus on are the font-family, the font-size as well as the Fill.
</p>
<p>
This tells us that the text will start to be drawn at the point (50, 50), with the font-family sans-serif, with the font-size of "12px", and the fill color of "red".
</p>
<br>
<p>
</p>
<p>
<pre><code class="html">&lt;!DOCTYPE html>
&lt;html>
    &lt;head&gt;&lt;script type="text/javascript" src="d3.v3.min.js"&gt;&lt;/script>&lt;/head&gt;
    &lt;body&gt;
        &lt;svg&gt;
            &lt;circle cx="20" cy="20" r="20" fill="purple"/&gt;
            &lt;text x="50" y="50" font-family="sans-serif" font-size="12px" fill="red"&gt;Circle&lt;text&gt;
        &lt;/svg&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
</p>
<p>
We can thus write an HTML file as follows and the browser will understand it correctly.
</p>
<p>
When we load this in the browser, we get the following
</p>
<br>
<p>
[ Image: A Purple Circle With Red Text ]
</p>
<p>
The purple circle shows up as we would now expect.
</p>
<p>
The red text shows up on the screen and is visible in the developer's tools elements section.
</p>
<p>
In this way we can add text to our data visualizations to help explain and improve readability and legibility.
</p>
<br>
<p>
</p>
<p>
<pre><code class="html">&lt;svg&gt;
    &lt;circle cx="20" cy="20" r="20" fill="purple" /&gt;
    &lt;text x="50" y="50" font-family="sans-serif" font-size="12px" fill="red">Circle&lt;text&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
The great thing about SVG is that all of the keyword elements are constructed the same.
</p>
<p>
There are attributes and their values.
</p>
<p>
As you can imagine, this makes it familiar, easy and flexible when we go to add text using D3.
</p>
<br>
<br>
<p>
<strong>
D3 and SVG Text Elements
</strong>
</p>
<br>
<p>
</p>
<p>
<pre><code class="javascript">d3.selection.append("circle").attr("cx",20).attr("cy",20).attr("r",20).style("fill","purple");</code></pre>
</p>
<p>
For SVG Basic shapes, we already know how to add attributes using D3.
</p>
<p>
Adding attributes and their values to make SVG Text will be the same using D3.
</p>
<br>
<p>
</p>
<p>
<pre><code class="html">&lt;svg&gt;
    &lt;circle cx="20" cy="20" r="20" fill="purple"/>
    &lt;text x="50" y="50" font-family="sans-serif" font-size="12px" fill="red">circle&lt;text&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
The one thing we need to cover is how to insert the text into the opening and closing tags.
</p>
<p>
We need to tell D3 that we want to put the word circle into the SVG Text example on the screen.
</p>
<br>
<p>
</p>
<p>
<pre><code class="javascript">d3.selection.text([value])</code></pre>
</p>
<p>
This is the D3 Text Operator
</p>
<p>
If a value is specified, then it sets the text content of all the selected elements to the specified value.
</p>
<p>
If the value is constant, then all the elements are given the same text content.
</p>
<p>
If the value is a function, then the function is evaluated for each element in order.
</p>
<br>
<p>
</p>
<p>
<pre><code class="html">&lt;svg&gt;
    &lt;circle cx="20" cy="20" r="20" fill="purple" /&gt;
    &lt;text x="50" y="50" font-family="sans-serif" font-size="12px" fill="red">circle&lt;text&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
Using the D3 Text Operator we can set the text of the SVG Text.
</p>
<p>
Because the D3 text operator allows for constant values as well as functions that return a value
</p>
<p>
we can dynamically set the text content of the SVG Text.
</p>
<br>
<p>
Let's take a look at the JavaScript Console to see how this works.
</p>
<br>
<p>
We start with what we already know - how to create SVG circles using D3 and data.
</p>
<p>
<pre><code class="javascript">var svgContainer = d3.select("body").append("svg").attr("width","200").attr("height","200");

svgContainer.append("circle").attr("cx",20).attr("cy",20).attr("r",20).style("fill","purple");</code></pre>
</p>
<p>
BROWSER - Click in Developer's Tools Elements Section to open up the Body & SVG
</p>
<p>
First we create the SVG Container viewport.
</p>
<p>
Then we append a circle to the SVG Container
</p>
<p>
Then we add attributes to the SVG Circle.
</p>
<p>
In the circle's case we add in the cx, cy, radius and fill to match the example we did above.
</p>
<p>
The purple circle shows up as expected.
</p>
<br>
<p>
Next, let's start with baby steps, adding the text keyword to the SVG Container.
</p>
<p>
<pre><code class="javascript">var svgText = svgContainer.append("text");</code></pre>
</p>
<p>
Given how we added the circle to the SVG Container, we can append the text keyword to the svgContainer.
</p>
<p>
BROWSER - Click on the SVG keyword text in the elements section of the chrome web developer tools
</p>
<p>
The text keyword shows up as the last child element of the SVG Container because we used append.
</p>
<p>
Notice that the opening tag and closing tag of the Text SVG Element are added for us.
</p>
<br>
<p>
Next, let's add the x and y coordinates.
</p>
<p>
<pre><code class="javascript">svgText.attr("x",50).attr("y",50);</code></pre>
</p>
<p>
This tells the browser that the text will start at the point 50,50.
</p>
<p>
The text then expands to the right.
</p>
<br>
<p>
Next, using the D3 text operator, let's add the word circle as a string
</p>
<p>
<pre><code class="javascript">svgText.text("circle");</code></pre>
</p>
<p>
BROWSER - Click in Developer's Tools Elements Section to open up the Body & SVG
</p>
<p>
The word circle now appears on the screen
</p>
<p>
In the elements section of the developer tools, you can see that the word was added between the tags.
</p>
<p>
Though it was added with double quotations, the quotations do not show up in the SVG Container.
</p>
<br>
<p>
We can run the same command again with a different word now.
</p>
<p>
<pre><code class="javascript">svgText.text("data");</code></pre>
</p>
<p>
The word data now appears on the screen
</p>
<p>
In the elements section of the developer tools, you can see that the word was added between tags.
</p>
<p>
The D3 text command adds in the new text and replaces the old text.
</p>
<br>
<p>
Let's change it back to the word circle and make the X and Y points 20,20.
</p>
<p>
<pre><code class="javascript">svgText.attr("x",20).attr("y",20).text("circle");</code></pre>
</p>
<p>
It is now back to being the word circle.
</p>
<p>
And the point where the text starts is the center point of the circle.
</p>
<p>
You can see that the word "Circle" starts at the center point and moves to the right
</p>
<p>
One other thing to note is that the characters are drawn up in our regular coordinate space, not the SVG Coordinate space.
</p>
<br>
<p>
Let's move it back to the X and Y points 50, 50, so we have a clear view of the text.
</p>
<p>
<pre><code class="javascript">svgText.attr("x",50).attr("y",50);</code></pre>
</p>
<p>
We can see the SVG Text word - circle, clearly.
</p>
<br>
<p>
Now, let's add in the font and font-size.
</p>
<p>
<pre><code class="javascript">svgText.attr("font-family","sans-serif").attr("font-size",12);</code></pre>
</p>
<p>
You can see that the font style changed as did the font-size.
</p>
<p>
One important thing to keep in mind when using font-families is that if the user does not have that font on their computer, the browser will try to find an equivalent font.
</p>
<p>
For this reason, it's best to stick to generic font-family names, like the "sans-serif" in this example.
</p>
<br>
<p>
The other thing to notice is that for the font-size we did not specify the units, D3 added the px text for us.
</p>
<p>
We can add in the px ourselves if we want.
</p>
<p>
<pre><code class="javascript">svgText.attr("font-size","30px");</code></pre>
</p>
<p>
It works the same way.
</p>
<br>
<p>
Next, let's take a look at how we can use data to create SVG Basic Shapes and then to add SVG Text labels to those SVG Basic shapes based on the data.
</p>
<br>
<br>
<p>
<strong>
D3, Data and SVG Text
</strong>
</p>
<br>
<p>
</p>
<p>
<pre><code class="javascript">dataSet = [{"name":"Shanghai"        , "population":18, "rank": 1},
           {"name":"Guangzhou"       , "population":11, "rank":10},
           {"name":"Dongguan"        , "population": 8, "rank":20},
           {"name":"Cairo"           , "population": 7, "rank":30},
           {"name":"Saint Petersburg", "population": 5, "rank":40},
           {"name":"New Taipei"      , "population": 4, "rank":50}];</code></pre>
</p>
<br>
<p>
We define a data set that contains text and numbers.
</p>
<p>
This data set is based on the top 50 largest cities in the world and their population as measured in Millions according to Wikipedia.
</p>
<p>
For now, we design a super basic data visualization.
</p>
<p>
We will create circles where the radius is based on the population in millions.
</p>
<p>
Then we will add the name of the city next to the circle.
</p>
<p>
We position the circles on the graph based on their index number.
</p>
<br>
<p>
To the JavaScript Console
</p>
<br>
<p>
First, we define the data set:
</p>
<p>
<pre><code class="javascript">dataSet = [{"name":"Shanghai"        , "population":18, "rank": 1},
           {"name":"Guangzhou"       , "population":11, "rank":10},
           {"name":"Dongguan"        , "population": 8, "rank":20},
           {"name":"Cairo"           , "population": 7, "rank":30},
           {"name":"Saint Petersburg", "population": 5, "rank":40},
           {"name":"New Taipei"      , "population": 4, "rank":50}];</code></pre>
</p>
<p>
We will use this to bind each JSON object to each circle element.
</p>
<br>
<p>
First, we start by adding an SVG Container
</p>
<p>
<pre><code class="javascript">var svgContainer = d3.select("body").append("svg").attr("width","200").attr("height","200");</code></pre>
</p>
<p>
BROWSER - Expand body in elements section
</p>
<p>
This will contain all of the elements of the data visualization
</p>
<br>
<p>
Next, let's add circles to the svg container and attach the data.
</p>
<p>
<pre><code class="javascript">var circles = svgContainer.selectAll("circle").data(dataSet).enter().append("circle");</code></pre>
</p>
<p>
BROWSER - Expand the SVG in elements section
</p>
<p>
The circles now appear
</p>
<br>
<p>
We check to make sure the each JSON object was bound to each circle
</p>
<p>
<pre><code class="javascript">circles;</code></pre>
</p>
<p>
BROWSER - Click into the array, then into the first circle, then into the data attribute and highlight the information
</p>
<p>
The JavaScript object was bound to each circle.
</p>
<p>
BROWSER - Close all of the arrays.
</p>
<p>
Next, let's use the object to create the circle attributes.
</p>
<br>
<p>
We position each circle according to it's index, remembering that it is zero-indexed.
</p>
<p>
The radius of each circle is define by the population.
</p>
<p>
<pre><code class="javascript">circles.attr("cx", function(d,i) { return (i+1)*25; })
    .attr("cy", function(d,i) { return (i+1)*25; })
    .attr("r" , function(d,i) { return d.population });</code></pre>
</p>
<p>
The circles now appear in the SVG Viewport.
</p>
<p>
The circles decrease in size as they go from left to right and from up to down.
</p>
<p>
This is expected and it shows what we want - the relative size of the cities.
</p>
<p>
However, as we covered earlier, without looking directly at the data, it is hard to know which circle pertains to which city.
</p>
<br>
<p>
Let's add SVG Text labels to each circle based on the data.
</p>
<p>
<pre><code class="javascript">var circleLabels = svgContainer.selectAll("text").data(dataSet).enter().append("text");</code></pre>
</p>
<p>
We use the same D3 pattern as before.
</p>
<p>
Except this time instead of adding SVG Circle elements, we are adding SVG Text elements
</p>
<p>
We bind the data set in the same way
</p>
<p>
Each SVG Text Element gets it's own JSON data object
</p>
<br>
<p>
We check to make sure the each JSON object was bound to each text element
</p>
<p>
<pre><code class="javascript">circleLabels;</code></pre>
</p>
<p>
BROWSER - Click into the array, then into the first text, then into the data attribute and highlight the information
</p>
<p>
The JavaScript object was bound to each text element.
</p>
<p>
BROWSER - Close all of the arrays.
</p>
<p>
Next, let's use the object to create the text attributes.
</p>
<br>
<p>
For the text elements, we first have to define where they live
</p>
<p>
This is defined the same way as the circles, according to the data index
</p>
<p>
<pre><code class="javascript">circleLabels.attr("x", function(d,i) { return (i+1)*25; })
    .attr("y", function(d,i) { return (i+1)*25; });</code></pre>
</p>
<p>
This has given each text element the attribute and value to match the circle.
</p>
<br>
<p>
Now we add the actual text based on the data's city name.
</p>
<p>
Instead of a hard-coded value, we use an anonymous function to get the name from the data property
</p>
<p>
<pre><code class="javascript">circleLabels.text(function(d,i) { return d.name; });</code></pre>
</p>
<p>
The name of each city appears on top of each circle.
</p>
<p>
Which solves the issue of knowing which circle pertains to which city.
</p>
<p>
However, the text is black and the circle is black so it's hard to read.
</p>
<br>
<p>
Let's change the style of the text elements.
</p>
<p>
<pre><code class="javascript">circleLabels.style("fill","red");</code></pre>
</p>
<p>
The red labels is now fully visible.
</p>
<p>
Well - other than the fact that the text on the last two countries runs out of the SVG Viewport dimensions and are thus partially hidden.
</p>
<p>
We will come back to that later.
</p>
<br>
<p>
For now, let's change the text of the circle Labels to be the rank.
</p>
<p>
Because the D3 text operator replaces the text, we can just call the text operator again with a function that returns the rank instead of the name of the city.
</p>
<p>
<pre><code class="javascript">circleLabels.text(function(d,i) { return d.rank; });</code></pre>
</p>
<p>
The rank of each city is now visible and because the font is still red, we can read it.
</p>
<p>
However, without specifying what the number next to each circle means, we have no way of knowing whether it's a population or rank.
</p>
<br>
<p>
Because we use a function to set the text, we can concatenate a string and a number to set the text to a better explanation
</p>
<p>
<pre><code class="javascript">circleLabels.text(function(d,i) { return "rank: " + d.rank; });</code></pre>
</p>
<br>
<p>
And there you have it, we used data to create SVG Basic Shapes and then to added SVG Text labels to those SVG Basic shapes based on the data.
</p>
        </div>
      </div>

</div>☺
    

<hr>
<h3 id="lesson28">Margin Convention<h3>
    <div>
    
    <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>Things within the SVG Viewport dimensions are visible</li>
<li>Things inside the SVG tags though outside the SVG Viewport dimensions are not visisble, though they still exist as DOM elements</li>
<li>The SVG Coordinate Space has the y-axis inverted when compared to the Cartesian Coordinate Space</li>
<li>The SVG Group Element has two roles a) a container of SVG elements and b) an SVG element that can define a new coordinate system for the set of its child SVG elements</li>
<li>The D3 Margin Convention is a heavily used convention that allows SVG Graphics to have a border of space around the data visualization so that everything is visible and no elements are cut off</li>
<li>The D3 Margin Convention defines a margin.top, margin.right, margin.bottom, and margin.left through the use of a JavaScript Object Literal</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/using-the-svg-coordinate-space">Using the SVG Coordinate Space</a></li>
<li><a href="https://www.dashingd3js.com/lessons/dynamic-svg-coordinate-space">Dynamic SVG Coordinate Space</a></li>
<li><a href="https://www.dashingd3js.com/lessons/svg-group-element">SVG Group Element</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-and-the-svg-group-element">D3 and the SVG Group Element</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            Margin Convention
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
SVG Viewport Revisited
</strong>
</p>
<br>
<p>
</p>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;
    ...
&lt;/svg&gt;</code></pre>
</p>
<p>
Things within the SVG Viewport dimension's are visible
</p>
<p>
Things inside the SVG tags though outside the Viewport dimensions are not visible.
</p>
<p>
Things inside the SVG tags though outside the Viewport dimensions still exist, they are just not visible.
</p>
<br>
<p>
[ Image: SVG Coordinate Axis ]
</p>
<p>
SVG Coordinate Space works in the same way that mathematical graph coordinate space works except for two important features:
</p>
<p>
GREEN ARROW POINTING TO THE ORIGIN POINT
</p>
<p>
One - SVG Coordinate space has it's origin point (0,0) at the top left
</p>
<p>
Two - SVG Coordinate space has the Y coordinates growing from top to bottom.
</p>
<br>
<p>
[ Image: X & Y SVG Axis With A Green Circle]
</p>
<p>
Text on Screen (25,25)
</p>
<p>
Which means when we are given the coordinates of (25,25)
</p>
<p>
We go 25 units from the left to the right
</p>
<p>
and
</p>
<p>
We go 25 units from the top to the bottom.
</p>
<br>
<p>
</p>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;

&lt;svg width="400" height="600"&gt;

&lt;svg width="100" height="100"&gt;

&lt;svg width="960" height="500"&gt;</code></pre>
</p>
<p>
The width and height that we choose for the SVG Coordinate Space are completely under our control.
</p>
<p>
We can make it as big or small as we want.
</p>
<p>
There are two ways to think about how to choose the dimensions of the SVG Viewport.
</p>
<p>
One - is to let the data tell you how big to make it.
</p>
<p>
Two - is to choose hard numbers and to scale the data up or down accordingly.
</p>
<p>
Way number two is the preferred way to choose the dimensions of the SVG Viewport.
</p>
<br>
<p>
[ Image: Cities By Size Data Visualization ]
</p>
<p>
Looking at this Data Visualization, you can see that the text on the screen ran out of room in the Viewport.
</p>
<p>
This made the text partially hidden.
</p>
<p>
One way to fix the issue is to add margins to the graphics in case there is a run over.
</p>
<p>
Which means that we make the SVG Viewport and then we make a smaller internal drawing container where everything will be drawn.
</p>
<p>
The margins specify the space between the Original SVG Container and where the smaller internal drawing container lives.
</p>
<p>
We can define the margins all at once as part of a JavaScript object.
</p>
<p>
For the inner drawing container, we can group everything inside of it in an SVG Group Element.
</p>
<br>
<br>
<p>
<strong>
D3 Group Element Revisited
</strong>
</p>
<br>
<p>
</p>
<p>
<pre><code class="html">&lt;g&gt; &lt;/g&gt;</code></pre>
</p>
<p>
The SVG Group Element is used to group SVG Elements together.
</p>
<p>
You can think of the SVG Group as a container.
</p>
<p>
The g tag is the SVG Group Element.
</p>
<p>
Anything inside of the G tag is considered to be inside slash part of the G container.
</p>
<br>
<p>
</p>
<p>
<pre><code class="html">&lt;g&gt; &lt;/g&gt;</code></pre>
</p>
<p>
There are two main reasons to use the SVG Group Element
</p>
<p>
One - To group a set of SVG elements that share the same attributes
</p>
<p>
Two - To define a new coordinate system for a set of SVG elements by applying a transformation to each coordinate specified in this set of SVG elements.
</p>
<p>
When you use a Group element, it can be for one reason or the other or both.
</p>
<br>
<p>
</p>
<p>
<pre><code class="html">&lt;g&gt; &lt;/g&gt;</code></pre>
</p>
<p>
With a group element, you can apply a set of transformations.
</p>
<p>
These transformations will transform every element inside of the G group.
</p>
<p>
The transformations does not affect elements outside of the specific G group to which the transformation was applied to.
</p>
<br>
<p>
[ Image: SVG Group Element Transform New Coordinate Space ]
</p>
<p>
What the G element transform is doing is transforming the SVG Coordinate Space.
</p>
<p>
The Translate functionality can be thought of as moving the (0,0) point of the blue coordinate system to a (0,0) point in the purple coordinate system.
</p>
<p>
So everything inside of the G element is now operating inside of the new purple coordinate space
</p>
<br>
<p>
</p>
<p>
<pre><code class="html">&lt;svg width="200" height="200"&gt;
    &lt;g ... transform=... > &lt;/g&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
So by defining an SVG Viewport and then defining a group element with a transform
</p>
<p>
We have defined a new coordinate space that we can treat as a regular coordinate space.
</p>
<p>
The margins we define then separate the sides, top and bottom of the group coordinate space from the SVG viewport coordinate space.
</p>
<p>
Everything we then draw can be drawn only in this new coordinate space.
</p>
<p>
By using the G element, we can assume away the margins and only focus on this new coordinate space.
</p>
<br>
<br>
<p>
<strong>
D3 Margin Convention
</strong>
</p>
<br>
<p>
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 10, bottom: 20, left: 10};</code></pre>
</p>
<p>
This is the margin convention commonly used in D3 examples - particularly in the D3js.org website.
</p>
<p>
This is a JavaScript Object.
</p>
<p>
It is not a JSON object because it does not have double quotes around the keys.
</p>
<p>
Though the margin number values may differ slightly between examples, the JavaScript object structure is the same.
</p>
<br>
<p>
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 10, bottom: 20, left: 10};

margin.top;

margin.right;

margin.bottom;

margin.left;</code></pre>
</p>
<p>
Because margin is a JavaScript object, we can use the keys to access the values inside.
</p>
<p>
This lends to a very readable variable that details all of the margin information.
</p>
<p>
The margin.top, margin.right, margin.bottom and margin.left tell you specifically that you are looking at the margin and which type of margin.
</p>
<br>
<p>
</p>
<p>
<pre><code class="javascript">eval(function(p,a,c,k,e,r){e=function(c){return c.toString(a)};if(!''.replace(/^/,String)){while(c--)r[e(c)]=k[c]||e(c);k=[function(e){return r[e]}];e=function(){return'\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c]);return p}('6 0={1:2,3:2,4:7,5:8},9=a-0.5-0.3,b=c-0.1-0.4;',13,13,'margin|top|20|right|bottom|left|var|30|50|width|960|height|500'.split('|'),0,{}))
  ...

var margin = {top: 20, right: 20, bottom: 30, left: 50},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;</code></pre>
</p>
<p>
Just because you can encode or compress your JavaScript
</p>
<p>
Does not mean you should.
</p>
<p>
The two JavaScript statements on the screen are equivalent and do the exact same thing.
</p>
<p>
Imagine 6 months from now trying to decipher what the top version does versus the second version.
</p>
<p>
So make sure to create and name variables in a way that makes it very easy to read and understand later.
</p>
<br>
<p>
</p>
<p>
<pre><code class="javascript">width = 960 - margin.left - margin.right;</code></pre>
</p>
<p>
There is a concept in Computer Science called Self-Documenting Code.
</p>
<p>
While this is not quite there, it is close enough that just by reading it out-loud we can get really close to the meaning.
</p>
<p>
The width is equal to 960 minus margin.left minus margin.right.
</p>
<p>
Makes sense and the only question we would have left is the width of what is equal to that equation.
</p>
<br>
<p>
Let's look at an example from the d3js.org website example section in order to see the margin object in Action.
</p>
<br>
<br>
<p>
<strong>
Line Chart Case Study
</strong>
</p>
<p>
We are going to look at the Line Chart on the D3js.org website
</p>
<p>
We navigate to the example section of the website and scroll down to the basic charts section.
</p>
<p>
We click on the line chart.
</p>
<p>
You can now see the line chart.
</p>
<p>
If we scroll down the page, you can see the code that has created this line chart.
</p>
<p>
First comes the CSS formatting
</p>
<p>
Then comes the actual D3 code
</p>
<p>
Finally comes the data used to construct this chart.
</p>
<p>
Going back to the top, let's look at the graph.
</p>
<p>
We can see the Y axis on the left side of the screen
</p>
<p>
We can see the X axis at the bottom of the chart
</p>
<p>
And we can see the Line Chart of the Data in the middle of the screen.
</p>
<p>
At the bottom right of the chart, there is a link called "Open in a new window"
</p>
<p>
This link takes us to a new window where the only thing on the HTML document page is the chart and the code created to generate it.
</p>
<p>
Let's click on that link.
</p>
<p>
This opened up a new tab for me.
</p>
<p>
You can't see that it's a new tab for me because I'm zoomed into the browser, though know that it is.
</p>
<p>
It will be a new tab for you if / when you click on the link yourself.
</p>
<p>
Now we open the Developer Tools.
</p>
<p>
BROWSER - Open the developer tools
</p>
<p>
A Few things to notice
</p>
<p>
1st - The D3 script link is located inside of the body instead of the head of the document.
</p>
<p>
2nd - The script that defines the chart using D3 comes after that.
</p>
<p>
3rd - The SVG is defined after the script.
</p>
<p>
As we'll see in a second, this is because the SVG was appended to the body element so it was added as the last child element.
</p>
<p>
Okay, so we see how the file is defined and structured.
</p>
<p>
Let's go back to the 1st tab to take a look at the code.
</p>
<p>
BROWSER - Go to the 1st tab
</p>
<p>
We scroll down the page to get to the script that generates the chart.
</p>
<p>
The first thing we see is the margin declaration
</p>
<p>
BROWSER - Highlight the MARGIN declaration.
</p>
<p>
This is the JavaScript Margin Object
</p>
<p>
This was covered earlier in this video.
</p>
<p>
Next is the definition of the width and height of what will eventually become the chart.
</p>
<p>
BROWSER - Highlight the WIDTH and HEIGHT declaration.
</p>
<p>
This will be used to define the interior SVG Coordinate space.
</p>
<p>
Now that we have the width and height and the margins, let's go down the code a bit to see where they are used.
</p>
<p>
BROWSER - Highlight the SVG Declaration.
</p>
<p>
This is where the margin variables and the width and height come into play.
</p>
<p>
Let's go back to the screen to see what we can make of this statement.
</p>
<br>
<p>
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 50},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;
    
var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
Here we have the variable declaration as well as the SVG Declaration.
</p>
<p>
We will go step by step to make sure we understand what is happening in this code.
</p>
<br>
<p>
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 50},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;
    
var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
We have already covered the variable declarations.
</p>
<p>
The first line we look at this time is the green highlighted line.
</p>
<p>
This line is declaring a variable called SVG
</p>
<p>
What is being assigned to it is a d3 selection containing the SVG element that has been appended to the body element.
</p>
<p>
This is straight forward and something we have seen before.
</p>
<br>
<p>
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 50},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;
  
var svg = d3.select("body").append("svg")                 
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
Next, we define the width of the SVG element by adding the width attribute and it's value.
</p>
<p>
We have seen the width attribute before.
</p>
<p>
What is new here is how the value of the width attribute is being constructed.
</p>
<p>
The width variable is having the margin.left and the margin.right added back into it.
</p>
<p>
Since the variable declaration subtracted them out earlier, through some mental arithmetic, we can see that the width of the SVG will be 960.
</p>
<br>
<p>
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 50},
    width = 960 - margin.left - margin.right,            
    height = 500 - margin.top - margin.bottom;
    
var svg = d3.select("body").append("svg")                 
    .attr("width", width + margin.left + margin.right)      
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
Next, we define the height of the SVG element by adding the height attribute and it's value.
</p>
<p>
We have seen the height attribute before.
</p>
<p>
What is new here is how the value of the height attribute is being constructed.
</p>
<p>
The height variable is having the margin.top and the margin.bottom added back into it.
</p>
<p>
Since the variable declaration subtracted them out earlier, through some mental arithmetic, we can see that the height of the SVG will be 500.
</p>
<br>
<p>
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 50},
    width = 960 - margin.left - margin.right,           
    height = 500 - margin.top - margin.bottom;
    
var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
So far so good, we have defined the SVG Viewport Container
</p>
<p>
It is 960 pixels wide by 500 pixels tall on the HTML Document Screen.
</p>
<p>
But we don't stop there.
</p>
<p>
We then append an SVG Group Element.
</p>
<br>
<p>
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 50},
    width = 960 - margin.left - margin.right,           
    height = 500 - margin.top - margin.bottom;
    
var svg = d3.select("body").append("svg")                 
    .attr("width", width + margin.left + margin.right)      
    .attr("height", height + margin.top + margin.bottom)    
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
The SVG Group element is appended to the SVG Container we just defined.
</p>
<p>
The G element is what everything else in this D3 chart is appended to.
</p>
<p>
Even the x-axis and y-axis.
</p>
<br>
<p>
</p>
<p>
<pre><code class="javascript">
var margin = {top: 20, right: 20, bottom: 30, left: 50},
    width = 960 - margin.left - margin.right,           
    height = 500 - margin.top - margin.bottom;
    
var svg = d3.select("body").append("svg")                 
    .attr("width", width + margin.left + margin.right)      
    .attr("height", height + margin.top + margin.bottom)    
  .append("g")                                              
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
The last thing we do is add in a transform attribute to the SVG Group Element.
</p>
<p>
The value of the transform attribute is a translate operation.
</p>
<p>
The translate operation will move the Origin point of the G Group element, margin.left units to the right
</p>
<p>
and margin.top units down.
</p>
<p>
The G element taken in with the transform / translate operation will act as a new Coordinate Space for the graph to be drawn in.
</p>
<br>
<p>
[ Image: D3 Margin Definition Snapshot ]
</p>
<p>
And with that, we have used the D3 margin convention to setup a new coordinate space in an SVG Container to draw a graph in.
</p>
<p>
The margins will provide more than enough space for the x-axis and y-axis to fit in.
</p>
<p>
This new coordinate space also serves as the De Facto coordinate space for drawing the chart.
</p>
        </div>
      </div>

</div>☺
    

<hr>
<h3 id="lesson29">D3 and JS Dates and Times<h3>
    <div>
        <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>JavaScript Objects are collections of methods and properties</li>
<li>One of the few times when using D3 that we use the JavaScript Object Constructor instead of the Object Literal creation is when defining JavaScript Date Objects</li>
<li>JavaScript Date Objects enable basic storage and retrieval of dates and times</li>
<li>JavaScript Date Objects can only be instantiated by calling JavaScript Date as a constructor with the word "new"</li>
<li>The JavaScript Date is measures as number of milliseconds since January 1, 1970, 00:00:00 UTC (Coordinate Universal Time)</li>
<li>D3 includes a helper module, d3.time.format(specifier), for parsing and formatting JavaScript Dates modeled after the strptime and strftime C-library standards</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/introduction-to-javascript">Introduction to JavaScript</a></li>
<li><a href="https://www.dashingd3js.com/lessons/javascript-functions">JavaScript Functions</a></li>
<li><a href="https://www.dashingd3js.com/lessons/javascript-data-types">JavaScript Data Types</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 and JS Dates and Times
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
JavaScript Objects Revisited
</strong>
</p>
<br>
<p>
JavaScript Composite Data Types
<p>
<ol>
<li>Object</li>
<li>Array</li>
</ol>
</p>
<p>
JavaScript Objects are collections of methods and properties.
</p>
<p>
A method is a function that is a member of an object.
</p>
<p>
A property is a value or set of values that is a member of an object.
</p>
<p>
The world of objects in JavaScript is a deep one.
</p>
<p>
The part of that world that we want to look at is Object Literals.
</p>
<p>
Object Literal JavaScript Object creation is used when you only want to create one instance of an object.
</p>
<p>
For a very large part of the D3 work that we will do together, we will only ever want to create one instance of an object.
</p>
<br>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 50};</code></pre>
</p>
<p>
This is an Object Literal JavaScript Object
</p>
<p>
With the curly brackets, we assign values to specific keys
</p>
<p>
In this case, 20 is assigned to top
</p>
<p>
20 is assigned to right
</p>
<p>
30 is assign to bottom
</p>
<p>
and 50 is assigned to left.
</p>
<br>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 50};

margin.top;     // margin['top']

margin.right;   // margin['right']

margin.bottom;  // margin['bottom']

margin.left;    // margin['left']</code></pre>
</p>
<p>
By creating an object, we can access it's properties.
</p>
<p>
We can access it by the way on the left or by the way on the right.
</p>
<br>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 50};</code></pre>
</p>
<p>
By defining the margin object like this, we had a ready made JavaScript object ready to go.
</p>
<p>
This is the Object Literal JavaScript Object way of defining objects.     
</p>
<br>
<p>
<pre><code class="javascript">var margin = new Object();

margin.top = 20;

margin.right = 20;

margin.bottom = 30;

margin.left = 50;</code></pre>
</p>
<p>
ANTI - PATTERN
</p>
<p>
Another way to define objects is to Construct them using a JavaScript built in Constructor.
</p>
<p>
The Object constructor creates an object wrapper for the given value.
</p>
<p>
If the value is null or undefined, it will create and return an empty object.
</p>
<p>
Otherwise, it will return an object of a type that corresponds to the given value.
</p>
<p>
It is an anti-pattern, in that it is not the preferred pattern to construct objects.
</p>
<p>
It is not the preferred pattern for two reasons:
</p>
<p>
One - Object Literal Construction is easier to type and read as it's done in one statement.
</p>
<p>
Two - Object Literal Construction emphasizes objects are simply Associative Arrays.
</p>
<br>
<br>
<p>
<strong>
JavaScript Date Object
</strong>
</p>
<br>
<p>
<pre><code class="javascript">var dateObject = new Date();</code></pre>
</p>
<p>
One of the few times when we do use an Object Constructor in JavaScript is when defining JavaScript Date Objects
</p>
<p>
JavaScript Date Objects enable basic storage and retrieval of dates and times.
</p>
<p>
JavaScript Date Objects can only be instantiated by calling JavaScript Date as a constructor with the word new.
</p>
<p>
Calling it as a regular function, without the new operator, will return a string rather than a Date object;   
</p>
<br>
<p>
<pre><code class="javascript">new Date();

new Date(value);

new Date(dateString);

new Date(year, month, day [, hour, minute, second, millisecond]);</code></pre>
</p>
<p>
The JavaScript Date Object can be created with several different parameters.
</p>
<p>
If you do not pass in any parameters, then the date gets set to today's date and time according to local time.
</p>
<p>
If you pass in a value, it is the number of milliseconds since January 1, 1970, 00:00:00 UTC - Which is the Coordinated Universal Time
</p>
<p>
If you pass in a date string, it will convert it to a Date Object for you.
</p>
<p>
If you pass in numbers separated by commas, it will assume that you are doing the last construction.
</p>
<p>
For every number you don't pass in, it will assume a zero.
</p>
<p>
For the year, make sure to pass in a four number year.    
</p>
<br>
<p>
<pre><code class="javascript">new Date(2013, 0); // 2013 - January

new Date(2013, 1); // 2013 - February

new Date(2013, 2); // 2013 - March

new Date(2013, 3); // 2013 - April

new Date(2013, 4); // 2013 - May

new Date(2013, 5); // 2013 - June

new Date(2013, 6); // 2013 - July

new Date(2013, 7); // 2013 - August

new Date(2013, 8); // 2013 - September

new Date(2013, 9); // 2013 - October

new Date(2013,10); // 2013 - November

new Date(2013,11); // 2013 - December</code></pre>
</p>
<p>
One important gotcha to pay attention to is that the month is zero based.
</p>
<p>
Make sure you keep this in mind and it will help prevent off-by one errors.
</p>
<br>
<p>
Date measured as Number of milliseconds since January 1, 1970, 00:00:00 UTC (UTC = Coordinated Universal Time)
</p>
<p>
The other important gotcha to pay attention to is that the Time Zone is UTC.
</p>
<p>
This can cause issues when you are very near midnight and your time zone is far enough away from UTC that it can cause a difference of dates.
</p>
<br>
<p>
new Date();
</p>
<p>
<ul>
<li>getDate()</li>
<li>getDay()</li>
<li>getFullYear()</li>
<li>getHours()</li>
<li>getMilliseconds()</li>
<li>getMinutes()</li>
<li>getMonth()</li>
<li>getSeconds()</li>
<li>getTime()</li>
<li>getTimezoneOffset()</li>
<li>getUTCDate()</li>
<li>getUTCDay()</li>
<li>getUTCFullYear()</li>
<li>getUTCHours()</li>
<li>getUTCMilliseconds()</li>
<li>getUTCMinutes()</li>
<li>getUTCMonth()</li>
<li>getUTCSeconds()</li>
<li>parse()</li>
<li>setDate()</li>
<li>setFullYear()</li>
<li>setHours()</li>
<li>setMilliseconds()</li>
<li>setMinutes()</li>
<li>setMonth()</li>
<li>setSeconds()</li>
<li>setTime()</li>
<li>setUTCDate()</li>
<li>setUTCFullYear()</li>
<li>setUTCHours()</li>
<li>setUTCMilliseconds()</li>
<li>setUTCMinutes()</li>
<li>setUTCMonth()</li>
<li>setUTCSeconds()</li>
<li>toDateString()</li>
<li>toISOString()</li>
<li>toJSON()</li>
<li>toLocaleDateString()</li>
<li>toLocaleTimeString()</li>
<li>toLocaleString()</li>
<li>toString()</li>
<li>toTimeString()</li>
<li>toUTCString()</li>
<li>UTC()</li>
<li>valueOf()</li>
</ul>
</p>
</p>
<p>
These are all of the methods available to the JavaScript Date Object
</p>
<p>
Quite a few of them.
</p>
<p>
There are many ways to get certain parts of the date and times.
</p>
<p>
There are also many ways to set certain parts of the date and times.
</p>
<p>
One set of things that are not present however, are ways to format dates and times.
</p>
<p>
Luckily, the D3 library comes with Time Formatting built into it.
</p>
<br>
<br>
<p>
<strong>
D3 Time Formatting
</strong>
</p>
<br>
<p>
<pre><code class="javascript">d3.time.format(specifier)</code></pre>
</p>
<p>
D3 includes a helper module for parsing and formatting dates modeled after the strptime and strftime C-library standards
</p>
<p>
If you've used Python's Time Module before, you'll be familiar with these.
</p>
<p>
Otherwise the D3 API documentation has a full write up.</p>
<br>
<p>
<pre><code class="javascript">d3.time.format(specifier)</code></pre>
</p>
<p>
There are 23 different types of formatting specifiers available as of the recording of this video.
</p>
<p>
They range from things like
</p>
<p>
abbreviated weekday name.
</p>
<p>
full weekday name.
</p>
<p>
abbreviated month name.
</p>
<p>
To things like
</p>
<p>
Week number of the year as a decimal number [00,53]
</p>
<p>
with Sunday as the first day of the week.</p>
<br>
<p>
<pre><code class="javascript">var dateToday = new Date();

var formatter = d3.time.format("%A");

formatter(dateToday);</code></pre>
</p>
<p>
This is the way to use the D3 helper module for formatting dates.
</p>
<p>
First, define the type of formatting you want
</p>
<p>
Then you pass in the date that you want formatted.   
</p>
<br>
<p>
Let's take a look in the JavaScript console at some of the D3 Time Formatting
</p>
<br>
<p>
First, let's define the dateFuture variable as a date in the future.
</p>
<p>
<pre><code class="javascript">var dateFuture = new Date(2020,0,12);</code></pre>
</p>
<p>
This date is January 12th, 2020.
</p>
<br>
<p>
Next, let's call it to see what it returns
</p>
<p>
<pre><code class="javascript">dateFuture;</code></pre>
</p>
<p>
You can see that it set the date in the future.
</p>
<p>
Also - notice that it is using my time zone (EST)
</p>
<p>
Also - notice that the time in hours, minutes and seconds has been set to zero.   
</p>
<br>
<p>
Next, let's check what type of JavaScript thing it is
</p>
<p>
<pre><code class="javascript">typeof(dateFuture);</code></pre>
</p>
<p>
JavaScript tells us it is an object.   
</p>
<br>
<p>
We can see what properties and methods it has available, by placing a period after the name and waiting for the JavaScript console to provide a dropdown list
</p>
<p>
<pre><code class="javascript">dateFuture.</code></pre>
</p>
<p>
In addition to the getter and setter methods, you can see the constructor method.
</p>
<p>
After that are get and set methods to get and set specific parts of the time and date.
</p>
<br>
<p>
We try one to see how it works
</p>
<p>
<pre><code class="javascript">dateFuture.getFullYear();</code></pre>
</p>
<p>
Notice that we use the open and close parenthesis after the method name to call the method.
</p>
<p>
This returns 2020 just as we would expect.
</p>
<br>
<p>
Now that we have the JavaScript Date Time Object, let's see what kind of formatting we can do with D3.
</p>
<br>
<p>
We type in the dateFuture variable again so we see what we are starting with.
</p>
<p>
<pre><code class="javascript">dateFuture;</code></pre>
</p>
<p>
The date returned is a Sunday.
</p>
<br>
<p>
Let's use D3 to get the full day name
</p>
<p>
<pre><code class="javascript">var dateFormatter1 = d3.time.format("%A");

dateFormatter1;

typeof(dateFormatter1);

dateFormatter1(dateFuture);</code></pre>
</p>
<p>
This returns Sunday.
</p>
<p>
Which is what we wanted from the D3 time formatter.   
</p>
<br>
<p>
Let's now get the full month name using D3
</p>
<p>
<pre><code class="javascript">var dateFormatter2 = d3.time.format("%B");

dateFormatter2(dateFuture);</code></pre>
</p>
<p>
This returns January, which is expected as when we built the dateFuture variable, we passed in a zero for January.
</p>
<br>
<p>
Next, Let's see what number of month D3 returns when we ask for the month number.
</p>
<p>
<pre><code class="javascript">var dateFormatter3 = d3.time.format("%m");

dateFormatter3(dateFuture);</code></pre>
</p>
<p>
This returned the string "01"
</p>
<p>
Two things to notice here
</p>
<p>
One - the string has a leading zero
</p>
<p>
Two - January shows up as the month number 1
</p>
<p>
Two is important to pay attention to because when we build JavaScript Date Objects, January is month number 0.
</p>
<p>
So you want to make sure you are paying close attention to whether you are using JavaScript or D3 Date to do things that require actual month numbers.
</p>
<br>
<p>
D3 can even tell us whether it is AM or PM time in the local time zone.
</p>
<p>
<pre><code class="javascript">var dateFormatter4 = d3.time.format("%p");

dateFormatter4(dateFuture);</code></pre>
</p>
<p>
This returns AM.
</p>
<p>
When the variable dateFuture was defined, we did not give it an hour, minute or second.
</p>
<p>
Since the JavaScript Date Object Constructor sets 0 to all the arguments that are not passed in, the dateFuture Date Object got set with 0 hours 0 minutes and 0 seconds.
</p>
<p>
Basically, exactly midnight on January 12th 2020.
</p>
<br>
<p>
And that covers some of the basic Date Time Formatting that can be applied using D3 to JavaScript Date Objects.
</p>
<br>
<p>
This comes in very handy when doing Data Visualizations of Time Series or events related to time.
</p>
<br>
<p>
Especially when we construct axis for charts and one of the axis contains times or dates or both.
</p>
        </div>
      </div>
    
    
    
    ☺</div>


<hr>
<h3 id="lesson30">D3 Time Scales<h3>
   
<div>
    <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>D3 Time Scales are an extension of the D3 Quantitative Scales that use the JavaSCript Date Object</li>
<li>The Scale domain is the input data, the Scale range is the output data</li>
<li>JavaScript Date Objects enable basic storage and retrieval of dates and times</li>
<li>If you put a plus sign in front of a JavaScript date object, JavaScript returns the number of milliseconds since January 1, 1970, 00:00:00 UTC (Coordinate Universal Time)</li>
<li>The D3 Time Scale is d3.time.scale</li>
<li>The D3 Time Scale is both an object and a function - you can call the scale just like any other function (pass in an argument and a result returns) and the scale has additional methods that change its behavior</li>
<li>The D3 Time Scale domain expects JavaScript Dates</li>
<li>The D3 Time Scale range expects numerical values</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/introduction-to-javascript">Introduction to JavaScript</a></li>
<li><a href="https://www.dashingd3js.com/lessons/javascript-functions">JavaScript Functions</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-and-js-dates-and-times">D3 and JS Dates and Times</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-scales">D3 Scales</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-scales-part-two">D3 Scales Part Two</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-scales-part-three">D3 Scales Part Three</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 Time Scales
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
D3 Scales Revisited
</strong>
</p>
<br>
<p>
Quantitative Scales - for continuous input domains, such as numbers.
</p>
<p>
Ordinal Scales - for discrete input domains, such as names or categories.
</p>
<p>
Time Scales - for time domains.
</p>
<br>
<p>
D3 provides three types of functions that map an input domain to an output range.
</p>
<p>
The Quantitative scales are for real numbers
</p>
<p>
The Ordinal Scales are Discreet domains, such as letters of the alphabet
</p>
<p>
The Time Scales are an extension of the Quantitative Scales that use the JavaScript Date Objects.
</p>
<p>
All of these scales take in data and convert it to a useable set of output.
</p>
<p>
Sometimes this means scaling up the data and sometimes it means scaling down the data.
</p>
<br>
<p>
Quantitative Scales - Linear Scales
</p>
<br>
<p>
y = mx + b
</p>
<p>
D3 Quantitative Scales are for continuous input domains, such as numbers.
</p>
<p>
The mapping is linear in that the output range value y can be expressed as a linear function of the input domain value x.
</p>
<p>
So we get y = mx + b
</p>
<br>
<p>
<pre><code class="javascript">d3.scale.linear()
    .domain( [0,400] )
    .range( [0,200] );</code></pre>
</p>
<p>
Rather than having to do this math ourselves, we can get D3 to do the math for us.
</p>
<p>
Using the D3 Scale Linear
</p>
<p>
We can tell D3 that the initial data covers 0 to 400
</p>
<p>
and we want it to cover 0 to 200 after it has been scaled.
</p>
<p>
This then figures out the correct math for the y=mx+b equation.
</p>
<p>
The initial data is entered in the domain.
</p>
<p>
What we want the data to be scaled to is put into the range.
</p>
<br>
<p>
<pre><code class="javascript">d3.scale.linear()
    .domain( [0,400] )
    .range( [0,200] );</code></pre>
</p>
<p>
The domain takes in 1 array that contains two numbers in it.
</p>
<p>
Note - these numbers can be anything you want.
</p>
<p>
These numbers should cover all the possible values of the data you are using.	
</p>
<br>
<p>
<pre><code class="javascript">d3.scale.linear()
    .domain( [0,400] ) 
    .range( [0,200] );</code></pre>
</p>
<p>
The range takes in 1 array that contains two numbers in it.
</p>
<p>
Note - these numbers can be anything you want.
</p>
<p>
These numbers should cover all of the possible values that you want the data to be mapped to.
</p>
<br>
<p>
ℝ - Real Numbers
<br>
LINE 1: Domain
<br>
----------A---------B---------C---------
<br>
LINE 2: Range
<br>
----------D---------E---------F---------
</p>
<p>
The Domain is Line 1
</p>
<p>
The Range is Line 2
</p>
<p>
The Range is thus the result of the y=mx+b transformation from Line 1 to Line 2
</p>
<p>
The left most element in Line 1 gets transformed to the left most element in Line 2
</p>
<p>
And the right most element in Line 1 gets transformed to the right most element in Line 2
</p>
<p>
And the middle elements in line 1 get transformed to the middle elements in line 2.
</p>
<br>
<br>
<p>
<strong>
JavaScript Date Objects Revisited 		
</strong>
</p>
<br>
<p>
<pre><code class="javascript">var dateObject = new Date();</code></pre>
</p>
<p>
JavaScript Date Objects enable basic storage and retrieval of dates and times.
</p>
<p>
JavaScript Date Objects can only be instantiated by calling JavaScript Date as a constructor with the word new.
</p>
<p>
Calling it as a regular function, without the new operator, will return a string rather than a Date object;
</p>
<br>
<p>
Date measured as Number of milliseconds since January 1, 1970, 00:00:00 UTC UTC = Coordinated Universal Time
</p>
<p>
The Time Zone on this date and time is UTC - The Coordinated Universal Time.
</p>
<br>
<p>
new Date()
</p>
<p>
<ul>
<li>getDate()</li>
<li>getDay()</li>
<li>getFullYear()</li>
<li>getHours()</li>
<li>getMilliseconds()</li>
<li>getMinutes()</li>
<li>getMonth()</li>
<li>getSeconds()</li>
<li>getTime()</li>
<li>getTimezoneOffset()</li>
<li>getUTCDate()</li>
<li>getUTCDay()</li>
<li>getUTCFullYear()</li>
<li>getUTCHours()</li>
<li>getUTCMilliseconds()</li>
<li>getUTCMinutes()</li>
<li>getUTCMonth()</li>
<li>getUTCSeconds()</li>
<li>parse()</li>
<li>setDate()</li>
<li>setFullYear()</li>
<li>setHours()</li>
<li>setMilliseconds()</li>
<li>setMinutes()</li>
<li>setMonth()</li>
<li>setSeconds()</li>
<li>setTime()</li>
<li>setUTCDate()</li>
<li>setUTCFullYear()</li>
<li>setUTCHours()</li>
<li>setUTCMilliseconds()</li>
<li>setUTCMinutes()</li>
<li>setUTCMonth()</li>
<li>setUTCSeconds()</li>
<li>toDateString()</li>
<li>toISOString()</li>
<li>toJSON()</li>
<li>toLocaleDateString()</li>
<li>toLocaleTimeString()</li>
<li>toLocaleString()</li>
<li>toString()</li>
<li>toTimeString()</li>
<li>toUTCString()</li>
<li>UTC()</li>
<li>valueOf()</li>
</ul>
</p>
<p>
These are all of the methods available to the JavaScript Date Object
</p>
<p>
There are many ways to get certain parts of the date and times.
</p>
<p>
There are also many ways to set certain parts of the date and times.
</p>
<p>
When working with Time Series in JavaScript and D3, these come up frequently.	
</p>
<br>
</p>
<p>
<pre><code class="javascript">var dateObject = new Date();

+dateObject;</code></pre>
</p>
<p>
If you put a plus sign in front of the dateObject, JavaScript returns the number of MilliSeconds since the starting date.
</p>
<p>
This is very useful if you are doing date Object Comparisons
</p>
<p>
Or adding and subtracting Date Objects.
</p>
<p>
Or Doing D3 Time Scales.
</p>
<br>
<br>
<p>
<strong>
D3 Time Scales
</strong>
</p>
<br>
<p>
Quantitative Scales - for continuous input domains, such as numbers.
</p>
<p>
Ordinal Scales - for discrete input domains, such as names or categories.
</p>
<p>
Time Scales - for time domains.
</p>
<br>
<p>
D3 provides three types of functions that map an input domain to an output range.
</p>
<p>
The Time Scales are an extension of the Quantitative Scales that use the JavaScript Date Objects.
</p>
<p>
The Time Scales take in data and convert it to a useable set of output.
</p>
<p>
Sometimes this means scaling up the data and sometimes it means scaling down the data.
</p>
<br>
<p>
Quantitative Scales
		- Linear Scales
		  >> Time Scales
	y = mx + b
</p>
<p>
D3 Quantitative Scales are for continuous input domains, such as numbers and Dates
</p>
<p>
The mapping is linear in that the output range value y can be expressed as a linear function of the input domain value x.
</p>
<p>
So we get y = mx + b
</p>
<br>
<p>
<pre><code class="javascript">d3.time.scale();</code></pre>
</p>
<p>
D3's time scale is an extension of d3.scale.linear that uses JavaScript Date objects as the domain representation.
</p>
<p>
Unlike the normal linear scale, domain values are coerced to dates rather than numbers
</p>
<p>
A scale object, such as that returned by d3.time.scale, is both an object and a function.
</p>
<p>
That is: you can call the scale like any other function, and the scale has additional methods that change its behavior.
</p>
<br>
<p>
<pre><code class="javascript">d3.time.scale()
    .domain([date_left, date_right])
    .range ([numb_left, numb_right]);</code></pre>
</p>
<p>
The Domain of the D3 Time scale takes in dates.
</p>
<p>
The range of the D3 Time scale takes in numbers.
</p>
<p>
In this way we are mapping a set of dates to a set of numbers.
</p>
<br>
<p>
ℝ - Real Numbers
<br>
LINE 1: Domain (Dates)
<br>
----------A---------B---------C---------
<br>
LINE 2: Range (Numbers)
<br>
----------D---------E---------F---------
</p>
<p>
The Domain is Line 1
</p>
<p>
The Range is Line 2
</p>
<p>
The Range is thus the result of the y=mx+b transformation from Line 1 to Line 2
</p>
<p>
The reason this works for dates to numbers is that when dates are used in D3 Quantitative Scales,
</p>
<p>
The dates are implicitly coerced to numbers representing the number of milliseconds
</p>
<p>
Which means Line 1 is the number of milliseconds
</p>
<p>
And line 2 is a set of numbers.
</p>
<br>
<p>
Let's check out some examples in the JavaScript Console.
</p>
<br>
<p>
First we take a look at how the d3.time.scale can transform data from 10 days to 10 numbers.
</p>
<p>
<pre><code class="javascript">var timeScale1 = d3.time.scale()
    .domain([new Date(2020,0,1),new Date(2020,0,11)])
    .range([0,10]);</code></pre>
</p>
<p>
In this case, we want to transform the first 10 1 day intervals of January 2020
</p>
<p>
To a line of numbers from 0 to 10.
</p>
<p>
That is a set of 10 1 unit intervals.
</p>
<br>
<p>
Let's check to see what was assigned to the timeScale1 variable
</p>
<p>
<pre><code class="javascript">timeScale1;

typeof(timeScale1);</code></pre>
</p>
<p>
The timeScale1 command returns the function while the typeOf(timeScale1) command returns the function string.
</p>
<p>
This means that d3.time.scale() is a function.
</p>
<br>
<p>
Next, let's test the left end points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">timeScale1(new Date(2020,0,1));</code></pre>
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
The function assumes that you are giving it a Date from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
We told the function to convert the left most point in line 1 to the left most point in line 2.
</p>
<p>
In this case, we were converting line 1 point January 1st 2020 to line 2 point 0.
</p>
<p>
So we should expect zero.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned zero.
</p>
<br>
<p>
Next, let's test the right end points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">timeScale1(new Date(2020,0,11));</code></pre>
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
The function assumes that you are giving it a Date from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
We told the function to convert the right most point in line 1 to the right most point in line 2.
</p>
<p>
In this case, we were converting line 1 point January 11th 2020 to line 2 point 10.
</p>
<p>
So we should expect 10.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned 10.
</p>
<br>
<p>
Next, let's test the middle points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">[timeScale1(new Date(2020,0,3)), timeScale1(new Date(2020,0,5)), timeScale1(new Date(2020,0,7))];</code></pre>
</p>
<p>
I put the functions into an array to save space so that we could test a few of them at the same time.
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
The function assumes that you are giving it a Date from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
So we should expect 2, 4 and 6.
</p>
<p>
Because we are passing in a date 2 days after January 1st 2020
</p>
<p>
a date 4 days after January 1st 2020
</p>
<p>
and a date 6 days after January 1st 2020.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned 2, 4 and 6.
</p>
<p>
Well, something incredibly close to 2, 4 and 6.
</p>
<p>
Why is it off?
</p>
<p>
It is slightly off because JavaScript treats decimal numbers as 64-bit floating point numbers.
</p>
<p>
For our purposes, this isn't really important now.
</p>
<br>
<p>
From this we can see that after we define the function with our initial data, we can use it to convert data for later use.
</p>
<p>
Let's reload the browser and look at how we can scale up the dates to a bigger second number line.	
</p>
<br>
<p>
Next, we take a look at how the d3.time.scale can transform data from 10 days to 100 numbers.
</p>
<p>
<pre><code class="javascript">var timeScale2 = d3.time.scale()
    .domain([new Date(2020,0,1),new Date(2020,0,11)])
    .range([0,100]);</code></pre>
</p>
<p>
In this case, we want to transform the first 10 1 day intervals of January 2020
</p>
<p>
To a line of numbers from 0 to 100.
</p>
<p>
That is a set of 100 1 unit intervals.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<br>
<p>
Let's check to see what was assigned to the timeScale2 variable
</p>
<p>
<pre><code class="javascript">timeScale2;

typeof(timeScale2);</code></pre>
</p>
<p>
The timeScale2 command returns the function while the typeOf(timeScale2) command returns the function string.
</p>
<p>
This means that d3.time.scale() is a function.	
</p>
<br>
<p>
Next, let's test the left end points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">timeScale2(new Date(2020,0,1));</code></pre>
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
The function assumes that you are giving it a Date from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
We told the function to convert the left most point in line 1 to the left most point in line 2.
</p>
<p>
In this case, we were converting line 1 point January 1st 2020 to line 2 point 0.
</p>
<p>
So we should expect zero.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned zero.	
</p>
<br>
<p>
Next, let's test the right end points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">timeScale2(new Date(2020,0,11));</code></pre>
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
The function assumes that you are giving it a Date from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
We told the function to convert the right most point in line 1 to the right most point in line 2.
</p>
<p>
In this case, we were converting line 1 point January 11th 2020 to line 2 point 100.
</p>
<p>
So we should expect 100.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned 100.
</p>
<br>
<p>
Next, let's test the middle points of the domain to range conversion.
</p>
<p>
<pre><code class="javascript">[timeScale2(new Date(2020,0,3)), timeScale2(new Date(2020,0,5)), timeScale2(new Date(2020,0,7))];</code></pre>
</p>
<p>
I put the functions into an array to save space so that we could test a few of them at the same time.
</p>
<p>
Before we press enter, what do we expect?
</p>
<p>
The function assumes that you are giving it a Date from the domain.
</p>
<p>
The function then returns a number in the range.
</p>
<p>
So we should expect 20, 40 and 60.
</p>
<p>
Because we are passing in a date 2 days after January 1st 2020
</p>
<p>
a date 4 days after January 1st 2020
</p>
<p>
and a date 6 days after January 1st 2020.
</p>
<p>
BROWSER - PRESS ENTER
</p>
<p>
As you can see, it returned 20, 40 and 60.
</p>
<br>
<p>
From this we can see that after we define the function with our initial data, we can use it to convert data for later use.
</p>
<p>
As you can imagine, we can also use the time scale function to shift data to the right or the left
</p>
<p>
As well as combinations of scaling up or down and shifting the data to the right or the left.
</p>
<br>
<p>
<pre><code class="javascript">d3.time.scale()
    .domain([date_left, date_right])
    .range ([numb_left, numb_right]);</code></pre>
</p>
<p>
Again,
</p>
<p>
The Domain of the D3 Time scale takes in dates.
</p>
<p>
The range of the D3 Time scale takes in numbers.
</p>
<p>
In this way we are mapping a set of dates to a set of numbers.
</p>
<br>
<p>
And with that, you can see just how powerful the D3 Time Scale function can be because we can scale one data set to another.
</p>
<p>
This is incredibly helpful when building Data Visualizations that contain dates and times.
</p>
<p>
Both for constructing the SVG Viewport as well as for doing the x-axis and/or the y-axis.
</p>
        </div>
      </div>

</div>☺
    

<hr>
<h3 id="lesson31">D3 Axes<h3>
    <div>
    <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>The D3 Axis Component, d3.svg.axis(), displays reference lines, labeled ticks, and does the math to get equal space between the ticks for any D3 Scale you provide automatically</li>
<li>The D3 axis component works with D3 Quantitative Scales, D3 Times Scales, and D3 Ordinal Scales</li>
<li>Using the D3 Scale, you can tell the D3 SVG Axis Component what the domain and range should be for the scale you want to use, and the D3 SVG Axis Component will do all the math behind the scenes for us</li>
<li>The D3 Axis Component is a function, so you have to pass it an argument in which it can do work on - this is always a D3 Selection inside of which it will generate the SVG Axis for us</li>
<li>Because the D3 Axis Component does the minimum amount of work, it doesn't take into account the fact that some of the SVG Graphical Elements it generates could be outside of the SVG Viewport, so you need to use the D3 Margin Convention</li>
<li>By using the D3 Margin Convention and defining the margin.top, margin.bottom, margin.left, and margin.right you can do an SVG transform translate to ensure there Axis the D3 Axis Component generates appears fully in the SVG Viewport</li>
</ul>
</p>

        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/d3-scales">D3 Scales</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-scales-part-two">D3 Scales Part Two</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-scales-part-three">D3 Scales Part Three</a></li>
<li><a href="https://www.dashingd3js.com/lessons/dynamic-svg-coordinate-space">Dynamic SVG Coordinate Space</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-and-the-svg-group-element">D3 and the SVG Group Element</a></li>
<li><a href="https://www.dashingd3js.com/lessons/margin-convention">Margin Convention</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 Axes
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
D3 Axis Component
</strong>
</p>
<br>
<p>
[ Image: X and Y Axis Graph ]
</p>
<p>
This is what the math coordinate space looks like when taught in schools.
</p>
<p>
The graph has a coordinate space where x=0 and y=0 coordinates fall on the bottom left.
</p>
<p>
And the coordinates of X grow as you move to the right
</p>
<p>
And the coordinates of Y grow as you move up.
</p>
<br>
<p>
[ Image: SVG Coordinate axis ]
</p>
<p>
SVG Coordinate Space works in the same way that mathematical graph coordinate space works except for two important features:
</p>
<p>
GREEN ARROW POINTING TO THE ORIGIN POINT
</p>
<p>
One - SVG Coordinate space has it's origin point (0,0) at the top left
</p>
<p>
Two - SVG Coordinate space has the Y coordinate growing from top to bottom.
</p>
<br>
<p>
[ Image: Graph ]
</p>
<p>
In either Math Coordinate Space or SVG Coordinate space, we often use graphs to give us a picture of the relationship between variables.
</p>
<p>
The graphs consist of two axes typically called the x axis (for the horizontal variable) and the y axis (for the vertical variable).
</p>
<p>
The point where the two axis intersect is called the origin point.
</p>
<p>
This point is normally the (0,0) point.
</p>
<p>
When a point is drawn on the chart it is showing the interplay between the two variables.
</p>
<p>
Normally, the X axis is the independent variable and the Y axis is the dependent variable.
</p>
<p>
In linear relationships, this is easily seen by the y=mx+b equation.
</p>
<br>
<p>
[ Image: Axes ]
</p>
<p>
Each axis has a common set of components that help us to understand the relationship between the variables.
</p>
<p>
The axis will have tick marks to designate equal spacing between the ends of the axis
</p>
<p>
The axis will have text that designates the numbers of each tick as well as ends of the axis
</p>
<p>
The axis will also have an axis straight line that allows the ticks and text to live on it
</p>
<p>
The axis will also has an orientation - commonly the top or bottom or left or right to designate whether it is the X or Y axis.
</p>
<p>
There is a good deal of math and drawing required to make a good looking readable and legible axis.
</p>
<p>
Luckily for us, D3 provides a component that will take care of all of the above for us as long as we give it a few inputs.
</p>
<br>
<p>
</p>
<p>
<pre><code class="javascript">d3.svg.axis()</code></pre>
</p>
<p>
The D3 axis component displays reference lines, labeled ticks and does the math to get equal space between the ticks for any scale we provide automatically.
</p>
<p>
The D3 axis component works with quantitative scales, time scales and even ordinal scales.
</p>
<p>
According to the D3 API - This lets you focus on displaying the data, while the axis component takes care of the tedious task of drawing axes and labeled ticks.
</p>
<p>
Which is great news for us!
</p>
<br>
<p>
<pre><code class="javascript">d3.select("body").append("svg")
    .attr("width", 200)
    .attr("height",200)
  .append("g")
    .call( d3.svg.axis() );</code></pre>
</p>
<p>
This is the most basic way to add an axis to an SVG Container.
</p>
<p>
We will take a look at this in a second in the JavaScript Console
</p>
<p>
Notice that we use D3 to create an SVG Container
</p>
<p>
Then we add the width and height attribute to the SVG Container
</p>
<p>
Then we append an SVG Group Element
</p>
<p>
The SVG Group element will hold the D3 Axis Elements.
</p>
<p>
Finally we call the d3.svg.axis component.</p>
<br>
<p>
<pre><code class="javascript">.call( d3.svg.axis() );</code></pre>
</p>
<p>
To add the D3 Axis to the SVG Group Element, we have to call the D3 Axis Component.
</p>
<p>
The D3.svg.axis component is a function, so when we call it, we are passing to it the current selection.
</p>
<p>
The current selection being the SVG Group Element.
</p>
<p>
The D3.svg Axis Component does it's function thing and then returns a new selection.
</p>
<br>
<p>
Alright, let's try it in the JavaScript Console.
</p>
<br>
<p>
Let's type the most basic way to add an axis to the SVG Container.
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg")
    .attr("width", 200)
    .attr("height",200)
  .append("g")
    .call( d3.svg.axis() );</code></pre>
</p>
<p>
As we covered before, this creates an SVG container, then adds the width and height attributes
</p>
<p>
Then appends the SVG Group Element and calls the d3.svg.axis function
</p>
<p>
BROWSER - Press Enter
</p>
<p>
You can see that something has been created.  
</p>
<br>
<p>
Let's click into the body element to see what was created.
</p>
<p>
BROWSER - CLICK INTO THE BODY ELEMENT
</p>
<p>
Here you can see the following:
</p>
<p>
First, we see the SVG Container with a width of 200 and a height of 200
</p>
<p>
Next, we see the SVG Group Element
</p>
<p>
Then, we see a whole bunch of SVG Group elements.
</p>
<p>
Each group element has the class "tick major" with a style and a transform translate.
</p>
<p>
You can see that the transform translates have the x-axis coordinate increasing by 0.1 each time.
</p>
<p>
If we continue scrolling down, we eventually reach a SVG path with class of domain and a d equals for the SVG Path drawing instructions.
</p>
<br>
<p>
Let's scroll back to the top and look at the first tick.
</p>
<p>
BROWSER - Scroll back to top and click on first tick element.
</p>
<p>
When we click into the first tick element
</p>
<p>
We see two things inside
</p>
<p>
One - an SVG Line
</p>
<p>
Two - SVG text with the text 0.0 in it.
</p>
<p>
When we click into the second element
</p>
<p>
We see two things inside
</p>
<p>
One - an SVG line
</p>
<p>
Two - SVG Text with the text 0.1 in it.
</p>
<p>
This tells us a few things:
</p>
<p>
A - Each tick element will be comprised of a line and text
</p>
<p>
and B - Each text element will have text inside indicating what the value is   
</p>
<br>
<p>
The one thing that is hard to appreciate it is what it looks like.
</p>
<p>
BROWSER - Highlight the HTML WEBPAGE
</p>
<p>
This is because all of the tick marks happen between the 0 and the 1 unit of the SVG Container.
</p>
<br>
<p>
What we need to do is to somehow tell the D3 SVG Axis, that we want the axis to scale over the full 200 units of the SVG Container.
</p>
<br>
<p>
Luckily, D3 has that built in.
    # Using the D3 Quantitative Scale, we can tell the D3 SVG Axis component what the domain and range should be for the scale we want to use, and the D3 SVG Axis component will do all the math behind the scenes for us.
</p>
<br>
<br>
<p>
<strong>
D3 Axis Scale
</strong>
</p>
<p>
</p>
<br>
<p>
Quantitative Scales - for continuous input domains, such as numbers.
</p>
<p>
Ordinal Scales - for discrete input domains, such as names or categories.
</p>
<p>
Time Scales - for time domains.
</p>
<br>
<p>
D3 provides three types of functions that map an input domain to an output range.
</p>
<p>
The Quantitative scales are for real numbers
</p>
<p>
The Ordinal Scales are Discreet domains, such as letters of the alphabet
</p>
<p>
The Time Scales are an extension of the Quantitative Scales that use the JavaScript Date Objects.
</p>
<p>
All of these scales take in data and convert it to a usable set of output.
</p>
<p>
Sometimes this means scaling up the data and sometimes it means scaling down the data.    
</p>
<br>
<p>
ℝ - Real Numbers
<br>
LINE 1: Domain
<br>
----------A---------B---------C---------
<br>
LINE 2: Range
<br>
----------D---------E---------F---------
</p>
<p>
The Domain of the scale is Line 1
</p>
<p>
The Range of the scale is Line 2
</p>
<p>
The Range is thus the result of the y=mx+b transformation from Line 1 to Line 2
</p>
<p>
The left most element in Line 1 gets transformed to the left most element in Line 2
</p>
<p>
And the right most element in Line 1 gets transformed to the right most element in Line 2
</p>
<p>
And the middle elements in line 1 get transformed to the middle elements in line 2.
</p>
<br>
<p>
<pre><code class="javascript">var myScale = d3.scale.linear()
    .domain( [0,1] )
    .range( [0,200] );

var myAxis = d3.svg.axis()
    .scale(myScale);

    //...
    .call( myAxis );</code></pre>
</p>
<p>
After we define the scale, we can pass the scale function to the d3.svg Axis component.
</p>
<p>
This allows the math to happen behind the scenes.
</p>
<p>
When we do then call myAxis, the scale will have been fixed so that it takes in the domain and converts it to the range.
</p>
<p>
So we should expect all the tick marks, lines, paths and text to now be generated over the whole range.
</p>
<br>
<p>
<pre><code class="javascript">var myScale = d3.scale.linear()
    .domain( [0,10] )
    .range( [0,200] );

var myAxis = d3.svg.axis()
    .scale(myScale);

var mySVG = d3.select("body").append("svg")
    .attr("width", 200)
    .attr("height",200);

var axisGroup = mySVG.append("g").call( myAxis );</code></pre>
</p>
<p>
In full, we are going to define the scale we want to use
</p>
<p>
Define the axis function and pass in a scale for it to use
</p>
<p>
Then we are going to define the SVG Container
</p>
<p>
And finally, we are going to append an SVG Group container to the SVG Container
</p>
<p>
And then call the axis function on the SVG Container Selection.
</p>
<p>
This will do the necessary work in the background and generate a full axis for us.
</p>
<br>
<p>
Let's try it out in the JavaScript Console
</p>
<br>
<p>
We define each element one by one.
</p>
<br>
<p>
First, we define the myScale variable
</p>
<p>
<pre><code class="javascript">var myScale = d3.scale.linear()
    .domain( [0, 10] )
    .range ( [0,200] );</code></pre>
</p>
<p>
This tells D3 that we want to convert the number line 0 to 10
</p>
<p>
To a number line that spans 0 to 200
</p>
<p>
Basically, the y=mx+b math should be that you multiply every number in the domain by 20 to get the range
</p>
<br>
<p>
Next, we define the D3 Axis Component
</p>
<p>
<pre><code class="javascript">var myAxis = d3.svg.axis()
    .scale(myScale);</code></pre>
</p>
<p>
We define the D3 Axis Component with a scale to make sure that it generates the right size of axis for us.
</p>
<p>
This includes the text, the tick marks, the SVG transform translate and the SVG path that connects all of the tick marks.
</p>
<br>
<p>
Next, we define the SVG Container
</p>
<p>
<pre><code class="javascript">var mySVG = d3.select("body").append("svg")
    .attr("width", 200)
    .attr("height",200);</code></pre>
</p>
<p>
Starting from an empty HTML document with nothing in it other than the HTML Document type and the D3 JavaScript link
</p>
<p>
We select the body and append an SVG Element.
</p>
<p>
We then append the attributes width and height and their respective values
</p>
<p>
This gives us the SVG Viewport in which we can draw all of the graphics.
</p>
<br>
<p>
Next, we define the Axis SVG Group Element.
</p>
<p>
<pre><code class="javascript">var axisGroup = mySVG.append("g").call( myAxis );</code></pre>
</p>
<p>
In this command, we append the SVG Group element to the SVG Container.
</p>
<p>
Then we call the D3 Axis Component function on the SVG Group Element selection
</p>
<p>
This does it's calculations and returns the axis for us.
</p>
<br>
<p>
As you can see, we have now generated an axis!
</p>
<br>
<p>
Let's click into the body element to see what was created.
</p>
<p>
BROWSER - CLICK INTO THE BODY ELEMENT
</p>
<p>
Here you can see the following:
</p>
<p>
First, we see the SVG Container with a width of 200 and a height of 200
</p>
<p>
Next, we see the SVG Group Element
</p>
<p>
Then, we see a whole bunch of SVG Group elements.
</p>
<p>
Each group element has the class "tick major" with a style and a transform translate.
</p>
<p>
You can see that the transform translates have the x-axis coordinate increasing by 20 each time.
</p>
<p>
This is from the math we did earlier.
</p>
<p>
The D3 Quantitative Scale converted the domain of 0 to 10 to the range of 0 to 200.
</p>
<p>
This means that each number in the domain needed to be multiplied by 20.
</p>
<p>
Which means that if we divide the range of 200 by 10 units, each spacing should by 20 units wide.
</p>
<p>
If we continue scrolling down, we eventually reach a path with class of domain and a d equals attribute for the SVG Path drawing instructions.
</p>
<p>
When we hover over the path, you can see that this is the axis line that connects all of the tick marks.
</p>
<br>
<p>
Let's scroll back to the top and look at the first tick major mark.
</p>
<p>
BROWSER - Scroll back to top and click on first tick element.
</p>
<p>
When we click into the first tick element
</p>
<p>
We see two things inside
</p>
<p>
One - an SVG Line
</p>
<p>
Two - SVG text with the text 0 in it.
</p>
<p>
When we click into the second element
</p>
<p>
We see two things inside
</p>
<p>
One - an SVG line
</p>
<p>
Two - SVG Text with the text 1 in it.
</p>
<p>
This tells us two things:
</p>
<p>
A - Each tick element will comprise of a line and text
</p>
<p>
and B - Each text element will have text inside indicating what the value is
</p>
<p>
Again, going back to the D3 scale we defined above, we want the scale domain to cover the numbers 0 to 10.
</p>
<p>
You can see that the axis does indeed cover the numbers 0 to 10.
</p>
<p>
Each tick mark is one of those numbers.
</p>
<br>
<p>
Before we do more examples, let's revisit the D3 Margin Convention for Graphs.
</p>
<p>
If you recall, this helps create an inside SVG element that is then used to create all graphs.
</p>
<p>
Doing this will help use see the end points of the D3 SVG Axis Component.
</p>
<br>
<br>
<p>
<strong>
D3 Axis Component with Margins
</strong>
</p>
<p>
</p>
<br>
<p>
<pre><code class="javascript">var margin = {top: 50, right: 50, bottom: 50, left: 50},
    width = 300 - margin.left - margin.right,           
    height = 300 - margin.top - margin.bottom;
    
var mySVG = d3.select("body").append("svg")                 
    .attr("width", width + margin.left + margin.right)      
    .attr("height", height + margin.top + margin.bottom)    
  .append("g")                                              
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
This is the D3 Margin Convention
</p>
<p>
First we define a JavaScript Object Literal which has the top, right, bottom and left margins.
</p>
<p>
Then we define the SVG Container to be 300 pixels wide by 300 pixels tall.
</p>
<p>
Then we define an interior SVG Group element that is transform translated margin.left to the right
</p>
<p>
and margin.top to the bottom.
</p>
<p>
This creates an interior SVG Coordinates space in which everything will be drawn and created in.
</p>
<br>
<p>
[ Image: Margin Definition Picture ]
</p>
<p>
And with that, we have used the D3 margin convention to setup a new coordinate space in an SVG Container to draw a graph in.
</p>
<p>
The margins will provide more than enough space for the x-axis and y-axis to fit in.
</p>
<p>
This new coordinate space also serves as the De Facto coordinate space for drawing the chart.
</p>
<br>
<p>
<pre><code class="javascript">var margin = {top: 50, right: 50, bottom: 50, left: 50},
    width = 300 - margin.left - margin.right,           
    height = 300 - margin.top - margin.bottom;

var myScale = d3.scale.linear()
    .domain( [0,10] )
    .range ( [0,width] );

var myAxis = d3.svg.axis()
    .scale(myScale);

var mySVG = d3.select("body").append("svg")                 
    .attr("width", width + margin.left + margin.right)      
    .attr("height", height + margin.top + margin.bottom)    
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var axisGroup = mySVG.append("g").call( myAxis );</code></pre>
</p>
<p>
This is the full code we are going to use.
</p>
<p>
It is the same as before, except that this time, we are going to do two things differently.
</p>
<p>
One - the scale range is now from 0 to width.
</p>
<p>
This is the width of the SVG inner container coordinate space
</p>
<p>
Two - mySVG now contains an interior container coordinate space which we attach the D3 SVG Axis component too.
</p>
<p>
Not to worry if this is a bunch of code to look at, all at the same time.
</p>
<p>
We'll play with it in JavaScript and things will make more sense.
</p>
<br>
<p>
We define each element one by one.
</p>
<br>
<p>
First, we define the margin JavaScript Object Literal as well as the width and height of the inner SVG coordinate space
</p>
<p>
<pre><code class="javascript">var margin = {top: 50, right: 50, bottom: 50, left: 50},
    width = 300 - margin.left - margin.right,           
    height = 300 - margin.top - margin.bottom;</code></pre>
</p>
<p>
These variables are used to define the width and height of the inner SVG coordinate space as well as the margins around it.
</p>
<p>
All of which live inside of the 300 by 300 SVG Container.
</p>
<br>
<p>
Next, we define the myScale variable
</p>
<p>
<pre><code class="javascript">var myScale = d3.scale.linear()
    .domain( [0,   10] )
    .range ( [0,width] );</code></pre>
</p>
<p>
This tells D3 that we want to convert the number line 0 to 10
</p>
<p>
To a number line that spans 0 to the width of the inner SVG coordinate space.
</p>
<p>
Which in this case is 200.
</p>
<p>
Which is the same as the example earlier, meaning that the y=mx+b math should be that you multiply every number in the domain by 20 to get the range
</p>
<br>
<p>
Next, we define the D3 Axis Component
</p>
<p>
<pre><code class="javascript">var myAxis = d3.svg.axis()
    .scale(myScale);</code></pre>
</p>
<p>
We define the D3 Axis Component with a scale to make sure that it generates the right size of axis for us.
</p>
<p>
This includes the text, the tick marks, the SVG transform translate and the SVG path that connects all the tick marks.
</p>
<p>
There is no change here due to the addition of the margins to the SVG Container.
</p>
<p>
This is because once we have the inner SVG Container defined and scaled, we can treat it as the de-facto drawing space.
</p>
<br>
<p>
Next, we define the SVG Container
</p>
<p>
<pre><code class="javascript">var mySVG = d3.select("body").append("svg")                 
    .attr("width", width + margin.left + margin.right)      
    .attr("height", height + margin.top + margin.bottom)    
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
Starting from an empty HTML document with nothing in it other than the HTML Document type and the D3 JavaScript link
</p>
<p>
We select the body and append an SVG Element.
</p>
<p>
We then define the attributes width and height and their respective values based
</p>
<p>
on the inner SVG Coordinate space width and the margins to the left and right of the it
</p>
<p>
as well as the margins to the top and bottom of it.
</p>
<p>
Then we append an inner SVG Group element which is where all the graphical elements will be located.
</p>
<p>
We use the SVG transform translate to move this to a new coordinate space.
</p>
<p>
This gives us the SVG inner container in which we can draw all of the graphics.
</p>
<br>
<p>
Next, we define the Axis SVG Group Element.
</p>
<p>
<pre><code class="javascript">var axisGroup = mySVG.append("g").call( myAxis );</code></pre>
</p>
<p>
In this command, we append the SVG Group element to the SVG Container.
</p>
<p>
Then we call the D3 Axis Component function on the SVG Group Element selection
</p>
<p>
This does it's calculations and returns the axis to us.
</p>
<br>
<p>
As you can see, we have now generated an axis!
</p>
<br>
<p>
Let's click into the body element to see what was created.
</p>
<p>
BROWSER - CLICK INTO THE BODY ELEMENT
</p>
<p>
Here you can see the following:
</p>
<p>
First, we see the SVG Container with a width of 300 and a height of 300
</p>
<p>
Next, we see the SVG Group Element
</p>
<p>
We can see that it has an SVG transform translate of 50 comma 50.
</p>
<p>
This is where we did the transformation to give the inner container margins.
</p>
<p>
Inside of this container, we see another SVG Group Element.
</p>
<p>
This is the container where the D3 Axis Component generated the axis.
</p>
<p>
Inside of this, we then see a whole bunch of SVG Group elements.
</p>
<p>
Each group element has the class "tick major" with a style and a transform translate.
</p>
<p>
You can see that the transform translates have the x-axis coordinate increasing by 20 each time.
</p>
<p>
This is from the math we did earlier.
</p>
<p>
The D3 Quantitative Scale converted the domain of 0 to 10 to the range of 0 to 200.
</p>
<p>
This means that each number in the domain needed to be multiplied by 20.
</p>
<p>
Which means that if we divide the range of 200 by 10 units, each spacing should by 20 units wide.
</p>
<p>
If we continue scrolling down, we eventually reach a path with class of domain and a d equals for the SVG Path drawing instructions.
</p>
<p>
When we hover over the path, you can see that this is the axis line that connects all the tick marks.
</p>
<p>
Because we specified margins around the inner SVG Container, we are able to see the full zero SVG text element and the full 10 SVG text element at the opposite ends of the Axis.
</p>
<br>
<p>
Let's scroll back to the top and look at the first tick major mark.
</p>
<p>
BROWSER - Scroll back to top and click on first tick element.
</p>
<p>
When we click into the first tick element
</p>
<p>
We see two things inside
</p>
<p>
One - an SVG Line
</p>
<p>
Two - SVG text with the text 0 in it.
</p>
<p>
When we click into the second element
</p>
<p>
We see two things inside
</p>
<p>
One - an SVG line
</p>
<p>
Two - SVG Text with the text 1 in it.
</p>
<p>
This tells us a few things:
</p>
<p>
A - Each tick element will comprise of a line and text
</p>
<p>
and B - Each text element will have text inside indicating what the value is
</p>
<p>
Again, going back to the D3 scale we defined above, we want the scale domain to cover the numbers 0 to 10.
</p>
<p>
You can see that the axis does indeed cover the numbers 0 to 10.
</p>
<p>
Each tick mark is one of those numbers.
</p>
<br>
<p>
</p>
<p>
<pre><code class="javascript">d3.svg.axis()</code></pre>
</p>
<p>
And with that, you can see just how powerful the D3 SVG Axis Component can be, in generating an axis for us.
</p>
<p>
It does all the math behind the scenes as long as we provide for it a scale with a domain and range
</p>
<p>
As well as an SVG Group Element it can live inside of.
</p>
<p>
So the D3 API Documentation was correct - this does let you focus on displaying the data, while the axis component takes care of the tedious task of drawing axes and labeled ticks for us.
</p>
        </div>
      </div>

</div>
☺
    

<hr>
<h3 id="lesson32">D3 Axes Manipulation<h3>
    <div>
     <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>The D3 Axis Component, d3.svg.axis(), displays reference lines, labeled ticks, and does the math to get equal space between the ticks for any D3 Scale you provide automatically</li>
<li>The D3 Axis Component is a function, so you have to pass it an argument in which it can do work on - this is always a D3 Selection inside of which it will generate the SVG Axis for us</li>
<li>The D3 Axis Component has a method, .orient([orientation]), for getting/setting the position of the ticks and their labels in relation to the axis path (the actual axis line)</li>
<li>For horizontal axes, the key words are "top" and "bottom"</li>
<li>For vertical axes, the key words are "left" and "right"</li>
<li>The default orientation is a horizontal axis with a "bottom" orientation (that is - the ticks and labels are below the line)</li>
<li>If you use "left" or "right", D3 changes your axis from a horizontal axis to a vertical axis, which solves the issue of figuring out how to manually rotate ticks, lines, and the path line so that the axis is vertical rather than horizontal</li>
<li>The orientation is orienting the ticks and text on either side of the path line, it is not putting the axis on the left or right or top or bottom of the SVG Group Element Container you are calling it from</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/d3-scales">D3 Scales</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-scales-part-two">D3 Scales Part Two</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-scales-part-three">D3 Scales Part Three</a></li>
<li><a href="https://www.dashingd3js.com/lessons/margin-convention">Margin Convention</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-axes">D3 Axes</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 Axes Manipulation
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
D3 Axis Component Revisited
</strong>
</p>
<br>
<p>
<pre><code class="javascript">d3.svg.axis()</code></pre>
</p>
<p>
The D3 axis component displays reference lines, labeled ticks and does the math to get equal spacing between the ticks for any scale we provide automatically.
</p>
<p>
The D3 axis component works with quantitative scales, time scales and even ordinal scales.
</p>
<p>
According to the D3 API - This lets you focus on displaying the data, while the axis component takes care of the tedious task of drawing axes and labeling ticks.
</p>
<br>
<p>
<pre><code class="javascript">d3.select("body").append("svg")
    .attr("width", 200)
    .attr("height",200)
  .append("g")
    .call( d3.svg.axis() );</code></pre>
</p>
<p>
This is the most basic way to add an axis to an SVG Container.
</p>
<p>
Notice that we use D3 to create an SVG Container
</p>
<p>
Then we add the width and height attribute to the SVG Container
</p>
<p>
Then we append an SVG Group Element
</p>
<p>
The SVG Group element will hold the D3 Axis Elements.
</p>
<p>
Finally we call the d3.svg.axis component.
</p>
<br>
<p>
<pre><code class="javascript">var myScale = d3.scale.linear()
    .domain( [0,1] )
    .range( [0,200] );

var myAxis = d3.svg.axis()
    .scale(myScale);

// ...
    .call( myAxis );</code></pre>
</p>
<p>
We can give the axis element a scale in which we give it a domain and a range.
</p>
<p>
After we define the scale, we can pass the scale function to the d3.svg Axis component.
</p>
<p>
This allows the math to happen behind the scenes.
</p>
<p>
When we do then call myAxis, the scale will have been fixed so that it takes in the domain and converts it to the range.
</p>
<p>
So we should expect all of the tick marks, lines, paths and text to now be generated over the whole range.
</p>
<br>
<p>
<pre><code class="javascript">var margin = {top: 50, right: 50, bottom: 50, left: 50},
    width = 300 - margin.left - margin.right,           
    height = 300 - margin.top - margin.bottom;

var myScale = d3.scale.linear()
    .domain( [0,10] )
    .range ( [0,width] );

var myAxis = d3.svg.axis()
    .scale(myScale);

var mySVG = d3.select("body").append("svg")                 
    .attr("width", width + margin.left + margin.right)      
    .attr("height", height + margin.top + margin.bottom)    
  .append("g")                                                               
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var axisGroup = mySVG.append("g").call( myAxis );</code></pre>
</p>
<p>
If we include in the margins and the scale, this is the full code we are going to use.
</p>
<p>
First we define the margin and the width and height of the inner SVG Container
</p>
<p>
Then we define the scale such that the range goes from 0 to the width of the inner container
</p>
<p>
Then we define the myAxis variable and pass the scale to it.
</p>
<p>
Then we define SVG Viewport Container
</p>
<p>
Within this SVG Viewport Container we define an SVG Group Element which will be the drawing surface.
</p>
<p>
This drawing surface is a SVG Group Element Transform Translated to provide room for the margins.
</p>
<p>
Finally, we call myAxis on the mySVG Group Element Selection.   
</p>
<br>
<p>
[ Image: D3 Axes ]
</p>
<p>
The code then gives us the Axes going from 0 to 10.
</p>
<p>
Now that we have this axis, there are a few things we can change in order to manipulate how it's displayed on the screen.
</p>
<p>
Let's tackle how we orient the axis.
</p>
<br>
<br>
<p>
<strong>
D3 Axis Orient
</strong>
</p>
<br>
<p>
<pre><code class="javascript">d3.svg.axis()
    .orient([orientation])</code></pre>
</p>
<p>
This "gets" or "sets" the position of the ticks and their labels in relation to the axis path.
</p>
<p>
That is on top or the bottom of the path line
</p>
<p>
Or on the left or right of the path line.
</p>
<p>
For the horizontal axis, the top or the bottom are the correct orientation.
</p>
<p>
For the vertical axis, the left or right are the correct orientation.
</p>
<p>
The default orientation is a horizontal axis with the bottom orientation.
</p>
<p>
This means the tick text falls beneath the SVG Path Line.
</p>
<br>
<p>
<pre><code class="javascript">d3.svg.axis()
    .orient([left or right])</code></pre>
</p>
<p>
One interesting thing that happens when you specify left or right is that D3 changes your axis from a horizontal axis to a vertical axis.
</p>
<p>
Which solves the issue of figuring out how to rotate ticks, lines and the path line so that it is vertical rather than horizontal.
</p>
<br>
</p>
<p>
<pre><code class="javascript">d3.svg.axis()
    .orient([orientation])</code></pre>
</p>
<p>
An important thing to note is that the Orient is orienting the text on either side of the path line.
</p>
<p>
IT IS NOT putting the axis on the left or right or top or bottom of the SVG Group Element Container you are calling it from.
</p>
<p>
For that to happen, you have to use the SVG Group Element Transform Translate to move the axis specifically how you want it.
</p>
<br>
<p>
Let's take a look in the JavaScript Console.
</p>
<br>
<p>
First, we enter all of the code to generate the original first axis.
</p>
<p>
<pre><code class="javascript">var margin = {top: 50, right: 50, bottom: 50, left: 50},
    width = 300 - margin.left - margin.right,           
    height = 300 - margin.top - margin.bottom;

var myScale = d3.scale.linear()
    .domain( [0, 10] )
    .range ( [0,width] );

var myAxis = d3.svg.axis().scale(myScale);

var mySVG = d3.select("body").append("svg")                 
    .attr("width", width + margin.left + margin.right)      
    .attr("height", height + margin.top + margin.bottom)    
  .append("g")                                                               
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var axisGroup = mySVG.append("g").call( myAxis );</code></pre>
</p>
<p>
You can see that the horizontal axis has been generated.
</p>
<p>
BROWSER - HIGHLIGHT THE var myAxis = d3.svg.axis().scale(myScale);
</p>
<p>
The d3.svg.axis command used the default orientation setting which is a horizontal axis with the orientation of bottom.
</p>
<br>
<p>
Let's delete the inner G element inside of the Transformed Translated G element.
</p>
<p>
BROWSER - Highlight the G element inside of the SVG Group Element that was transformed / translated
</p>
<p>
BROWSER - Press delete
</p>
<p>
In case you were not aware of this, when using Chrome developer tools, you can delete elements right from this window.
</p>
<p>
Just click on them and then press the delete key.
</p>
<p>
As you can see, this element is no longer there.
</p>
<br>
<p>
Now that the previous axis was removed, let's re-define the myAxis D3 SVG Axis component and this time give it an orientation of top.
</p>
<p>
<pre><code class="javascript">var myAxis = d3.svg.axis().scale(myScale).orient("top");</code></pre>
</p>
<br>
<p>
Next let's call axisGroup again so that we can append an SVG Group element to the transform translated Group element and call the myAxis on the selection
</p>
<p>
<pre><code class="javascript">var axisGroup = mySVG.append("g").call( myAxis );</code></pre>
</p>
<p>
This generates the horizontal axis element.
</p>
<p>
You can see that the tick text is above the axis line that connects all the tick marks.
</p>
<p>
This is what D3 means when the orientation is at the top.
</p>
<p>
Not that the axis shows up at the top of the SVG Container or Group element we are in, 
</p>
<p>
It means that the tick text is above the axis line.
</p>
<br>
<p>
Let's delete the inner G element again inside of the Transformed Translated G element to clear the drawing space.
</p>
<p>
BROWSER - Highlight the G element inside of the SVG Group Element that was transformed / translated
</p>
<p>
BROWSER - Press delete
</p>
<p>
As before, when using Chrome developer tools, you can delete elements right from this window.
</p>
<p>
Just click on them and then press the delete key.
</p>
<p>
As you can see, the axis with orientation of top is no longer there.
</p>
<br>
<p>
Now that the previous axis was removed, let's re-define the myAxis D3 SVG Axis component and this time give it an orientation of left.
</p>
<p>
<pre><code class="javascript">var myAxis = d3.svg.axis().scale(myScale).orient("left");</code></pre>
</p>
<p>
This will put the tick text on the left of the axis line.
</p>
<p>
Also, this will create the axis in a vertical manner.
</p>
<br>
<p>
Next let's call axisGroup again so that we can append an SVG Group element to the transform translated Group element and call the myAxis on the selection
</p>
<p>
<pre><code class="javascript">var axisGroup = mySVG.append("g").call( myAxis );</code></pre>
</p>
<p>
This generates the vertical axis element.
</p>
<p>
You can see that the tick text is to the left the axis line that connects all the tick marks.
</p>
<p>
This is what D3 means when the orientation is at the left.
</p>
<p>
Not that the axis shows up on the left of the SVG Container or Group element we are in, 
</p>
<p>
It means that the tick text is left of the axis line.
</p>
<p>
With this great shortcut and margins, we are able to generate a very good looking y-axis.
</p>
<p>
Note - since the SVG Coordinate space has the Y-axis inverted
</p>
<p>
That is as Y coordinates get bigger, they move towards the bottom of the chart,
</p>
<p>
We get the numbers increasing from zero to 10 as they move towards the bottom of the chart.
</p>
<br>
<p>
Let's delete the inner G element again inside of the Transformed Translated G element to clear the drawing space.
</p>
<p>
BROWSER - Highlight the G element inside of the SVG Group Element that was transformed / translated
</p>
<p>
BROWSER - Press delete
</p>
<p>
As before, when using Chrome developer tools, you can delete elements right from this window.
</p>
<p>
Just click on them and then press the delete key.
</p>
<p>
As you can see, the axis with orientation of left is no longer there.
</p>
<br>
<p>
Now that the previous axis was removed, let's re-define the myAxis D3 SVG Axis component and this time give it an orientation of right.
</p>
<p>
<pre><code class="javascript">var myAxis = d3.svg.axis().scale(myScale).orient("right");</code></pre>
</p>
<p>
This will put the tick text on the right of the axis line.
</p>
<p>
Also, this will create the axis in a vertical manner.
</p>
<br>
<p>
Next, let's call axisGroup again so that we can append an SVG Group element to the transform translated Group element and call the myAxis on the selection
</p>
<p>
<pre><code class="javascript">var axisGroup = mySVG.append("g").call( myAxis );</code></pre>
</p>
<p>
This generates the vertical axis element.
</p>
<p>
You can see that the tick text is to the right of the axis line that connects all the tick marks.
</p>
<p>
This is what D3 means when the orientation is at the right.
</p>
<p>
Not that the axis shows up at the right of the SVG Container or Group element we are in, 
</p>
<p>
It means that the tick text is right of the axis line.
</p>
<br>
<p>
Let's delete the inner G element again inside of the Transformed Translated G element to clear the drawing space.
</p>
<p>
BROWSER - Highlight the G element inside of the SVG Group Element that was transformed / translated
</p>
<p>
BROWSER - Press delete
</p>
<p>
As before, when using Chrome developer tools, you can delete elements right from this window.
</p>
<p>
Just click on them and then press the delete key.
</p>
<p>
As you can see, the axis with orientation of right is no longer there.
</p>
<br>
<p>
Now, let's create a vertical and horizontal axis to show what the SVG Coordinate space looks like.
</p>
<p>
The vertical axis will have the orientation of left
</p>
<p>
While the horizontal axis will have the orientation of top.
</p>
<p>
<pre><code class="javascript">var myXAxis = d3.svg.axis().scale(myScale).orient("top");

var myYAxis = d3.svg.axis().scale(myScale).orient("left");</code></pre>
</p>
<p>
This will put the tick text on the left of the Y-axis line
</p>
<p>
And the tick text on top of the X-axis line
</p>
<br>
<p>
Next, let's call axisXGroup and axisYGroup SVG Group elements containing the X-Axis and Y-Axis to the transform translated Group element
</p>
<p>
<pre><code class="javascript">var axisXGroup = mySVG.append("g").call( myXAxis );

var axisyGroup = mySVG.append("g").call( myYAxis );</code></pre>
</p>
<p>
This generated the vertical axis element and the horizontal axis elements.
</p>
<p>
You can see that the tick text is in the right place for both the x-axis and the y-axis.
</p>
<br>
<p>
<pre><code class="javascript">d3.svg.axis()
    .orient([orientation]);</code></pre>
</p>
<p>
And with that, you can see just how powerful the D3 SVG Axis Component can be, in generating vertical and horizontal axis for us.
</p>
<p>
It does all the math behind the scenes as long as we provide for it a scale with a domain and range
</p>
<p>
As well as an SVG Group Element it can live inside of.
</p>
<p>
And when we provide it with an orientation, is does the hard work of figuring out how and where to draw the axis for us.
</p>
        </div>
      </div>
    
    ☺</div>


<hr>
<h3 id="lesson33">D3 Scales For Data<h3>
    <div>
     <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>D3 provides three types of functions that map an input domain to an output range - Quantitative Scales (real numbers), Ordinal Scales (discreet domains), and Time Scales (JavaScript Date Objects)</li>
<li>All of the scale functions take in data and convert it to a usable set of output</li>
<li>The D3 Axis Component, d3.svg.axis(), displays reference lines, labeled ticks, and does the math to get equal space between the ticks for any D3 Scale you provide automatically</li>
<li>The D3 Axis Component is a function, so you have to pass it an argument in which it can do work on - this is always a D3 Selection inside of which it will generate the SVG Axis for us</li>
<li>The D3 Axis Component works with Quantitative Scales, Ordinal Scales, and Time Scales</li>
<li>Not only do you want to use the D3 Scales for making the Axes, you will also want to scale the data so that it the input data is properly scaled and placed within the data visualization</li>
<li>This means that you will want to use the D3 Scales when defining the attribute value pairs of DOM elements you create using the D3 Data Join</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/d3-scales">D3 Scales</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-scales-part-two">D3 Scales Part Two</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-scales-part-three">D3 Scales Part Three</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-data-operator">D3 Data Operator</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-update-selection">D3 Update Selection</a></li>
<li><a href="https://www.dashingd3js.com/lessons/binding-data-to-dom-elements">Binding Data to DOM Elements</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 Scales For Data
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
D3 Scales Revisited
</strong>
</p>
<br>
<p>
Quantitative Scales - for continuous input domains, such as numbers.
</p>
<p>
Ordinal Scales - for discrete input domains, such as names or categories.
</p>
<p>
Time Scales - for time domains.
</p>
<br>
<p>
D3 provides three types of functions that map an input domain to an output range.
</p>
<p>
The Quantitative scales are for real numbers
</p>
<p>
The Ordinal Scales are Discreet domains, such as letters of the alphabet
</p>
<p>
The Time Scales are an extension of the Quantitative Scales that use the JavaScript Date Objects.
</p>
<p>
All of these scales take in data and convert it to a useable set of output.
</p>
<br>
<p>
Quantitative Scales - Linear Scales
</p>
<br>
<p>
y = mx + b
</p>
<p>
D3 Quantitative Scales are for continuous input domains, such as Numbers and Time
</p>
<p>
The mapping is linear in that the output range value y can be expressed as a linear function of the input domain value x.
</p>
<p>
So we get y = mx + b
</p>
<p>
<pre><code class="javascript">d3.scale.linear()
    .domain( [0,400] )
    .range( [0,200] );</code></pre>
</p>
<p>
Rather than having to do this math ourselves, we can get D3 to do the math for us.
</p>
<p>
Using the D3 Scale Linear
</p>
<p>
We can tell D3 that the initial data covers 0 to 400
</p>
<p>
and we want it to cover 0 to 200 after it has been scaled.
</p>
<p>
This then figures out the correct math for the y=mx+b equation.
</p>
<p>
The initial data is entered in the domain.
</p>
<p>
and what we want the data to be scaled to is put into the range.
</p>
<br>
<p>
ℝ - Real Numbers
<br>
LINE 1: Domain
<br>
----------A---------B---------C---------
<br>
LINE 2: Range
<br>
----------D---------E---------F---------
</p>
<p>
The Domain is Line 1
</p>
<p>
The Range is Line 2
</p>
<p>
The Range is thus the result of the y=mx+b transformation from Line 1 to Line 2
</p>
<p>
The left most element in Line 1 gets transformed to the left most element in Line 2
</p>
<p>
And the right most element in Line 1 gets transformed to the right most element in Line 2
</p>
<p>
And the middle elements in line 1 get transformed to the middle elements in line 2.
</p>
<br>
<br>
<p>
<strong>
D3 Axes Component Revisited
</strong>
</p>
<br>
<p>
<pre><code class="javascript">d3.svg.axis()</code></pre>
</p>
<p>
The D3 axis component displays reference lines, labeled ticks and does the math to get equal space between the ticks for any scale we provide automatically.
</p>
<p>
The D3 axis component works with quantitative scales, time scales and even ordinal scales.
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg")
    .attr("width", 200)
    .attr("height",200)
  .append("g")
    .call( d3.svg.axis() );</code></pre>
</p>
<br>
<p>
This is the most basic way to add an axis to an SVG Container.
</p>
<p>
Notice that we use D3 to create the SVG Container
</p>
<p>
Then we add the width and height attribute to the SVG Container
</p>
<p>
Then we append an SVG Group Element
</p>
<p>
The SVG Group element will hold the D3 Axis Elements.
</p>
<p>
Finally we call the d3.svg.axis component.
</p>
<p>
We have to call the D3 Axis component to add the D3 Axis to the SVG Group Element.
</p>
<p>
The D3.svg.axis component is a function, so when we call it, we are passing to it the current selection.
</p>
<p>
The current selection being the SVG Group Element.
</p>
<p>
The D3.svg Axis Component does it's function thing and then returns a new selection.    
</p>
<br>
<p>
<pre><code class="javascript">var margin = {top: 50, right: 50, bottom: 50, left: 50},
    width = 300 - margin.left - margin.right,           
    height = 300 - margin.top - margin.bottom;

var myScale = d3.scale.linear()
    .domain( [0, 10] )
    .range ( [0,width] );

var myXAxis = d3.svg.axis().scale(myScale).orient("top");

var myYAxis = d3.svg.axis().scale(myScale).orient("left");

var mySVG = d3.select("body").append("svg")                 
    .attr("width", width + margin.left + margin.right)      
    .attr("height", height + margin.top + margin.bottom)    
  .append("g")                                                               
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var axisXGroup = mySVG.append("g").call( myXAxis );

var axisYGroup = mySVG.append("g").call( myYAxis );</code></pre>
</p>
<p>
Given D3 Margin Convention, D3 Scales and D3 Axis Components
</p>
<p>
We can put together this code to give us an inner drawing space in an SVG Container that has the well defined X and Y axes.
</p>
<p>
The axes taken into account the scale domain of the data we wanted
</p>
<p>
The axes also take into account the width and height of the inner SVG drawing space to make sure the axes cover the full width and height..
</p>
<p>
What is left to figure out is what to do and how to manipulate the data that will go inside.
</p>
<br>
<br>
<p>
<strong>
D3 Scales For Data
</strong>
</p>
<br>
<p>
<pre><code class="javascript">var myScale = d3.scale.linear()
    .domain( [0, 10] )
    .range ( [0,width] );</code></pre>
      # In the code before, we used this to setup the D3 Scale Function.
</p>
<p>
We told it the domain of the data was 0 to 10 and that it should be mapped to a range of 0 to the width
</p>
<p>
Which in this case was 200.
</p>
<br>
<p>
ℝ - Real Numbers
<br>
LINE 1: Domain
<br>
----------A---------B---------C---------
<br>
LINE 2: Range
<br>
----------D---------E---------F---------
</p>
<p>
Recalling how to think about the Domain and the Range
</p>
<p>
Where the Domain is Line 1
</p>
<p>
and the Range is Line 2
</p>
<p>
The data that we have lives on line 1.
</p>
<p>
Which means that if we want it to be represented in the scaled version of the world which is line 2
</p>
<p>
We also have to convert it using the scaling function.
</p>
<br>
<p>
<pre><code class="javascript">var dataSet = //...

elements = d3.select(...).selectAll(...).data(dataSet).enter().append(...)

elementAttributes = elements.attr(...,function(d,i) { return d; });
    .attr(...,function(d,i) { return d; })
    .attr(...,function(d,i) { return d; })
    .attr(...,function(d,i) { return d; });</code></pre>
</p>
<p>
In D3 Data Visualizations
</p>
<p>
There are usually two main places where we touch and/or manipulate the actual real data
</p>
<p>
One - when we define the data source
</p>
<p>
Two - when we tell D3 how to find the data that is bound to the DOM Elements
</p>
<p>
So if we were going to use a scale to manipulate the actual real data to fit into the scaled world we have two choices for where to manipulate the data.
</p>
<br>
<p>
It is really not a choice.
</p>
<p>
Once you receive or define the real data, leave it alone.
</p>
<p>
There may be more than one process that needs the actual real data, rather than the scaled data.
</p>
<p>
<pre><code class="javascript">var dataSet = //...

elements = d3.select(...).selectAll(...).data(dataSet).enter().append(...)

elementAttributes = elements.attr(...,function(d,i) { return d; });
    .attr(...,function(d,i) { return d; });</code></pre>
</p>
<p>
Which means, that if any scaling of the data is going to be done,
</p>
<p>
It should be done when we are taking the real data that is bound to the DOM Elements
</p>
<p>
and scaling it for the attributes of that element.
</p>
<br>
<p>
<pre><code class="javascript">var dataSet = //...
var myScale = d3.scale.linear()
    .domain( [0, 10] )
    .range ( [0,width] );

elements = d3.select(...).selectAll(...).data(dataSet).enter().append(...)

elementAttributes = elements.attr(...,function(d,i) { return myScale(d); })
    .attr(...,function(d,i) { return myScale(d); });</code></pre>
</p>
<p>
This makes sure that the real data is attached to the DOM Element.
</p>
<p>
However, the attribute data is the data that is scaled.
</p>
<p>
This is scaled to match the type of scaling that we want to happen in the data visualization.
</p>
<p>
Most of the time this means fitting inside of the SVG Container and SVG inner drawing space we have defined.
</p>
<br>
<p>
Let's take a look in the JavaScript Console   
</p>
<br>
<p>
First, we enter all of the code necessary for the SVG Viewport, the SVG Inner space and the Scale Function
</p>
<p>
<pre><code class="javascript">var margin = {top: 50, right: 50, bottom: 50, left: 50},
    width = 300 - margin.left - margin.right,           
    height = 300 - margin.top - margin.bottom;</code></pre>
</p>
<br>
<p>
Then we generate the scale which will be used for both axes elements as well as scaling the data later.
</p>
<p>
<pre><code class="javascript">var myScale = d3.scale.linear()
    .domain( [0,   10] )
    .range ( [0,width] );</code></pre>
</p>
<br>
<p>
We define the X-Axis and the Y-Axis functions, scale them and give them an orientation.
</p>
<p>
<pre><code class="javascript">var myXAxis = d3.svg.axis().scale(myScale).orient("top");

var myYAxis = d3.svg.axis().scale(myScale).orient("left");</code></pre>
</p>
<br>
<p>
Next, we define the SVG Viewport as well as the Inner Drawing Space
</p>
<p>
<pre><code class="javascript">var mySVG = d3.select("body").append("svg")                 
    .attr("width",  width  + margin.left + margin.right)      
    .attr("height", height + margin.top  + margin.bottom);

var innerSpace = mySVG.append("g")                                                               
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<br>
<p>
Next we call the X-Axis and Y-Axis functions to have them generate all the D3 Axis Components.
</p>
<p>
<pre><code class="javascript">var axisXGroup = innerSpace.append("g").call( myXAxis );

var axisyGroup = innerSpace.append("g").call( myYAxis );</code></pre>
</p>
<p>
BROWSER - Click into Body element
</p>
<p>
BROWSER - Click into SVG element
</p>
<p>
BROWSER - Click into G element
</p>
<p>
And there we go - we have now the full chart ready for us.
</p>
<br>
<p>
Next, let's define a data object to pass to the D3 Data Operator.
</p>
<p>
<pre><code class="javascript">var myDataPoint = [{"x":5, "y":5}];</code></pre>
</p>
<br>
<p>
Next, let's bind the data to an SVG Circle Element
</p>
<p>
<pre><code class="javascript">var circle = innerSpace.selectAll("circle")
    .data(myDataPoint)
  .enter().append("circle");</code></pre>
</p>
<p>
BROWSER - Click on the circle SVG element that was added
</p>
<p>
You can see that the Circle SVG element was added to the G Group that has the transform translate.
</p>
<p>
This G group is the inner drawing space.
</p>
<p>
The circle was added as the last child element, because this is how the D3 append operator works.
</p>
<p>
The circle does not appear on the screen because we have not define it's attributes.
</p>
<br>
<p>
First, let's define it's attributes without scaling the data.
</p>
<p>
<pre><code class="javascript">var circleAttributes = circle
    .attr("cx", function(d,i) { return d.x; })
    .attr("cy", function(d,i) { return d.y; })
    .attr("r", 5);</code></pre>
</p>
<p>
The attributes are defined based on the data that was bound to the SVG Circle element.
</p>
<p>
We use anonymous JavaScript functions to get out the relevant x and y values.
</p>
<p>
We set the radius to be 5.
</p>
<br>
<p>
When we press enter
</p>
<p>
BROWSER - Press Enter
</p>
<p>
You can see that the circle was created.
</p>
<p>
If we look at the elements section of the Chrome Developer Tools, we see that the 
</p>
<p>
CX is 5
</p>
<p>
the CY is 5
</p>
<p>
and the Radius is 5
</p>
<p>
Which is that the data told us.
</p>
<p>
However, when we look at the chart in the webpage, it currently looks like the circle's data
</p>
<p>
has a CX of something between 0 and 1
</p>
<p>
and has a CY of something between 0 and 1
</p>
<p>
This is because we did not scale the data when we defined the attributes of the circle.
</p>
<br>
<p>
Let's delete the Circle SVG element inside of the Transformed Translated G element to clear the drawing space.
</p>
<p>
BROWSER - Highlight the Circle element inside of the SVG Group Element that was transformed / translated
</p>
<p>
BROWSER - Press delete
</p>
<p>
When using Chrome developer tools, you can delete elements right from this window.
</p>
<p>
Just click on them and then press the delete key.
</p>
<p>
As you can see, the circle element is no longer there.
</p>
<br>
<p>
Let's bind the data to the SVG Circle Element and create the circle element again.
</p>
<p>
<pre><code class="javascript">var circle = innerSpace.selectAll("circle")
    .data(myDataPoint)
  .enter().append("circle");</code></pre>
</p>
<p>
BROWSER - Click on the circle SVG element that was added
</p>
<p>
You can see that the Circle SVG element was added to the G Group that has the transform translate.
</p>
<br>
<p>
This time, let's define it's attributes making sure to scale the data using the scaling function [ DON'T PRESS ENTER UNTIL NEXT PART]
</p>
<p>
<pre><code class="javascript">var circleAttributes = circle
    .attr("cx", function(d,i) { return myScale(d.x); })
    .attr("cy", function(d,i) { return myScale(d.y); })
    .attr("r", 5);</code></pre>
</p>
<p>
The attributes are defined based on the data that was bound to the SVG Circle element.
</p>
<p>
We use anonymous JavaScript functions to get out the relevant x and y values.
</p>
<p>
We set the radius to be 5.
</p>
<p>
This time however, we use the scaling function to scale the real data to a scaled version of the data
</p>
<p>
This scaled version of the data will match the scaling applied to the X-axis and the Y-axis.
</p>
<br>
<p>
When we press enter
</p>
<p>
BROWSER - Press Enter
</p>
<p>
You can see that the circle was created.
</p>
<p>
If we look at the elements section of the Chrome Developer Tools, we see that the 
</p>
<p>
CX is 100
</p>
<p>
the CY is 100
</p>
<p>
and the Radius is 5
</p>
<p>
Which is what we would expect given that we used the scaling function.
</p>
<p>
The scaling function took the numbers in the domain and multiplied them by 20 to get the range.
</p>
<p>
So the cx equals 5 and cy equals 5 from before have been scaled to cx equals 100 and cy equals 100.
</p>
<p>
Which is great because now the Graph Axis and the Data plotted on the graph actually show the same thing.
</p>
<p>
That the data point has an X value of 5 and a Y value of 5.
</p>
<p>
<pre><code class="javascript">elementAttributes = elements
    .attr(...,function(d,i) { return scaleFunction(d); })
    .attr(...,function(d,i) { return scaleFunction(d); });</code></pre>
</p>
<br>
<p>
And with that, you can see just how easy and useful it can be to scale the data when setting attributes.
</p>
<p>
It helps to make sure the data attributes are scaled in the same way that the axis attributes have been.
</p>
<p>
The D3 Scale function does all the math behind the scenes as long as we provide for it a scale with a domain and range.
</p>
        </div>
      </div>
    
    ☺</div>



<hr>
<h3 id="lesson34">Putting It All Together<h3>
    <div>
        <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>When constructing a D3 data visualization, start with the data</li>
<li>Then figure out what attributes of the data you are going to visualize</li>
<li>Then choose what type of visualization you are going to make</li>
<li>Then choose the dimensions of where you will make the visualization</li>
<li>Then create the scales for the visualization, in this case - the X and Y axis scales</li>
<li>Then define the Axes for the X and Y axis</li>
<li>Then decide on the data representation, in this case - a circle will represent data elements</li>
<li>Then define attributes for the visual data representation</li>
<li>Then add text labels</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/d3-data-operator">D3 Data Operator</a></li>
<li><a href="https://www.dashingd3js.com/lessons/binding-data-to-dom-elements">Binding Data to DOM Elements</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-axes">D3 Axes</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-axes-manipulation">D3 Axes Manipulation</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-scales-for-data">D3 Scales For Data</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            Putting It All Together
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
Data
</strong>
</p>
<br>
<p>
<pre><code class="javascript">dataSet = [{"name":"Shanghai"        , "population":18, "rank": 1},
           {"name":"Guangzhou"       , "population":11, "rank":10},
           {"name":"Dongguan"        , "population": 8, "rank":20},
           {"name":"Cairo"           , "population": 7, "rank":30},
           {"name":"Saint Petersburg", "population": 5, "rank":40},
           {"name":"New Taipei"      , "population": 4, "rank":50}];</code></pre>
</p>
<p>
We define a data set that contains text and numbers.
</p>
<p>
This data set is based on the top 50 largest cities in the world and their population as measured in Millions according to Wikipedia.
</p>
<p>
For now, we design a super basic data visualization.
</p>
<p>
We will create circles where the radius is based on the population in millions.
</p>
<p>
Then we will add the name of the city next to the circle.
</p>
<p>
We position the circles on the graph based on their index number.
</p>
<br>
<br>
<p>
<strong>
Initial Visualization Decision
</strong>
</p>
<br>
<p>
<pre><code class="javascript">dataSet = [{"name":"Shanghai"        , "population":18, "rank": 1},
           {"name":"Guangzhou"       , "population":11, "rank":10},
           {"name":"Dongguan"        , "population": 8, "rank":20},
           {"name":"Cairo"           , "population": 7, "rank":30},
           {"name":"Saint Petersburg", "population": 5, "rank":40},
           {"name":"New Taipei"      , "population": 4, "rank":50}];</code></pre>
</p>
<p>
Given the data set, we have three possible variables
</p>
<p>
Population
</p>
<p>
Rank
</p>
<p>
and Name of the city
</p>
<p>
Given that population and rank are both numbers, it will be easiest to start there
</p>
<p>
Which variable is dependent and which variable is independent?
</p>
<p>
The rank variable is dependent on the population variable
</p>
<p>
The bigger the population, the higher the rank
</p>
<p>
So Rank should be the Y axis and Population should be the X axis
</p>
<br>
<p>
[ Image: SVG Coordinate Space ]
</p>
<p>
For now, we will stay in the SVG Coordinate space
</p>
<p>
So if Rank should be the Y axis and Population should be the X axis
</p>
<p>
Then what kind of line should we get?
</p>
<br>
<p>
[ Image: Final Output of the Data Visualization ]
</p>
<p>
When we are done building the data visualization, this is what it will look like.
</p>
<p>
Shanghai will be at the top right
</p>
<p>
While New Taipei will be at the bottom left.
</p>
<p>
Let's go over the steps before we do it in the JavaScript Console.
</p>
<br>
<br>
<p>
<strong>
SVG Viewport and Margins
</strong>
</p>
<br>
<p>
SVG Viewport => 300 x 300
<br>
margins: 50 on each side
</p>
<p>
To make the data visualization fit into the screen so that we can show the Chrome Developer Tools, we choose the SVG Viewport dimensions as 300x300
</p>
<p>
Then we choose margins of 50 on each side to give plenty of room to the Chart and the axis we will draw.
</p>
<p>
The SVG Viewport and Margins will then help define the inner drawing space.
</p>
<br>
<p>
<pre><code class="javascript">var svgViewport = d3.select("body").append("svg").attr("width",300).attr("height",300);
var margin = {top: 50, right: 50, bottom: 50, left: 50},
    width = 300 - margin.left - margin.right,           
    height = 300 - margin.top - margin.bottom;

var innerSpace = svgViewport.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
Having decided on the SVG Viewport Dimensions and Margins
</p>
<p>
JavaScript variables and selections are defined so that we have the Viewport, the margins object and the innerSpace.
</p>
<br>
<br>
<p>
<strong>
Scale Data - Set the Domain
</strong>
</p>
<br>
<p>
<pre><code class="javascript">dataSet = [{"name":"Shanghai"        , "population":18, "rank": 1},
           {"name":"Guangzhou"       , "population":11, "rank":10},
           {"name":"Dongguan"        , "population": 8, "rank":20},
           {"name":"Cairo"           , "population": 7, "rank":30},
           {"name":"Saint Petersburg", "population": 5, "rank":40},
           {"name":"New Taipei"      , "population": 4, "rank":50}];</code></pre>
</p>
<p>
rank - Y-Axis
<br>
population - X-Axis
</p>
<p>
We have to define what the scales of the data set will be
</p>
<p>
Rank as the Y-Axis starts near enough to zero that we can say zero to make the graph look clean because it starts at the origin
</p>
<p>
With the Rank increasing to 50, we can make it 50 for a nice round number.
</p>
<p>
Population as the the X-Axis starts near enough to zero that we can say zero to make the graph look clean because it starts at the origin
</p>
<p>
With the population increasing to almost 18, we can make it 20 for a nice round number.
</p>
<p>
Note - we could use the D3 extent formulas here to get the max and min.
</p>
<p>
We do not use them to keep things simple.
</p>
<br>
<p>
rank - Y-Axis
<br>
population - X-Axis
</p>
<p>
<pre><code class="javascript">var yAxisScale = d3.scale.linear().domain([0,50]);

var xAxisScale = d3.scale.linear().domain([0,20]);</code></pre>
</p>
<p>
Knowing the min and max of the X and Y coordinates, we can set the domain of the scale.
</p>
<br>
<br>
<p>
<strong>
Scale Data - Set the Range
</strong>
</p>
<br>
<p>
<pre><code class="javascript">var svgViewport = d3.select("body").append("svg").attr("width",300).attr("height",300);

var margin = {"top": 50, "right": 50, "bottom": 50, "left": 50};

var innerSpace = svgViewport
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var yAxisScale = d3.scale.linear().domain([0,50]);

var xAxisScale = d3.scale.linear().domain([0,20]);</code></pre>
</p>
<p>
Now that we have the domain of the scale, we have to set the range of the scale.
</p>
<p>
Given the svgViewport, margins and inner drawing space, we can set the Range of the scale easily.
</p>
<p>
The inner drawing space width is 300 units minus the left margin which is 50 minus the right margin which is 50
</p>
<p>
So the inner drawing space width is 200 units.
</p>
<p>
So the range of the xAxisScale should be 0 to 200.
</p>
<p>
The inner drawing space height is 300 units minus the top margin which is 50 minus the bottom margin which is 50
</p>
<p>
So the inner drawing space height is 200 units.
</p>
<p>
So the range of the yAxisScale should be 0 to 200.
</p>
<br>
<p>
rank - Y-Axis
<br>
population - X-Axis
</p>
<p>
<pre><code class="javascript">var yAxisScale = d3.scale.linear().domain([0,50]).range([0,200]);

var xAxisScale = d3.scale.linear().domain([0,20]).range([0,200]);</code></pre>
</p>
<p>
Knowing what the range should be let's redefine the xAxisScale and the yAxisScale
</p>
<p>
Now we have the full scaling function necessary for the data visualization.
</p>
<br>
<br>
<p>
<strong>
Define and Call the Axes
</strong>
</p>
<br>
<p>
<pre><code class="javascript">var myXAxis = d3.svg.axis().scale(xAxisScale).orient("top");

var myYAxis = d3.svg.axis().scale(yAxisScale).orient("left");</code></pre>
</p>
<p>
We define the X-Axis and the Y-Axis functions, scale them and give them an orientation.
</p>
<p>
The x-axis will be horizontal.
</p>
<p>
The y-axis will be vertical.
</p>
<p>
Note that we have to use different scale functions for the different axes because they cover different domains.
</p>
<br>
<p>
<pre><code class="javascript">var axisXGroup = innerSpace.append("g").call( myXAxis );

var axisyGroup = innerSpace.append("g").call( myYAxis );</code></pre>
</p>
<p>
Then we have to call the d3.svg.axis functions for the x axis group and the y axis groups
</p>
<p>
This will create the axis components in the inner space.
</p>
<br>
<br>
<p>
<strong>
Data Representation      
</strong>
</p>
<br>
<p>
<pre><code class="javascript">dataSet = [{"name":"Shanghai"        , "population":18, "rank": 1},
           {"name":"Guangzhou"       , "population":11, "rank":10},
           {"name":"Dongguan"        , "population": 8, "rank":20},
           {"name":"Cairo"           , "population": 7, "rank":30},
           {"name":"Saint Petersburg", "population": 5, "rank":40},
           {"name":"New Taipei"      , "population": 4, "rank":50}];</code></pre>
</p>
<p>
Next, we have to decide how each of these data points is going to be represented
</p>
<p>
To remove clutter and make it easy to see, let's treat this visualization like a scatter plot.
</p>
<p>
Each data point will be a small circle
</p>
<p>
Each circle will have the same radius as the others
</p>
<p>
Each circle will be black.
</p>
<br>
<p>
SVG Circles
</p>
<p>
D3 Circles
</p>
<p>
These are both things we know how to add and represent given data, so that is what we'll do.
</p>
<p>
We'll bind data to the elements and the create SVG Circle Elements.
</p>
<br>
<br>
<p>
<strong>
Binding Data to SVG Elements
</strong>
</p>
<br>
<p>
<pre><code class="javascript">var circles = innerSpace.append("g").selectAll("circle").data(dataSet).enter().append("circle");</code></pre>
</p>
<p>
First, we append an SVG Group element because we want to group all of the circle elements together.
</p>
<p>
Here we use the D3 pattern
</p>
<p>
We select the SVG space we are going to use
</p>
<p>
We selectAll the element we want to add
</p>
<p>
We bind the data to it
</p>
<p>
We select the enter selection as there were no circles in this particular selection before
</p>
<p>
Then we merge the placeholder JavaScript objects with SVG Circle elements.
</p>
<p>
This binds the data, but does not create the circles as we have not provided attributes to the circles yet
</p>
<p>
Next, let's provide attributes to the circles to make sure they appear.
</p>
<br>
<br>
<p>
<strong>
Adding Attributes to SVG Elements
</strong>
</p>
<br>
<p>
<pre><code class="javascript">var circleAttributes = circles.attr("cx",...).attr("cy",...).attr("r",5);</code></pre>
</p>
<p>
Next we add attributes to the circles to make sure they appear correctly.
</p>
<p>
We also do it in a way that produces scaled data points from the real data.
</p>
<p>
We use the scale function for this.
</p>
<p>
Note - we have a different scaling function for each X and Y axis, so we need to make sure we use the right one.
</p>
<br>
<p>
<pre><code class="javascript">var yAxisScale = d3.scale.linear().domain([0,50]);

var xAxisScale = d3.scale.linear().domain([0,20]);</code></pre>
</p>
<p>
This is important to pay attention to - when you have a different scale for the x and y axis,
</p>
<p>
you need to make sure you use the right one when defining attributes and setting their values.
</p>
<p>
For circles
</p>
<p>
- the CX values will use the xAxisScale function
</p>
<p>
- the CY Values will use the yAxisScale function
</p>
<p>
and if available, the radius could also use a scaling function.
</p>
<p>
The example we are building does not vary the radius, so it is constant for all the circles.      
</p>
<br>
<p>
<pre><code class="javascript">var yAxisScale = d3.scale.linear().domain([0,50]);

var xAxisScale = d3.scale.linear().domain([0,20]);

var circleAttributes = circles
    .attr("cx", function(d,i) { return xAxisScale(d.population); })
    .attr("cy", function(d,i) { return yAxisScale(d.rank); })
    .attr("r",5);</code></pre>
</p>
<p>
The xAxisScale is used to scale the bound data for the cx point
</p>
<p>
In this case, the population is the x-axis variable, so we use the dot notation to get the population value out of the JSON object
</p>
<p>
The yAxisScale is used to scale the bound data for the cy point
</p>
<p>
In this case, the rank is the y-axis variable, so we use the dot notation to get the rank value out of the JSON object
</p>
<p>
At this point, you would be able to see each circle on the chart and how it corresponds to the X-axis and the Y-Axis.
</p>
<p>
What's missing now are some text labels to tell us what city name belongs to which dot.
</p>
<br>
<br>
<p>
<strong>
Adding Text Labels
</strong>
</p>
<br>
<p>
<pre><code class="javascript">var text = innerSpace.append("g").selectAll("text").data(dataSet).enter().append("text");</code></pre>
</p>
<p>
First, we append an SVG Group element because we want to group all of the text elements together.
</p>
<p>
Like the circle example, we use the Inner Drawing Space to selectAll SVG text elements,
</p>
<p>
Bind the data set to them
</p>
<p>
Choose the enter selection
</p>
<p>
And then append SVG Text Elements which merge with the JavaScript Object Placeholder elements
</p>
<br>
<p>
<pre><code class="javascript">textAttributes = text.attr("x",...).attr("y",...).attr("text",...);</code></pre>
</p>
<p>
Then we have to set the attributes.
</p>
<p>
Just like the circle attributes, we have to define the x and y coordinates of where the text will live
</p>
<p>
Also - we have to define the text that goes into the text element.
</p>
<p>
The x and y coordinates will be pulled out of the JSON object that was bound to the text element.
</p>
<br>
<p>
<pre><code class="javascript">var textAttributes = text
    .attr("x", function(d,i) { return xAxisScale(d.population); })
    .attr("y", function(d,i) { return yAxisScale(d.rank); })
    .text(function(d,i) { return d.name; });</code></pre>
</p>
<p>
The text attributes will be the x and y coordinates and the text.
</p>
<p>
The x coordinate is the scaled population
</p>
<p>
The y coordinate is the scaled rank
</p>
<p>
The actual text of the SVG Text element is the name of the city.
</p>
<br>
<p>
<pre><code class="javascript">var textAttributes = text
    .attr("x", function(d,i) { return xAxisScale(d.population); })
    .attr("y", function(d,i) { return yAxisScale(d.rank); })
    .text(function(d,i) { return d.name; })
    .style("fill","red");</code></pre>
</p>
<p>
We add a red color to the text so that it will be different from the black dots.
</p>
<p>
And with that we have all of the information necessary to create the data visualization.
</p>
<br>
<br>
<p>
<strong>
JavaScript Console Example
</strong>
</p>
<br>
<p>
First, we define the data set we will be using.
</p>
<p>
<pre><code class="javascript">dataSet = [{"name":"Shanghai"        , "population":18, "rank": 1},
           {"name":"Guangzhou"       , "population":11, "rank":10},
           {"name":"Dongguan"        , "population": 8, "rank":20},
           {"name":"Cairo"           , "population": 7, "rank":30},
           {"name":"Saint Petersburg", "population": 5, "rank":40},
           {"name":"New Taipei"      , "population": 4, "rank":50}];</code></pre>
</p>
<p>
You can see that it returns an array of 6 objects.
</p>
<p>
We will later bind each of these objects to an SVG Circle Element.
</p>
<br>
<p>
Next, we define the SVG Viewport
</p>
<p>
<pre><code class="javascript">var svgViewport = d3.select("body").append("svg").attr("width",300).attr("height",300);</code></pre>
</p>
<p>
The width and height are defined in such a way as to make sure it fits into the window so that the Chrome Developer Tools are visible.
</p>
<p>
BROWSER - Click into the Body element
</p>
<p>
BROWSER - Click on the SVG Element
</p>
<p>
Here you can see the dimensions of the SVG Viewport Container on the screen.
</p>
<br>
<p>
Next, we define the margins per D3 Margin Convention
</p>
<p>
<pre><code class="javascript">var margin = {top: 50, right: 50, bottom: 50, left: 50},
    width  = 300 - margin.left - margin.right,           
    height = 300 - margin.top  - margin.bottom;</code></pre>
</p>
<p>
Noting that the width and height are going to be used as the definitions of the width and height of the inner drawing space.
</p>
<br>
<p>
Next, we define the inner drawing space
</p>
<p>
<pre><code class="javascript">var innerSpace = svgViewport
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
BROWSER - Click into the G Element.
</p>
<p>
First we attach an SVG Group element to the SVG Viewport
</p>
<p>
Then we transform translate this group element by the margin left and by the margin top
</p>
<p>
This moves the inner drawing space 50 units to the right and 50 units down
</p>
<p>
You can think of this being where the new coordinate space is defined that will house the data visualization.
</p>
<br>
<p>
Next, we define the X-Axis Scale and the Y-Axis scale
</p>
<p>
<pre><code class="javascript">var xAxisScale = d3.scale.linear().domain([0,20]).range([0,200]);

var yAxisScale = d3.scale.linear().domain([0,50]).range([0,200]);</code></pre>
</p>
<p>
The x-axis scale is based on the x axis values which represent the population size of the city.
</p>
<p>
The range for both scales is 200 because that is the height and width of the SVG inner drawing space
</p>
<br>
<p>
Next, we define the circles that will be created in the inner drawing space.      
</p>
<p>
<pre><code class="javascript">var circles = innerSpace.append("g")
    .selectAll("circle")
    .data(dataSet)
  .enter().append("circle");</code></pre>
</p>
<p>
BROWSER - Click into the G transform translate element to see what's inside
</p>
<p>
BROWSER - Click into the G element inside to see all of the circles.
</p>
<p>
We attach an SVG Group Element to the inner drawing space in order to hold all of the circle elements
</p>
<p>
Then we bind the data, select the enter selection and merge the placeholder elements with the SVG Circle Elements.
</p>
<p>
As you can see, there are now 6 circle elements in their own group element inside of the inner drawing space group element.
</p>
<br>
<p>
Next, we give each circle cx, cy and radius attributes to make them appear on the screen.
</p>
<p>
<pre><code class="javascript">var circleAttributes = circles
    .attr("cx", function(d,i) { return xAxisScale(d.population);})
    .attr("cy", function(d,i) { return yAxisScale(d.rank      );})
    .attr("r",5);</code></pre>
</p>
<p>
BROWSER - click on the first SVG circle
</p>
<p>
We use anonymous functions as well as the scaling functions to take in the data that was bound to each circle to add the values to the attributes.
</p>
<p>
You can now see the 6 circle elements.
</p>
<p>
You can also see that the CX variable has been scaled up so that the first circle's CX attribute is 180.
</p>
<p>
The x data point for the first circle was 18, so you can see that the x scaling function is multiplying the domain numbers by 10 to get the range numbers.
</p>
<br>
<p>
Now that we have the circles, let's define the axis elements so that we can build the axes.
</p>
<p>
<pre><code class="javascript">var myXAxis = d3.svg.axis().scale(xAxisScale).orient("top");

var myYAxis = d3.svg.axis().scale(yAxisScale).orient("left");</code></pre>
</p>
<br>
<p>
Next, let's call the axis elements so that they create all of the necessary axes elements for us.
</p>
<p>
<pre><code class="javascript">var axisXGroup = innerSpace.append("g").call( myXAxis );

var axisyGroup = innerSpace.append("g").call( myYAxis );</code></pre>
</p>
<p>
You can see that D3 has created the horizontal x axis for us as well as a vertical y axis for us.
</p>
<br>
<p>
If we close the SVG Group Element that contained the circles
</p>
<p>
BROWSER - Close the SVG Group Element containing the circles
</p>
<p>
BROWSER - Hover over the first group element
</p>
<p>
BROWSER - Hover over the second group element
</p>
<p>
BROWSER - Hover over the third group element
</p>
<p>
You can see that there are three SVG Group Elements within the inner drawing space Group Element.
</p>
<p>
As we hover over each one of the group elements, you can see can see that
</p>
<p>
The First group element encapsulates all of the circles
</p>
<p>
The Second group element encapsulates all of the horizontal x-axis elements
</p>
<p>
and The Third group element encapsulates all of the vertical y-axis elements
</p>
<p>
This is useful in case we want to move or translate the axis elements or to apply certain attributes to all of the elements of one of the SVG group elements.
</p>
<br>
<p>
Lastly, let's add the text to the data visualization.
</p>
<p>
<pre><code class="javascript">var text = innerSpace.append("g")
    .selectAll("text")
    .data(dataSet)
  .enter().append("text");</code></pre>
</p>
<p>
BROWSER - Hover over the fourth group element
</p>
<p>
BROWSER - Click into the fourth group element
</p>
<p>
We attach an SVG Group Element to the inner drawing space in order to hold all of the text elements for the circle labeling.
</p>
<p>
Then we bind the data, select the enter selection and merge the placeholder elements with the SVG Text Elements.
</p>
<p>
As you can see, there are now 6 text elements in their own group element inside of the inner drawing space group element.
</p>
<p>
Also - notice that we added another group element which holds all of the text elements.
</p>
<p>
This was appended as the last child element in the inner drawing space as this is how the append command works.
</p>
<br>
<p>
Finally, let's add the text attributes so that the text actually appears.
</p>
<p>
<pre><code class="javascript">var textAttributes = text
    .attr("x", function(d,i) { return xAxisScale(d.population); })
    .attr("y", function(d,i) { return yAxisScale(d.rank      ); })
    .text(     function(d,i) { return            d.name       ; })
    .style("fill","red");</code></pre>
</p>
<p>
We use anonymous functions as well as the scaling functions to take in the data that was bound to each text element in order to add the values to the attributes.
</p>
<p>
You can now see the 6 text elements.
</p>
<br>
<p>
And there you go, you can see the full data visualization based on the original data.
</p>
<p>
We were able to use D3 to add the horizontal x-axis, the vertical y-axis, the circles and have them correctly scaled for the graph, as well as the text labels.
</p>
        </div>
      </div>
    ☺</div>


<hr>
<h3 id="lesson36">JavaScript Callback Functions<h3>
    <div>
     <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>A JavaScript function is a block of code that will be executed when you call it</li>
<li>Because JavaScript functions are first-class objects, you can pass functions to other functions as variables</li>
<li>The method of passing in functions as parameters to other functions to use them inside is used in JavaScript libraries almost everywhere</li>
<li>A JavaScript Callback Function is a function that is passed as a parameter to another JavaScript function, and the callback function is run inside of the function it was passed into</li>
<li>JavaScript Callback Functions can be used synchronously or asynchronously</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/introduction-to-javascript">Introduction to JavaScript</a></li>
<li><a href="https://www.dashingd3js.com/lessons/javascript-functions">JavaScript Functions</a></li>
<li><a href="https://www.dashingd3js.com/lessons/really-simple-http-server-with-python">Really Simple HTTP Server with Python</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            JavaScript Callback Functions
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
Passing JavaScript Functions as Variables Revisited
</strong>
</p>
<br>
<p>
<pre><code class="javascript">function functionName() {
    // some code	
}</code></pre>
</p>
<p>
This is a JavaScript Function
</p>
<p>
A function is a block of code that will be executed when you call it
</p>
<p>
A function is written as a code block inside curly { } braces, preceded by the function keyword
</p>
<p>
The code inside the function will be executed when you call the function

</p>
<br>
<p>
<pre><code class="javascript">function functionName(var1, var 2) {
    // some code
}</code></pre>

functionName(argument1, argument2);</code></pre>
</p>
<p>
When you call a function, you can pass along some values to it, these values are called arguments or parameters.
</p>
<p>
These arguments can then be used inside of the function.
</p>
<p>
You can send as many arguments as you like, separated by commas (,)
</p>
<p>
To use the arguments inside of the function, you must declare the arguments as variables when defining the function
</p>
<p>
The variables and arguments must be in expected order.
</p>
<p>
That is, the first argument gets assigned to the first variable.
</p>
<br>
<p>
<pre><code class="javascript">function functionOne(x) { return x; };

function functionTwo(var1) {
    // some code
}

functionTwo(functionOne);</code></pre>
</p>
<p>
Because you can assign functions to variables, and because functions are objects in JavaScript, you can pass functions to other functions as variables
</p>
<p>
Which means that in this case, we are passing functionOne as a variable to be used inside of functionTwo
</p>
<p>
Inside of functionTwo, var1's value will be functionOne
</p>
<p>
This is how you can pass functions to other functions in JavaScript.
</p>
<p>
In this case, functionTwo can use functionOne inside of it.
</p>
<br>
<br>
<p>
<strong>
JavaScript Callback Functions
</strong>
</p>
<br>
<p>
<pre><code class="javascript">function functionOne(x) { return x; };

function functionTwo(var1) {
    // some code
}

functionTwo(functionOne);</code></pre>
</p>
<p>
This method of passing in functions to other functions to use them inside is used in JavaScript libraries almost everywhere.
</p>
<p>
The common name for the function passed in is a callback function.
</p>
<p>
In computer programming, a callback is a piece of executable code that is passed as an argument to other code, which is expected to call back (execute) the argument at some convenient time.
</p>
<p>
The invocation may be immediate as in a synchronous callback or it might happen at later time, as in an asynchronous callback.
</p>
<p>
We will come back to synchronous and asynchronous callbacks in another video.
</p>
<br>
<p>
<pre><code class="javascript">function functionOne(x) { alert(x); }

function functionTwo(var1, callback) {
    callback(var1);		
}

functionTwo(2, functionOne);</code></pre>
</p>
<p>
This is an example of using the callback variable in a JavaScript Function.
</p>
<p>
Function One takes in an argument and issues an alert with the x as it's argument.
</p>
<p>
Function Two takes in an argument and a function.
</p>
<p>
Function Two then passes the argument it took in to the function it took in.
</p>
<p>
Function One is the callback function in this case.
</p>
<br>
<p>
<p>
As JavaScript has anonymous functions available, you can also pass in anonymous Functions as a variable to a function.
</p>
<pre><code class="javascript">function functionTwo(var1, callback) {
    callback(var1);		
}

functionTwo(1, function (x) { alert(x); })</code></pre>
</p>
<p>
In this case, the callback function is defined when we are calling functionTwo.
</p>
<br>
<p>
Note that we can call the callback function inside of functionTwo as many times as we like.
</p>
<p>
<pre><code class="javascript">function functionTwo(var1, callback) {
    callback(var1);	
    callback(var1);	
}

functionTwo(1, function (x) { alert(x); })</code></pre>
</p>
<p>
There is no limit to how many times we can call it.
</p>
<br>
<p>
The other thing to pay attention to is that you can pass in as many callback functions as you like to another function.
</p>
<p>
<pre><code class="javascript">function functionTwo(var1, var2, callback1, callback2) {
    callback1(var1);	
    callback2(var2);	
}

functionTwo(1, 2, function (x) { alert(x); }, function (x) { alert(x); })</code></pre>
</p>
<p>
Here in function two we pass in two variables and two functions as arguments.
</p>
<p>
Inside of function two, we run callback1 with variable 1 and we run callback2 with variable 2.
</p>
<br>
<p>
Let's take a look at the code in the JavaScript Console to see how it functions.
</p>
<br>
<p>
First we start in the browser with the Developer tools open and the JavaScript Console ready to go.
</p>
<p>
<pre><code class="javascript">function functionOne(x) { alert(x); }</code></pre>
</p>
<p>
FunctionOne is defined so that it emits an alert with the value of the argument that got passed into it.
</p>
<br>
<p>
Let's test it
</p>
<p>
<pre><code class="javascript">functionOne(2);</code></pre>
</p>
<p>
BROWSER - Click on the Okay button
</p>
<p>
Function One alerts us with the number 2.
</p>
<br>
<p>
Next, let's define function two so that it alerts us as well.
</p>
<p>
<pre><code class="javascript">function functionTwo(x) { alert(x); }</code></pre>
</p>
<p>
FunctionTwo is defined so that emits an alert with the value of the argument that got passed into it.
</p>
<p>
It has the exact same functionality as functionOne.
</p>
<br>
<p>
We test it with the number two.
</p>
<p>
<pre><code class="javascript">functionTwo(2);</code></pre>
</p>
<p>
BROWSER - Click on the Okay button
</p>
<p>
Function Two alerts us with the number 2.
</p>
<p>
This is expected because it's the same functionality as function one.
</p>
<br>
<p>
Let's rewrite the definition of functionTwo so that it takes in a variable and a function.
</p>
<p>
Then it will pass the variable to the function that was passed in.
</p>
<p>
<pre><code class="javascript">function functionTwo(var1, callback) { callback(var1); }</code></pre>
</p>
<p>
We name the function being passed into functionTwo callback.
</p>
<br>
<p>
Let's test it by passing the number 2 and the functionOne function
</p>
<p>
<pre><code class="javascript">functionTwo(2, functionOne);</code></pre>
</p>
<p>
BROWSER - Click on the Okay button
</p>
<p>
It works the same as before.
</p>
<p>
Function Two alerts us with the number 2.
</p>
<p>
This time however, instead of functionTwo having the alert command inside of it, it used the command inside of functionOne.
</p>
<br>
<p>
Let's test it a different way this time.
</p>
<p>
We continue passing in the number 2, except this time instead of passing in the functionOne function, we pass in an anonymous function.
</p>
<p>
<pre><code class="javascript">functionTwo(2, function(x) { alert(x); });</code></pre>
</p>
<p>
BROWSER - Click on the Okay button
</p>
<p>
It works the same as before.
</p>
<p>
Function Two alerts us with the number 2.
</p>
<p>
This time however, instead of functionTwo having the alert command inside of it, it used the command inside of the anonymous function we passed in.
</p>
<br>
<p>
Let's rewrite the definition of functionTwo so that it takes in a variable and two functions.
</p>
<p>
<pre><code class="javascript">function functionTwo(var1, callback1, callback2) {
    callback1(var1);
    callback2(var1);
}</code></pre>
</p>
<p>
Function two now takes in one variable and two functions.
</p>
<p>
We name the functions being passed into functionTwo callback1 and callback2.
</p>
<p>
It then passes this variable to the first function - callback1.
</p>
<p>
It then passes this variable to the second function - callback2.
</p>
<br>
<p>
Let's test it by passing the number 2 and the functionOne function in twice
</p>
<p>
<pre><code class="javascript">functionTwo(2, functionOne, functionOne);</code></pre>
</p>
<p>
BROWSER - Click on the Okay button
</p>
<p>
It works the same as before for each function.
</p>
<p>
Function Two alerts us with the number 2 then alerts us with the number 2 again.
</p>
<br>
<p>
Finally, Let's test it by passing the number 2, the functionOne function and an anonymous function.
</p>
<p>
The anonymous function will alert the result of adding two to the number that was passed into it.
</p>
<p>
<pre><code class="javascript">functionTwo(2, functionOne, function(x) { alert(x+2); });</code></pre>
</p>
<p>
BROWSER - Click on the Okay button
</p>
<p>
First we get the alert of the number 2.
</p>
<p>
Then we get the alert of the number 4.
</p>
<br>
<p>
And with that we have covered what JavaScript Callback Functions are and how they can be used.
</p>
<p>
This will let us explore topics like AJAX, how D3 does asynchronous requests to the server and how we can use callback functions to manipulate the data after D3 receives it and parses it for us.
</p>
        </div>
      </div>
    ☺</div>


<hr>
<h3 id="lesson37">D3 Requests<h3>
<div>
    <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>JavaScript is single-threaded, that is - it processes one command at a time</li>
<li>Because JavaScript is single-threaded, the ability to do Asynchronous Function calls makes it less susceptible to slow down programs, especially when dealing with a client and server</li>
<li>AJAX, an acronym for Asynchronous JavaScript and XML, is a group of interrelated web development techniques used on the client-side to create asynchronous web applications</li>
<li>AJAX lets web applications send and retrieve data from a server asynchronously, in the background, without interfering with the display and behavior of the existing web page</li>
<li>JavaScript and the XMLHttpRequest object, XHR for short, provide a method for exchanging data asynchronously between browser and server to avoid full page reloads</li>
<li>XMLHttpRequest is an API available in web browser scripting languages like JavaScript and supports HTTP requests methods like GET, POST, HEAD, PUT, DELETE, and OPTIONS</li>
<li>D3 includes an XHR module, d3.xhr, that creates an asynchronous request for the URL passed into it and has an option to take in a mimType and a JavaScript Callback Function</li>
<li>On top of the D3 XHR module site several kinds of type-specific XHR calls that allow for requesting and parsing of specific data</li>
<li>The D3 Type-Specific XHR Requests are d3.text, d3.json, d3.xml, d3.html, d3.csv, and d3.tsv</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/javascript-functions">JavaScript Functions</a></li>
<li><a href="https://www.dashingd3js.com/lessons/really-simple-http-server-with-python">Really Simple HTTP Server with Python</a></li>
<li><a href="https://www.dashingd3js.com/lessons/javascript-callback-functions">JavaScript Callback Functions</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 Requests
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
JavaScript Is Single-Threaded
</strong>   
</p>
<br>
<p>
[ Image: Single Threaded Execution ]
</p>
<p>
JavaScript Is Single-Threaded
</p>
<p>
In Computer Programming, single threading is the processing of one command at a time.
</p>
<p>
The opposite of single threading is multi-threading.
</p>
<p>
Single Threading means the processing of one command at a time.
</p>
<p>
Which means that one command is run.
</p>
<p>
Then the program waits for it to finish.
</p>
<p>
Once that command is finished, the next command starts.
</p>
<br>
<p>
[ Image: Waiting In Line ]
</p>
<p>
One way to think about it is that the command instructions are in a single line
</p>
<p>
As soon as one is done, the next one can start doing the work.
</p>
<p>
This works well as long as the command instructions happen in an orderly fashion.
</p>
<br>
<p>
[ Image: Disaster ]
</p>
<p>
Disaster strikes when one process takes a long time or just doesn't return.
</p>
<p>
This breaks the whole system down because the program does not run any more instructions.
</p>
<p>
Which means the program stops working.
</p>
<br>
<br>
<p>
<strong>
Asynchronous I/O
</strong>
</p>
<br>
<p>
Asynchronous I/O
</p>
<p>
From Wikipedia - Asynchronous I/O, or non-blocking I/O, in computer science, is a form of input/output processing that permits other processing to continue before the transmission has finished.
</p>
<p>
In other words, the Asynchronous approach does not have to worry about one command taking a long time because it permits the other commands to start running before the other command finishes.
</p>
<p>
This is especially useful in JavaScript.
</p>
<br>
<p>
[ Image: Singled Threaded Execution ]
</p>
<p>
Because JavaScript is Single-Threaded, having the ability to do Asynchronous Function calls, makes it less susceptible to slow down in the program.
</p>
<br>
<p>
[ Image: Classic Web Application Model ]
</p>
<p>
We care about Asynchronous I/O because we are dealing with the client and server.
</p>
<p>
So when we use JavaScript on the web browser we are dealing with a single thread of instructions that may rely in the communication between the client and the server.
</p>
<p>
The classic web application model is a single set of instructions that run as the client and web server communicate with each other.
</p>
<p>
This picture shows how user activity generates data that is transmitted to the server.
</p>
<p>
The server process this data and sends data back to the client.
</p>
<p>
This happens back and forth over and over again.
</p>
<p>
As we covered earlier, disaster can strike at any point that the client and/or server takes too long to process or do something with the data.
</p>
<br>
<p>
[ Image: Classic Web Application Model ]
</p>
<p>
From Wikipedia:
</p>
<p>
Ajax, an acronym for Asynchronous JavaScript and XML, is a group of interrelated web development techniques used on the client-side to create asynchronous web applications.
</p>
<p>
With Ajax, web applications can send data to, and retrieve data from, a server asynchronously in the background without interfering with the display and behavior of the existing page.
</p>
<p>
Ajax is not a single technology, but a group of technologies.
</p>
<p>
With AJAX, Data can be retrieved using the XMLHttpRequest object. 
</p>
<p>
JavaScript and the XMLHttpRequest object provide a method for exchanging data asynchronously between browser and server to avoid full page reloads.
</p>
<p>
Which is a huge win, because although JavaScript is single threaded, AJAX allows for the web page to continue loading and performing while data is sent and retrieved from the server.
</p>
<p>
D3 uses this extensively to load the data.
</p>
<br>
<br>
<p>
<strong>
XMLHttpRequest
</strong>
</p>
<br>
<p>
XMLHttpRequest - (xhr)
</p>
<p>
XMLHttpRequest or XHR for short, is an API available in web browser scripting languages like JavaScript.
</p>
<p>
It is used to send HTTP and/or HTTPS requests directly to a web server and load the server response directly back into the script.
</p>
<p>
The data received from the server can be JSON, XML, HTML or plain text.
</p>
<br>
<p>
AJAX
    (Asynchronous JavaScript and XML)
</p>
<p>
As we covered before, JavaScript and the XMLHttpRequest object provide a method for exchanging data asynchronously between browser and server to avoid full page reloads.
</p>
<p>
So with AJAX, Data can be retrieved using the XMLHttpRequest object.
</p>
<p>
XMLHttpRequest:
</p>
</p>
<p>
<ul>
<li>GET</li>
<li>POST</li>
<li>HEAD</li>
<li>PUT</li>
<li>DELETE</li>
<li>OPTIONS</li>
</ul>
</p>
<p>
The HTTP request methods supported by XHR are GET, POST, HEAD, PUT, DELETE and OPTIONS.
</p>
<br>
<p>
XMLHttpRequest
    (xhr)
</p>
<p>
XMLHttpRequest Objects and how they work are complicated and not entirely relevant for the basics of what we want to do.
</p>
<p>
The basics are that once created, the Object will go through a series of states of opening a connecting, sending information, ready state when the HTTP content begins loading and the ready state for when the HTTP content has finished loading.
</p>
<p>
Only after the content has finished loading, will the asynchronous JavaScript code proceed.
</p>
<p>
In the case of D3, we'll use the XMLHttpRequest to load data from the server.
</p>
<br>
<p>
XMLHttpRequest
    (xhr)
    d3.xhr
</p>
<p>
D3 contains a D3.xhr module to simplify the loading and parsing of data.
</p>
<p>
In fact, D3 takes it one step further and even has data-type specific methods for accessing data that sits on top of the D3.xhr module.
</p>
<br>
<br>
<p>
<strong>
D3 XHR
</strong>
</p>
<br>
<p>
<pre><code class="javascript">d3.xhr(url [, mimeType] [, callback])</code></pre>
</p>
<p>
This is the D3 XHR Module.
</p>
<p>
It creates an asynchronous request for the url passed into it.
</p>
<p>
It has an option to take in a mimeType and a callback JavaScript function.
</p>
<br>
<p>
<pre><code class="javascript">d3.xhr(url [, mimeType] [, callback])</code></pre>
</p>
<p>
A mimeType is a two-part identifier for file-formats on the internet.
</p>
<p>
The mimeType are also sometimes referred to as Content-Types.
</p>
<p>
When we use the D3 data-type specific methods, we can ignore setting the mimeType because D3 will make sure the right content type is requested.
</p>
<br>
<p>
<pre><code class="javascript">d3.xhr(url [, mimeType] [, callback])</code></pre>
</p>
<p>
The callback is the JavaScript Function that will be executed when the asynchronous XHR call returns.
</p>
<p>
The XHR call will either result in the resources being loaded or the request will fail.
</p>
<br>
<p>
<pre><code class="javascript">d3.xhr(url [, mimeType] [, callback])

callback(error, data)</code></pre>
</p>
<p>
The XHR call will invoke the callback function with two arguments.
</p>
<p>
The error and the data.
</p>
<p>
The error, if it exists, is the error for why the request failed.
</p>
<p>
The data is the actual XMLHttpRequest object.
</p>
<p>
If an error occurred, then the data XMLHttpRequest object will be undefined.
</p>
<br>
<p>
<pre><code class="javascript">callback(error, data)</code></pre>
</p>
<p>
It is here within the callback function that the D3 work that we have building up to this point takes place.
</p>
<p>
If you take a look at the all the basic D3 Data Visualizations on the D3js.org website, you'll see that the actual building of the visualization occurs within the callback code.
</p>
<br>
<p>
Next, let's take a look at the convenience methods that D3 provides.
</p>
<br>
<br>
<p>
<strong>
D3 Type Specific Requests
</strong>
</p>
<br>
<p>
d3.xhr Type Specific Requests:
</p>
<p>
<ul>
<li>d3.text(...)</li>
<li>d3.json(...)</li>
<li>d3.xml(...)</li>
<li>d3.html(...)</li>
<li>d3.csv(...)</li>
<li>d3.tsv(...)</li>
</ul>
</p>
<p>
D3 has Type Specific XHR functionality to load in data into the browser from a server.
</p>
<p>
This functionality covers
</p>
<p>
Text data
</p>
<p>
JSON data
</p>
<p>
XML data
</p>
<p>
HTML data
</p>
<p>
Comma Separated Values Data also called CSV
</p>
<p>
and Tab Separated Values Data also called TSV
</p>
<p>
Each type of request has certain features and methods for parsing the data that come in.
</p>
<br>
<p>
The D3 Text Type Specific Request creates a request for a text file at the specified URL.
</p>
<p>
<pre><code class="javascript">d3.text(url [, mimeType] [, callback])

callback(error,data)</code></pre>
</p>
<p>
The D3.text call will either result in the resources being loaded or the request will fail.
</p>
<p>
The D3.text call will invoke the callback function with two arguments.
</p>
<p>
The error and the data.
</p>
<p>
The error, if it exists, is the error for why the request failed and data will be undefined.
</p>
<p>
If no error, then the data will contain the response text.
</p>
<br>
<p>
The D3 JSON Type Specific Request creates a request for a JSON file at the specified URL.
</p>
<p>
<pre><code class="javascript">d3.json(url [, callback])

callback(error,data)</code></pre>
</p>
<p>
The D3.json call will either result in the resources being loaded or the request will fail.
</p>
<p>
The D3.json call will invoke the callback function with two arguments.
</p>
<p>
The error and the data.
</p>
<p>
The error, if it exists, is the error for why the request failed and data will be undefined.
</p>
<p>
If no error, then the data will contain the parsed JSON.
</p>
<p>
What this means is that it will take the JavaScript Object Notation String returned and convert it to a JavaScript JSON Object.
</p>
<br>
<p>
The D3 XML Type Specific Request creates a request for an XML file at the specified URL.
</p>
<p>
<pre><code class="javascript">d3.xml(url [, mimeType] [, callback])

callback(error,data)</code></pre>
</p>
<p>
The D3.xml call will either result in the resources being loaded or the request will fail.
</p>
<p>
The D3.xml call will invoke the callback function with two arguments.
</p>
<p>
The error and the data.
</p>
<p>
The error, if it exists, is the error for why the request failed and data will be undefined.
</p>
<p>
If no error, then the data will contain the parsed XML.
</p>
<p>
What this means is that it will take the XML String returned and convert it to an XML Document.
</p>
<br>
<p>
The D3 HTML Type Specific Request creates a request for an HTML file at the specified URL.
</p>
<p>
<pre><code class="javascript">d3.html(url [, callback])

callback(error,data)</code></pre>
</p>
<p>
The D3.html call will either result in the resources being loaded or the request will fail.
</p>
<p>
The D3.html call will invoke the callback function with two arguments.
</p>
<br>
<p>
The error and the data.
</p>
<p>
The error, if it exists, is the error for why the request failed and data will be undefined.
</p>
<p>
If no error, then the data will contain the parsed HTML.
</p>
<p>
What this means is that it will take the HTML String returned and convert it to an HTML Document Fragment.
</p>
<br>
<p>
The D3 CSV Type Specific Request creates a request for a comma separated values file or CSV at the specified URL.
</p>
<p>
<pre><code class="javascript">d3.csv(url [, callback])

callback(error,data)</code></pre>
</p>
<p>
The D3.csv call will either result in the resources being loaded or the request will fail.
</p>
<p>
The D3.csv call will invoke the callback function with two arguments.
</p>
<p>
The error and the data.
</p>
<p>
The error, if it exists, is the error for why the request failed and data will be undefined.
</p>
<p>
If no error, then the data will contain an array of parsed rows from the CSV file.
</p>
<br>
<p>
<pre><code class="javascript">d3.csv(url [, callback])

callback(error,data)</code></pre>
</p>
<p>
CSV File =>
<br>
Year,Gender,City,Country
<br>
1997,Male,Boston,USA
<br>
2000,Female,Miami,USA
</p>
<p>
Parsed CSV =>
</p>
<p>
<pre><code class="javascript">[
    {"Year": "1997", "Gender": "Male",   "City": "Boston", "Country": "USA"},
    {"Year": "2000", "Gender": "Female", "City": "Miami",  "Country": "USA"}
]</code></pre>
</p>
<p>
This is what it means when D3 takes in a CSV file and parses it to an array of parsed rows.
</p>
<p>
Each array item is a JavaScript Object, where everything, even numbers are strings.
</p>
<p>
By Parsing it in this way, you can use everything we've learned about arrays of JavaScript objects to use the D3.data functionality.
</p>
<br>
<p>
The D3 TSV Type Specific Request creates a request for a Tab Separated Values file or TSV at the specified URL.
</p>
<p>
<pre><code class="javascript">d3.tsv(url [, callback])

callback(error,data)</code></pre>
</p>
<p>
Tab-separated values are equivalent to comma-separated values, except the tab character is used as a delimiter rather than the comma.
</p>
<p>
The D3.tsv call will either result in the resources being loaded or the request will fail.
</p>
<p>
The D3.tsv call will invoke the callback function with two arguments.
</p>
<p>
The error and the data.
</p>
<p>
The error, if it exists, is the error for why the request failed and data will be undefined.
</p>
<p>
If no error, then the data will contain an array of parsed rows from the TSV file.
</p>
<p>
The TSV parsed rows are the same as the CSV parsed rows.
</p>
<br>
<p>
d3.xhr Type Specific Requests:
</p>
<p>
<ul>
<li>d3.text(...)</li>
<li>d3.json(...)</li>
<li>d3.xml(...)</li>
<li>d3.html(...)</li>
<li>d3.csv(...)</li>
<li>d3.tsv(...)</li>
</ul>
</p>
<br>
<p>
And with that we have covered the D3 Requests.
</p>
<p>
These different requests will let us load large amounts of data easily and seamlessly and let D3 parse the data that is loaded in for us.
</p>
<p>
The requests will be the core of getting D3 data visualizations up and running.
</p>
        </div>
      </div>
    
    ☺</div>

<hr>
<h3 id="lesson38">Loading Data From Server<h3>
    <div>
         <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>The Python module SimpleHTTPServer defines a very simple HTTP server in the directory in which the command line command is run</li>
<li>If the SimpleHTTPServer finds an index.html file in the folder it is run in, then it serves that, otherwise it returns the directory structure of the folder</li>
<li>D3 includes an XHR module, d3.xhr, that creates an asynchronous request for the URL passed into it and has an option to take in a mimType and a JavaScript Callback Function</li>
<li>On top of the D3 XHR module site several kinds of type-specific XHR calls that allow for requesting and parsing of specific data</li>
<li>The D3 Type-Specific XHR Requests are d3.text, d3.json, d3.xml, d3.html, d3.csv, and d3.tsv</li>
<li>The D3 XHR Requests need a URL where the data they are requesting lives</li>
<li>Depending on the D3 Type-Specific XHR Requests used, the data will be sent for, received, and then parsed into an array of JavaScript Objects</li>
<li>For safety, D3 converts all numerical values received from the XHR request into strings</li>
<li>If an error occurs in the D3 XHR Requests, then the XMLHttpRequest Object will describe in great detail what error it encountered and the data argument will be returned as undefined</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/really-simple-http-server-with-python">Really Simple HTTP Server with Python</a></li>
<li><a href="https://www.dashingd3js.com/lessons/javascript-callback-functions">JavaScript Callback Functions</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-requests">D3 Requests</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            Loading Data From Server
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
Python SimpleHTTPServer Revisited
</strong>
</p>
<br>
<p>
[ Image: Python Standard Library ]
</p>
<p>
The Python Programming Language comes with many modules in the Standard Library.
</p>
<p>
There are many wonderful and amazing things built into this library.
</p>
<p>
The one we are going to use is a module that provides a simple web server that we can run on our own computer.
</p>
<br>
<p>
SimpleHTTPServer
</p>
<p>
The Python Module SimpleHTTPServer defines a very simple HTTP server in the directory in which it is run.
</p>
<p>
It maps the directory structure to HTTP requests.
</p>
<br>
<p>
[ Image: Python SimpleHTTPServer Now Running]
</p>
<p>
Using the Command Line Interface on a computer with python installed, we can start an HTTP server in any folder we want.
</p>
<p>
When we run the python -m SimpleHTTPServer command, it will start an HTTP server in the folder where the command is run.
</p>
<p>
After we press enter you can see that the HTTP server starts running.
</p>
<p>
It tells us what IP address it is running on and what port the web server is listening to.
</p>
<br>
<p>
[ Image: Empty Folder ]
</p>
<p>
http://0.0.0.0:8000/ or http://localhost:8000/
</p>
<p>
If there is a file in the folder called index.html, then it serves that file
</p>
<p>
If there is no file in the folder called index.html, then it just returns the directory structure of that folder.
</p>
<p>
This means that to run the D3 Examples, the file name for the example file will be index.html as long as we use the Python SimpleHTTPServer.
</p>
<br>
<br>
<p>
<strong>
D3 Type Specific Requests Revisited
</strong>
</p>
<br>
</p>
<p>
This is the D3 XHR Module.
</p>
<p>
<pre><code class="javascript">d3.xhr(url [, mimeType] [, callback])</code></pre>
</p>
<p>
It creates an asynchronous request for the url passed into it.
</p>
<p>
It has an option to take in a mimeType and a callback JavaScript function.
</p>
<br>
<p>
The XHR call will invoke the callback function with two arguments.
</p>
<p>
<pre><code class="javascript">d3.xhr(url [, mimeType] [, callback])

callback(error, data)</code></pre>
</p>
<p>
The error and the data.
</p>
<p>
The error, if it exists, is the error for why the request failed.
</p>
<p>
The data is the actual XMLHttpRequest object.
</p>
<p>
If an error occurred, then the data XMLHttpRequest object will be undefined.
</p>
<br>
<p>
It is here within the callback function that the D3 work that we have building up to takes place.
</p>
<p>
<pre><code class="javascript">callback(error, data)</code></pre>
</p>
<br>
<p>
d3.xhr Type Specific Requests:
</p>
<p>
<ul>
<li>d3.text(...)</li>
<li>d3.json(...)</li>
<li>d3.xml(...)</li>
<li>d3.html(...)</li>
<li>d3.csv(...)</li>
<li>d3.tsv(...)</li>
</ul>
</p>
</p>
<p>
D3 has Type Specific XHR functionality to load in data into the browser from a server.
</p>
<p>
This functionality covers
</p>
<p>
Text data
</p>
<p>
JSON data
</p>
<p>
XML data
</p>
<p>
HTML data
</p>
<p>
Comma Separated Values Data also called CSV
</p>
<p>
and Tab Separated Values Data also called TSV
</p>
<p>
Each type of request has a certain feature and method for parsing the data that come in.
</p>
<br>
<p>
The D3 Type Specific Request creates a request for a specific mimeType file at the specified URL.
</p>
<p>
<pre><code class="javascript">d3.XXXXX(url [, mimeType] [, callback])

callback(error,data)</code></pre>
</p>
<p>
The D3 Type Specific Request call will either result in the resources being loaded or the request will fail.
</p>
<p>
The D3 Type Specific Request call will invoke the callback function with two arguments.
</p>
<p>
The error and the data.
</p>
<p>
The error, if it exists, is the error for why the request failed and data will be undefined.
</p>
<p>
If no error, then the data will contain the response.
</p>
<p>
Depending on the mimeType, the response will be parsed any number of ways to make it incredibly easy for us to use the Data in D3.
</p>
<br>
<p>
For now, the two most common mimeType D3 Type Specific Requests that we will use are the CSV and TSV.
</p>
<p>
<pre><code class="javascript">d3.csv(url [, callback])

d3.tsv(url [, callback])

callback(error,data)</code></pre>
</p>
<p>
The difference in the two file types is just the delimiter between values.
</p>
<p>
It is either a comma or a tab.
</p>
<br>
<p>
The D3 CSV and TSV Type Specific Request create a request for a CSV or TSV file at the specified URL.
</p>
<p>
<pre><code class="javascript">d3.csv(url [, callback])

d3.csv(url [, callback])

callback(error,data)</code></pre>
</p>
<p>
The D3 Type Specific Request call will either result in the resources being loaded or the request will fail.
</p>
<p>
The D3 Type Specific Request call will invoke the callback function with two arguments.
</p>
<p>
The error and the data.
</p>
<p>
The error, if it exists, is the error for why the request failed and the data will be undefined.
</p>
<p>
If no error, then the data will contain an array of parsed rows from the CSV or TSV file.
</p>
<br>
<p>
This is what it means when D3 takes in a CSV or TSV file and parses it to an array of parsed rows.
</p>
<p>
<pre><code class="javascript">d3.csv(url [, callback])

callback(error,data)</code></pre>
</p>
<br>
<p>
CSV File =>
<br>
Year,Gender,City,Country
<br>
1997,Male,Boston,USA
<br>
2000,Female,Miami,USA
</p>
<br>
<p>
Parsed CSV =>
</p>
<p>
<pre><code class="javascript">[
    {"Year": "1997", "Gender": "Male", "City": "Boston", "Country": "USA"},
    {"Year": "2000", "Gender": "Female", "City": "Miami", "Country": "USA"}
]</code></pre>
</p>
<p>
Each array item is a JavaScript Object, where everything, even numbers are strings.
</p>
<p>
By Parsing it in this way, you can use everything we've learned about arrays of JavaScript objects to use the D3.data functionality.
</p>
<p>
D3 does the exact same thing as seen on the screen with the TSV data files.
</p>
<br>
<p>
We will focus on TSV files for now as that is what most of the D3js.org examples use.
</p>
<p>
The CSV files work the same way, it is just that the delimiter is a comma instead of a tab.
</p>
<br>
<br>
<p>
<strong>
Loading TSV Data From Server
</strong>
</p>
<br>
<p>
[ Image: D3 Scatterplot Example ]
</p>
<p>
We will use the TSV Data from the D3js.org website Scatter Plot Example.
</p>
<br>
<p>
[ Image: Data TSV Example ]
</p>
<p>
We will save this data into a file called data.tsv
</p>
<p>
This file will be located in the folder where we will run the python SimpleHTTP Server command.
</p>
<p>
This file is the one that will be loaded asynchronously using the D3.tsv request functionality.
</p>
<br>
<p>
This is how we are going to call the D3.tsv request.
</p>
<p>
<pre><code class="javascript">var callbackError;

var callbackData;

d3.tsv("data.tsv",							
    function(error, data) {
        callbackError = error;
        callbackData = data;
    }
);</code></pre>
</p>
<br>
<p>
The "data.tsv" part of the d3.tsv call is the URL we are calling.
</p>
<p>
<pre><code class="javascript">var callbackError;

var callbackData;

d3.tsv("data.tsv",							
    function(error, data) {
        callbackError = error;
        callbackData = data;
    }
);</code></pre>
</p>
<p>
Because we are using the Python SimpleHTTPServer which serves files from the same directory as the root url
</p>
<p>
This will look for the data.tsv file in the folder we are in.
</p>
<br>
<p>
The callback function of the d3.tsv call is the anonymous function highlighted.
</p>
<p>
<pre><code class="javascript">var callbackError;

var callbackData;

d3.tsv("data.tsv",							
    function(error, data) {
        callbackError = error;
        callbackData = data;
    }
);</code></pre>
</p>
<p>
It takes in two parameters, the error and the data.
</p>
<p>
In this case, we are going to assign the error and data variables to a callbackError variable and a callbackData variable.
</p>
<p>
Note that we define the callbackError and callbackData variables outside of the function.
</p>
<p>
This is so that we can read the variables once the d3.tsv function has returned and loaded the data.
</p>
<br>
<p>
Let's move to the JavaScript Console now.
</p>
<br>
<p>
We Start at the D3js.org website Scatter Plot Example.
</p>
<p>
http://bl.ocks.org/mbostock/3887118
</p>
<br>
<p>
We scroll down the page until we come to the data.tsv headline
</p>
<p>
This is the data we want to copy to put into the data.tsv file 
</p>
<p>
Notice that there are 5 headings
</p>
<p>
and Each row contains 5 columns.
</p>
<p>
The first four columns are numbers
</p>
<p>
and the last column is a word.
</p>
<br>
<p>
We highlight all of the data under the data.tsv heading.
</p>
<p>
HIGHLIGHT THE DATA
</p>
<p>
We copy this data.
</p>
<br>
<p>
We open a new text editor file
</p>
<p>
PASTE THE DATA
</p>
<p>
and We paste the data into this file.
</p>
<br>
<p>
Now we save this text file in the folder where we are going to run the python SimpleHTTPServer
</p>
<p>
SAVE FILE
</p>
<p>
Note that this folder already contains the index.html file we will use.
</p>
<br>
<p>
If we take a look at the folder, we see 3 files.
</p>
<p>
LOOK AT THE FOLDER on the desktop
</p>
<p>
The D3.js minified file
</p>
<p>
The index.html file
</p>
<p>
and the data.tsv file.
</p>
<br>
<p>
Next, let's open the Command Line Interface and navigate to the the correct folder.
</p>
<p>
<pre><code class="python">cd Desktop/d3_projects</code></pre>
</p>
<p>
It is in this folder that we will run the python SimpleHTTPServer 
</p>
<br>
<p>
Let's start the python SimpleHTTPServer
</p>
<p>
<pre><code class="python">python -m SimpleHTTPServer</code></pre>
</p>
<p>
We have started the HTTP server. 
</p>
<p>
You can see the message Serving HTTP on 0.0.0.0 port 8000 ...
</p>
<br>
<p>
Let's go to the web browser and go to that address
</p>
<p>
IN CHROME
</p>
<p>
http://0.0.0.0:8000/ or http://localhost:8000/
</p>
<p>
It is working and you can see the text that I had written earlier in the index.html file.
</p>
<br>
<p>
Let's go to that index.html file in the text editor and add some D3 to it to load the data.
</p>
<p>
<pre><code class="html">&lt;script&gt;

var callbackError;

var callbackData;

d3.tsv("data.tsv",							
    function(error, data) {
        callbackError = error;
        callbackData = data;
        alert("data.tsv loaded!");
    }
);
&lt;/script&gt;</code></pre>
</p>
<p>
We write the callbackError and callbackData variables.
</p>
<p>
Then we write the d3.tsv request
</p>
<p>
We tell it what file to get
</p>
<p>
We then provide an anonymous callback function that receives two arguments - the error and data.
</p>
<p>
Inside of the function, we assign the error to the callbackError variable
</p>
<p>
We also assign the data to the callbackData variable
</p>
<p>
Lastly, we generate an alert to tell us the data file has been loaded.
</p>
<br>
<p>
Let's go back to the browser to reload the file.
</p>
<p>
BROWSER - ALERT POPS UP
</p>
<p>
From the alert, we can tell that the JavaScript callback function from the d3.tsv request was run.
</p>
<br>
<p>
Now, let's open up the Chrome Developer Tools to check to see what the error and data variables were assigned.
</p>
<p>
BROWSER - Open up chrome developer tools.
</p>
<p>
BROWSER - Open up the JavaScript console while looking at the HTML elements
</p>
<p>
<pre><code class="javascript">callbackError;

callbackData;</code></pre>
</p>
<p>
You can see that the callbackError is null
</p>
<p>
This means no error was encountered.
</p>
<p>
You can also see that the callbackData is an Array of 150 elements.
</p>
<br>
<p>
Let's look at the first element.
</p>
<p>
<pre><code class="javascript">callbackData[0];</code></pre>
</p>
<p>
D3.tsv parsed the data for us and created 150 objects for each of the 150 rows of data in the data.tsv file.
</p>
<p>
The first object has the sepalLength, sepalWidth, petalLength, petalWidth and the species.
</p>
<p>
This is fantastic, D3 took in the data file and parsed it into JavaScript objects for us.
</p>
<p>
We can now pass this array into the D3.data functionality and it will work seamlessly.
</p>
<p>
Let's do one last thing - let's change the file name of the data.tsv file from data.tsv to data1.tsv
</p>
<p>
FOLDER - Change the name of the file
</p>
<br>
<p>
Then, let's reload the browser
</p>
<p>
BROWSER - reload
</p>
<p>
We get the alert, so we know that the D3.tsv functionality ran and called the callback function.
</p>
<p>
In the JavaScript console we can see an error occurred with the HTTP Get command.
</p>
<p>
Let's look at the two variables and what values they were assigned.
</p>
<p>
<pre><code class="javascript">callbackError;

callbackData;</code></pre>
</p>
<p>
First, we see that the callbackError is no longer null.
</p>
<p>
It now contains an XMLHttpRequest Object that describes in great detail what the error is that occurred.
</p>
<p>
When we check the callbackData variable, we see that it is undefined.
</p>
<p>
This is expected because when the D3.tsv functionality encounters an error - it will make the data argument undefined.
d3.xhr Type Specific Requests:
</p>
<p>
<ul>
<li>d3.text(...)</li>
<li>d3.json(...)</li>
<li>d3.xml(...)</li>
<li>d3.html(...)</li>
<li>d3.csv(...)</li>
<li>d3.tsv(...)</li>
</ul>
</p>
</p>
<p>
Note that the D3 Type Specific Requests all work almost identically.
</p>
<p>
The only differences will be how the data that gets returned is parsed.
</p>
<p>
And with that we covered, tested and experimented with loading data from the server using D3.js
</p>
        </div>
      </div>
    
    
    </div>


<hr>
<h3 id="lesson39">Basic Chart - Line Chart<h3>
    <div>
    
    <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>You will use the TSV Data from the D3js.org website Line Chart Example to see how a full D3 Line Chart data visualization is built</li>
<li>Though it is customary to style the SVG elements you create with the D3 .style operator, once you've built the full visualization it's important to extract the styling into a separate &lt;style&gt; &lt;/style&gt; section</li>
<li>Notice the D3 Margin Convention</li>
<li>Notice the D3 Time Formatting</li>
<li>Notice the D3 Time Scale</li>
<li>Notice the D3 Linear Scale</li>
<li>Notice the D3 SVG Axis Component creation, definition, and instantiation for the X-Axis and Y-Axis</li>
<li>Notice the D3 SVG Line Path Generation function</li>
<li>Notice the D3 Type-specific XHR call - d3.tsv(...)</li>
<li>Notice that the creation of the visualization is all done within the JavaScript Callback Function within the d3.tsv call</li>
<li>Notice the D3 Data Join</li>
<li>Notice how D3 helps create visual representations of the data</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/putting-it-all-together">Putting It All Together</a></li>
<li><a href="https://www.dashingd3js.com/lessons/javascript-callback-functions">JavaScript Callback Functions</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-requests">D3 Requests</a></li>
<li><a href="https://www.dashingd3js.com/lessons/loading-data-from-server">Loading Data From Server</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            Basic Chart - Line Chart
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
Visual Code Walk Through
</strong>
</p>
<br>
<p>
[ Image: Line Chart Example ]
</p>
<p>
We will use the TSV Data from the D3js.org website Line Chart Example.
</p>
<br>
<p>
[ Image: Data Of Line Chart Example ]
</p>
<p>
We will save this data into a file called data.tsv
</p>
<p>
This file will be located in the folder where we will run the python SimpleHTTPServer command.
</p>
<p>
This file is the one that will be loaded asynchronously using the D3.tsv request functionality.
</p>
<br>
<p>
We will walk through the D3.js code together.
</p>
<p>
BROWSER HIGHLIGHT First section
</p>
<p>
<pre><code class="html">&lt;!-DOCTYPE...........&lt;meta....&gt;</code></pre>
</p>
<p>
We start at the top of the document.
</p>
<p>
First is the Document Type Declaration.
</p>
<p>
This tells the browser how to render the page in a standards compliant mode.
</p>
<p>
This specific DOCTYPE is the correct declaration for HTML5.
</p>
<p>
Next comes the meta character set.
</p>
<p>
This sets the character set to UTF-8.
</p>
<p>
If you are using non-minified D3.js this is important because the D3 javaScript file needs this particular type of encoding.
</p>
<br>
<p>
The next section is the style definition of the document.
</p>
<p>
Highlight &lt;style&gt;
</p>
<p>
We haven't spoken too much about style yet as to me that comes after the basic framework is built.
</p>
<p>
The little that we have covered should help us understand this section.
</p>
<br>
<p>
This CSS defines the style for the body element.
</p>
<p>
Highlight body { ...}
</p>
<p>
Here, the CSS specifies that the font should be 10px tall and should use a sans-serif font.
</p>
<br>
<p>
The next section defines the style for the axis path and line.
</p>
<p>
BROWSER Highlight .axis.... }
</p>
<p>
The .axis path and .axis line are both HTML classes that have a style associated with them.
</p>
<p>
Here the code is saying no fill, a stroke of #000 which is the HTML Color for black
</p>
<p>
And finally telling the browser that the SVG Content should be using the shape-rendering attribute of crisp edges.
</p>
<br>
<p>
The next section defines the style for the x-axis path.
</p>
<p>
BROWSER Highlight .x.axis ... }
</p>
<p>
Here the code is specifying that we do not want to display the path.
</p>
<p>
Why not just not draw it?
</p>
<p>
Because the code later uses the D3.axis functionality that auto generates the axis tick marks, spacing and line to connect all the ticks.
</p>
<p>
So rather than having to figure out how to not have the D3.axis functionality not draw the line that connects all the ticks, this CSS just hides it.
</p>
<br>
<p>
The next section defines the style for the line that will be the path generated by the data.
</p>
<p>
BROWSER Highlight .line { .... }
</p>
<p>
The fill is set to none and uses the stroke-width to give the line some depth so that it is seen on the screen.
</p>
<p>
The stroke color of the line is defined as steelblue.
</p>
<p>
And that is the end of the styling.
</p>
<p>
Why separate the code when D3 makes it easy to attach style and fill attributes?
</p>
<p>
Because we want to keep a separation of concerns.
</p>
<p>
The D3 JavaScript code gets, manipulates and figures out how to display the data.
</p>
<p>
The CSS Style code defines how to style the DOM elements once they are displayed.
</p>
<br>
<p>
Next we go into the JavaScript Sections of the documents.
</p>
<br>
<p>
First, we load the D3.js code from the web.
</p>
<p>
BROWSER Highlight &lt;script src....&gt; ... &lt;/script&gt;
</p>
<p>
You can use this or a local version for personal and educational projects.
</p>
<p>
If you are doing a commercial project you should use your own version hosted on your own server or content delivery network.
</p>
<p>
This ensures that you are always using the same version you want to use.
</p>
<br>
<p>
Next, we go into the heart of the D3 code.
</p>
<p>
BROWSER Highlight
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 50},
width = 960 - margin.left - margin.right,
height = 500 - margin.top - margin.bottom;</code></pre>
</p>
<p>
We've seen this code before.
</p>
<p>
This is the D3 Margin Convention.
</p>
<p>
It specifies what margins the inner drawing space will have in order to offset it from the overall SVG Container.
</p>
<p>
Then the width and height for the Inner Drawing Space are defined in terms of the margins and the overall width and height of the SVG Container.
</p>
<p>
The SVG Container will be 500 pixels tall by 960 pixels wide.
</p>
<br>
<p>
Next we have D3 code that is new to us.
</p>
<p>
BROWSER Highlight
</p>
<p>
<pre><code class="javascript">var parseDate = d3.time.format("%d-%b-%y").parse;</code></pre>
</p>
<p>
The idea behind this code is that it will take a string formatted in the way specified and convert it into a JavaScript Date Object.
</p>
<p>
When we covered the D3 Time Formatting, we went over a few of what the different letters mean.
</p>
<p>
These formatting helpers are modeled after the C-Library Standards and the Python time module.
</p>
<p>
This takes in a string that has a date then a dash then the three letter code for a month then a dash and finally a two digit number for the year.
</p>
<br>
<p>
Next we have a timescale function for the x-axis data.
</p>
<p>
BROWSER HIGHLIGHT
</p>
<p>
<pre><code class="javascript">var x = d3.time.scale()
.range([0, width]);</code></pre>
</p>
<p>
This code will create a scaling function where the range goes from zero to the width of the inner drawing space.
</p>
<p>
We will set the domain later after we have loaded in the data.
</p>
<br>
<p>
Next we have a scale linear function for the y-axis data.
</p>
<p>
HIGHLIGHT
</p>
<p>
<pre><code class="javascript">var y = d3.scale.linear()
.range([height, 0]);</code></pre>
</p>
<p>
This code will create a scaling function where the range goes from the height of the inner drawing space to 0.
</p>
<p>
Why backwards?
</p>
<p>
Because this inverts the SVG Coordinate Space along the Y-Axis.
</p>
<p>
Let me repeat that - this inverts the SVG Coordinate Space along the Y-Axis.
</p>
<p>
Which means that the origin point will now be at the bottom left instead of the top left.
</p>
<p>
So as the y axis variable grows it will move up rather than down.
</p>
<br>
<p>
Next we create the X-Axis function
</p>
<p>
HIGHLIGHT
</p>
<p>
<pre><code class="javascript">var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");</code></pre>
</p>
<p>
We pass in the x-scale function we created earlier and then give the axis an orientation of bottom.
</p>
<p>
This means that the text will be below the line.
</p>
<p>
Though in this case, if you remember that we defined the CSS style of the path as display none, we won't see a line - so we'll just see the text.
</p>
<p>
One question that might come up --- how can we pass in the x scale function before we give it a domain?
</p>
<p>
The reason we can do this is because the x scale function is a function.
</p>
<p>
Until we call it, we can continue to modify the function.
</p>
<p>
So the xAxis function itself now contains the x-scale function.
</p>
<p>
Nothing is executed until the x-axis function itself is called.
</p>
<br>
<p>
Then we create the Y-Axis the same way
</p>
<p>
HIGHLIGHT
</p>
<p>
<pre><code class="javascript">var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");</code></pre>
</p>
<p>
We pass in the y-scale function we created earlier and give the axis an orientation of left.
</p>
<p>
This orientation will make the axis vertical and make the text appear on the left of the line.
</p>
<br>
<p>
Next, the code defines the D3 path generation function.
</p>
<p>
HIGHLIGHT
</p>
<p>
<pre><code class="javascript">var line = d3.svg.line()
    .x(function(d) { return x(d.date); })
    .y(function(d) { return y(d.close); });</code></pre></p>
<br>
<p>
This uses the D3 Path Data Generator Functionality.</p>
<br>
<p>
For x values and y values, the code defines specific accessor functions.</p>
<p>
The data set we are looking at is comprised of dates and closing prices for the Apple stock.</p>
<p>
Which means the x values access the date from the data passed in through an anonymous function</p>
<p>
While the y values access the stock price close from the data passed in through an anonymous function.</p>
<p>
This creates another function which will be called later.
</p>
<br>
<p>
The next code creates the SVG Container and the Inner Drawing Space.
</p>
<p>
HIGHLIGHT
</p>
<p>
<pre><code class="javascript">var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
We have seen this code many times now.
</p>
<p>
First the code selects the body and then append an SVG Container.
</p>
<p>
Then the code defines the width and height attributes of the SVG Container in terms of the inner drawing space width and height and the relevant margins.
</p>
<p>
Then the code appends an SVG Group Element which will be the inner drawing space.
</p>
<p>
This inner drawing space is transform translated to the right and down by the relevant margins.
</p>
<p>
All of this is assigned to the variable SVG which everything else in the code will use as the reference drawing space.
</p>
<br>
<p>
The next code is where the D3 code magic happens.
</p>
<p>
HIGHLIGHT all d3.tsv
</p>
<p>
This is where D3 does an XHR type specific call to the server to get the "data.tsv" file.
</p>
<p>
Once the server responds with the file, the D3.tsv function calls the callback function with two arguments, the error and the data.
</p>
<p>
In this case, the callback function is an anonymous function.
</p>
<br>
<p>
Let's go through the callback function section by section.
</p>
<br>
<p>
First, we have code that iterates through the array of JavaScript objects
</p>
<p>
HIGHLIGHT
</p>
<p>
<pre><code class="javascript">data.forEach(function(d) {
    d.date = parseDate(d.date);
    d.close = +d.close;
});</code></pre>
</p>
<p>
For each JavaScript object it does two things:
</p>
<p>
one, it converts the date string to a JavaScript Date Object
</p>
<p>
and two, and it converts the closing price from a string to a number.
</p>
<br>
<p>
The D3 forEach iteration method is used on the data array.
</p>
<p>
HIGHLIGHT
</p>
<p>
<pre><code class="javascript">forEach</code></pre>
</p>
<p>
Is an iteration method D3 provides for iterating through a JavaScript array.
</p>
<p>
It applies the function specified to each element of the array.
</p>
<p>
In this case, it is applying an anonymous function to each element of the array.
</p>
<p>
So it is redefines the values it finds to the same keys in the same objects.
</p>
<p>
This is to convert the data to a more usable type of data.
</p>
<p>
Since each element of the array is a JavaScript Object, this code iterates through the JavaScript Objects and redefines the values for the keys date and close.
</p>
<br>
<p>
The parseDate is the function we defined earlier.
</p>
<p>
HIGHLIGHT
</p>
<p>
<pre><code class="javascript">d.date = parseDate(d.date);</code></pre>
</p>
<p>
This takes in a string and using the format we specified, it creates a new JavaScript Date Object.
</p>
<p>
Then it assigns it right back to the d.date key.
</p>
<br>
<p>
The + sign in front of the d.close converts the string to a number.
</p>
<p>
HIGHLIGHT
</p>
<p>
<pre><code class="javascript">d.close = +d.close;</code></pre>
</p>
<p>
This is a quick way to convert a string to a number in JavaScript.
</p>
<br>
<p>
Next, we set the domain for the x scale function
</p>
<p>
HIGHLIGHT
</p>
<p>
<pre><code class="javascript">x.domain(d3.extent(data, function(d) { return d.date; }));</code></pre>
</p>
<p>
Now that we have the data, we can set the domain of the x scale function by using the D3.extent method.
</p>
<p>
This returns an array containing the minimum and maximum Dates.
</p>
<p>
An anonymous function is used to get the date out of the Data Objects.
</p>
<br>
<p>
Next, we set the domain for the y scale function
</p>
<p>
HIGHLIGHT
</p>
<p>
<pre><code class="javascript">y.domain(d3.extent(data, function(d) { return d.close; }));</code></pre>
</p>
<p>
Now that we have the data, we can set the domain of the y scale function by using the D3.extent method.
</p>
<p>
This returns an array containing the minimum and maximum close prices.
</p>
<p>
An anonymous function is used to get the close out of the Data Objects.
</p>
<br>
<p>
Next, we call D3.axis operator for the x-axis.
</p>
<p>
HIGHLIGHT
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);</code></pre>
</p>
<p>
First the code appends an SVG Group Element to hold the x-axis.
</p>
<p>
Then the group element is given the class of "x axis"
</p>
<p>
Then it is transform translated by the height of the inner drawing space.
</p>
<p>
This is not something we have covered before, though it's been alluded to.
</p>
<p>
To move the Axis elements around, you have to move the G element in which they live in.
</p>
<p>
In this case, we are moving the G element to the bottom of the Inner Drawing Space.
</p>
<p>
Finally, the xAxis function is called.
</p>
<p>
This works correctly because we have now defined the x scaling function domain and range.
</p>
<br>
<p>
Next, we call D3.axis operator for the y-axis.
</p>
<p>
HIGHLIGHT
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "y axis")
    .call(yAxis)
  .append("text")
    .attr("transform", "rotate(-90)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Price ($)");</code></pre>
</p>
<p>
First the code appends an SVG Group Element to hold the y-axis.
</p>
<p>
Then the group element is given the class of y axis
</p>
<p>
Then then yAxis function is called.
</p>
<p>
This works correctly because we have now defined the y scaling function domain and range.
</p>
<p>
Finally, we append text to the Y Axis.
</p>
<p>
This is new.
</p>
<p>
This text is transformed by rotating it -90 degrees.
</p>
<p>
Then the y and Dy attributes are defined.
</p>
<p>
The style is defined as a text-anchor and placed at the end of the Y axis.
</p>
<p>
Finally the text for the SVG Text is defined.
</p>
<p>
This places a small label on the Y Axis.
</p>
<br>
<p>
And then finally, we draw the line that is the graph of the data.
</p>
<p>
HIGHLIGHT
</p>
<p>
<pre><code class="javascript">svg.append("path")
    .datum(data)
    .attr("class", "line")
    .attr("d", line);</code></pre>
</p>
<p>
This is the D3 pattern.
</p>
<p>
We define the drawing space.
</p>
<p>
We append a path
</p>
<p>
We use datum(data) since there is only one piece of a data the array.
</p>
<p>
The path instructions be generated by the D3 Path Generator functionality using that one array.
</p>
<p>
Then we give the path a class of line.
</p>
<p>
This is how the CSS knows to provide styling to the line.
</p>
<p>
And finally, we add the attribute d, which is the D3 Path Generator Function.
</p>
<p>
This will take in the data that was passed into the datum and generate the path for us.
</p>
<p>
One thing to notice here is that the passing of the data object is not explicit.
</p>
<p>
D3 implicitly understands that it should use the Data bound to the SVG path object.
</p>
<p>
Thus it it is able to use the data passed into the datum call without having it be specified.
</p>
<br>
<p>
And that is the end of the callback function and the end of the d3.tsv function.
</p>
<p>
HIGHLIGHT
</p>
<p>
<pre><code class="javascript">});</code></pre>
</p>
<p>
When this is done the graph will have been fully generated.
</p>
<br>
<p>
Let's now build this part by part in JavaScript.
</p>
<br>
<br>
<p>
<strong>
JavaScript Code Build
</strong>
</p>
<p>
Because the building of the chart happens inside of the callback function, we will use a more simple anonymous function
</p>
<p>
<pre><code class="javascript">d3.tsv("data.tsv", function(error, data){...});

// =>

d3.tsv("data.tsv", function(error, data){
    callbackError = error;
    callbackData = data;
});</code></pre>
</p>
<p>
We do this in this way for two reasons:
</p>
<p>
one - it's easier to do in the JavaScript console as we build the chart piece by piece
</p>
<p>
and two, it reinforces the idea of the callback function and how it works.
</p>
<p>
Though, to be honest, the preferred way of coding it when you code it into your web page is the way it's done in the example.
</p>
<p>
That way it is clear that it is a callback function and it is all in one place.
</p>
<p>
Alright, to the JavaScript Console.
</p>
<br>
<p>
CLEAR CHROME BROWSER CACHE
</p>
<br>
<p>
We start by saving the example data into the data.tsv file which lives in the folder where we will start the Python SimpleHTTPServer.</p>
<br>
<p>
save the data.</p>
<br>
<p>
Next, we start the Python SimpleHTTPServer from the command line
</p>
<p>
<pre><code class="python">cd Desktop/d3_projects/</code></pre>
</p>
<p>
<pre><code class="python">python -m SimpleHTTPServer</code></pre></p>
<br>
<p>
Now, we have the server going and have the data file ready to be served up.
</p>
<br>
<p>
Next, we make sure the index.html file is saved in the right place and has D3 being loaded into it.
</p>
<p>
Show index file and save it.
</p>
<p>
Go to the 0.0.0.0:8000/ or localhost:8000
</p>
<p>
We can see the web page.
</p>
<br>
<p>
We open the Chrome Developer tools and test to make sure D3 loaded correctly then clear the screen.
</p>
<p>
<pre><code class="javascript">d3.version;</code></pre>
</p>
<p>
<pre><code class="javascript">clear();</code></pre>
</p>
<p>
D3 loaded correctly.
</p>
<p>
Now we clear the screen.
</p>
<br>
<p>
Next, we go step by step building the visualization.
</p>
<br>
<p>
We start by defining the callbackError and callbackData variables which will be used to house the data we get back from the d3.tsv function.
</p>
<p>
<pre><code class="javascript">var callbackError;</code></pre>
</p>
<p>
<pre><code class="javascript">var callbackData;</code></pre>
</p>
<br>
<p>
The first step from the example is defining the margins and the width and height of the inner drawing space.
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 50},
width = 960 - margin.left - margin.right,
height = 500 - margin.top - margin.bottom;</code></pre>
</p>
<br>
<p>
Next - define the date parsing function.
</p>
<p>
<pre><code class="javascript">var parseDate = d3.time.format("%d-%b-%y").parse;</code></pre>
</p>
<br>
<p>
Next - define the x scaling function as well as the range of the function.
</p>
<p>
<pre><code class="javascript">var x = d3.time.scale()
    .range([0, width]);</code></pre>
</p>
<br>
<p>
Next - define the y scaling function as well as the range of the function.</p>
<br>
<p>
Remember to pay attention to the fact that the range has height first and then 0 - which inverts the y-axis.
</p>
<p>
<pre><code class="javascript">var y = d3.scale.linear()
    .range([height, 0]);</code></pre>
</p>
<br>
<p>
Next - define the xAxis function and provide it with a scale and orientation.
</p>
<p>
<pre><code class="javascript">var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");</code></pre>
</p>
<br>
<p>
Next - define the yAxis function and provide it with a scale and orientation as well.
</p>
<p>
<pre><code class="javascript">var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");</code></pre>
</p>
<br>
<p>
Next - define the D3 path Generator function.
</p>
<p>
<pre><code class="javascript">var line = d3.svg.line()
    .x(function(d) { return x(d.date); })
    .y(function(d) { return y(d.close); });</code></pre>
</p>
<br>
<p>
Next - define the SVG Container and the Inner Drawing Space
</p>
<p>
<pre><code class="javascript">var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
BROWSER - Open the Body element, the SVG element and show the inner SVG Group Element.
</p>
<p>
This is the first sign of anything occurring in the browser.
</p>
<p>
Up to now we have just been defining functions that will use or be used by the data that is passed in.
</p>
<br>
<p>
Next is where we are going to differ a bit from the code of the example.
</p>
<p>
<pre><code class="javascript">d3.tsv("data.tsv", function(error,data) {
    callbackError = error;
    callbackData  = data;
});</code></pre>
</p>
<p>
Instead of defining an anonymous callback function that does all the generating of the chart in one go, we'll define a callback function that assigns the data and error to variables.
</p>
<p>
We'll then use these variables to build the line chart.
</p>
<br>
<p>
Let's check what the d3.tsv call assigned to the callbackError variable.
</p>
<p>
<pre><code class="javascript">callbackError;</code></pre>
</p>
<p>
The callbackError is null, which means the D3.tsv call worked correctly.
</p>
<br>
<p>
Let's check what the d3.tsv call assigned to the callbackData variable.
</p>
<p>
<pre><code class="javascript">callbackData;</code></pre>
</p>
<p>
The callbackData is an array of 1280 elements, which means the D3.tsv call worked correctly.
</p>
<br>
<p>
Let's take a look at the first element of this array.
</p>
<p>
<pre><code class="javascript">callbackData[0];</code></pre>
</p>
<p>
You can see that it is a JavaScript object that has the date defined as a string and the close defined as a string.
</p>
<br>
<p>
Next - we use the D3 Array forEach iterator to go through the array and change the string values to either JavaScript Date Objects or Numbers.
</p>
<p>
<pre><code class="javascript">callbackData.forEach(function(d) {
    d.date = parseDate(d.date);
    d.close = +d.close;
});</code></pre>
</p>
<br>
<p>
Let's take a look now at the first element of this array.
</p>
<p>
<pre><code class="javascript">callbackData[0];</code></pre>
</p>
<p>
You can see that the values are no longer strings.
</p>
<p>
The date value is a date and the close value is a number.
</p>
<br>
<p>
To check to make sure the date is now a JavaScript object we can use the typeof JavaScript function:
</p>
<p>
<pre><code class="javascript">typeof(callbackData[0]['date']);</code></pre>
</p>
<p>
Which tell us it is an object.
</p>
<br>
<p>
To check to make sure the close is now a JavaScript number we can use the typeof JavaScript function:
</p>
<p>
<pre><code class="javascript">typeof(callbackData[0]['close']);</code></pre>
</p>
<p>
Which tell us it is an number.
</p>
<p>
Satisfied that we have JavaScript Date Objects and a numbers, let's move on.
</p>
<br>
<p>
Next - define the domain of the x scale function
</p>
<p>
<pre><code class="javascript">x.domain(d3.extent(callbackData, function(d) { return d.date; }));</code></pre>
</p>
<br>
<p>
Let's check to see what the extent was for the x-scale
</p>
<p>
<pre><code class="javascript">d3.extent(callbackData, function(d) { return d.date; });</code></pre>
</p>
<p>
We can see that the lowest date is Tuesday April 24th 2007 and the highest date is Tuesday May 1st 2012
</p>
<br>
<p>
Next - define the domain of the y scale function
</p>
<p>
<pre><code class="javascript">y.domain(d3.extent(callbackData, function(d) { return d.close; }));</code></pre>
</p>
<br>
<p>
Let's check to see what the extent was for the y-scale
</p>
<p>
<pre><code class="javascript">d3.extent(callbackData, function(d) { return d.close; });</code></pre>
</p>
<p>
We can see that the lowest stock price was 78.2 and the highest stock price was 636.23.
</p>
<br>
<p>
Next - the x-axis is created.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);</code></pre>
</p>
<p>
Note again that the transform translate moves the x-axis Group element to the bottom of the Inner Drawing Space.
</p>
<p>
On my screen, you can just see the start of the x-axis as Chrome developer tools are taking up about 2/3s of the web page.
</p>
<p>
That said, you can see the 2008.
</p>
<p>
BROWSER - click into the G element
</p>
<p>
If we click into the SVG Group Element for the Inner Drawing Space
</p>
<p>
You can see the SVG Group element with the class "x axis".
</p>
<p>
This is the X axis.
</p>
<br>
<p>
Next - the y-axis is created.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "y axis")
    .call(yAxis)
  .append("text")
    .attr("transform", "rotate(-90)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Price ($)");</code></pre>
</p>
<p>
You can see the y-axis and the price text anchor declaring that it is a price in dollars.
</p>
<p>
BROWSER - click into the G element
</p>
<p>
If we click into the SVG Group Element for the Inner Drawing Space
</p>
<p>
You can see the SVG Group element with the class "y axis".
</p>
<p>
This is the y axis.
</p>
<br>
<p>
Lastly - we create the line by using the D3 Path Generator.
</p>
<p>
<pre><code class="javascript">svg.append("path")
    .datum(callbackData)
    .attr("class", "line")
    .attr("d", line);</code></pre>
</p>
<p>
BROWSER - Click on the path class="line"
</p>
<p>
You can see that the SVG path was generated.
</p>
<p>
Why does it show up in a weird way?
</p>
<p>
It shows up in a weird way because in the example, the styling was defined in the CSS.
</p>
<p>
Here because we gave the line no fill, stroke color or stroke width, the line is visible and has a fill in it.
</p>
<br>
<p>
Let's delete the path in the Elements section and this time provide the command with the style attributes attached.
</p>
<p>
Click on the path and delete it.
</p>
<p>
You can see the path is now gone.
</p>
<br>
<p>
Let's redefine the path now.
</p>
<p>
<pre><code class="javascript">svg.append("path")
    .datum(callbackData)
    .attr("class", "line")
    .attr("d", line)
    .attr("fill","none")
    .attr("stroke","steelblue")
    .attr("stroke-width","1.5px");</code></pre>
</p>
<br>
<p>
And there we go, we have the chart.
</p>
<br>
<p>
Let's close the Chrome Developer tools to get a better look.
</p>
<p>
Close the Chrome Developer Tools.
</p>
<p>
Zoom out.
</p>
<p>
You can see the full picture.
</p>
<br>
<p>
The only difference between this and the example was the styling applied to the various DOM Elements.
 </p>
<br>
<p>
And with that we built the Basic Chart Line Graph.</p>
<br>
<p>
We used Data served from a web server and processed it through an asynchronous XHR call provided by the D3.tsv type specific method.
</p>
        </div>
      </div>
    ☺</div>


<hr>
<h3 id="lesson40">D3 Ordinal Scales<h3>
    <div>
    <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>D3 provides three types of functions that map an input domain to an output range - D3 Quantitative Scales, D3 Ordinal Scales, and D3 Time Scales</li>
<li>The D3 Ordinal Scales are for discreet domains, such as sets of things or categories</li>
<li>The D3 Ordinal Scale, d3.scale.ordinal(), constructs a new ordinal scale with an empty domain and an empty range</li>
<li>The D3 Ordinal Scale is invalid until an output range is specified</li>
<li>The D3 Ordinal Scale comes with built in functionality to work with ranges, rangePoints, rangeBands, and RangeRoundBands which allow for very specific subdivision of the output interval of the scale</li>
<li>D3 comes with several Ordinal scales specifically constructed for colors - d3.scale.category10(), d3.scale.category20(), d3.scale.category20b(), and d3.scale.category20c</li>
<li>The D3 category10 scale comes with 10 categorical colors already chosen for you</li>
<li>The D3 category20 scales come with 20 categorical colors already chosen for you</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/d3-scales">D3 Scales</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-scales-part-two">D3 Scales Part Two</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-scales-part-three">D3 Scales Part Three</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-time-scales">D3 Time Scales</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-scales-for-data">D3 Scales For Data</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 Ordinal Scales
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
D3 Scales Revisited
</strong>
</p>
<br>
<p>
Quantitative Scales - for continuous input domains, such as numbers.
<br>
Ordinal Scales - for discrete input domains, such as names or categories.
<br>
Time Scales - for time domains.
</p>
<p>
D3 provides three types of functions that map an input domain to an output range.
</p>
<p>
The Quantitative scales are for real numbers
</p>
<p>
The Ordinal Scales are Discreet domains, such as letters of the alphabet
</p>
<p>
The Time Scales are an extension of the Quantitative Scales that use the JavaScript Date Objects.
</p>
<p>
All of these scales take in data and convert it to a usable set of output.
</p>
<br>
<p>
Quantitative Scales - Linear Scales
</p>
<br>
<p>
y = mx + b
</p>
<p>
D3 Quantitative Scales are for continuous input domains, such as numbers or Dates and Times.
</p>
<p>
The mapping is linear in that the output range value y can be expressed as a linear function of the input domain value x.
</p>
<p>
<pre><code class="javascript">d3.scale.linear().domain([0,400]).range([0,200]);</code></pre>
</p>
<br>
<p>
ℝ - Real Numbers
<br>
LINE 1: Domain
<br>
----------A---------B---------C---------
<br>
LINE 2: Range
<br>
----------D---------E---------F---------
</p>
<p>
The Domain is Line 1
</p>
<p>
The Range is Line 2
</p>
<p>
The Range is thus the result of the y=mx+b transformation from Line 1 to Line 2
</p>
<p>
The left most element in Line 1 gets transformed to the left most element in Line 2
</p>
<p>
And the right most element in Line 1 gets transformed to the right most element in Line 2
</p>
<p>
And the middle elements in line 1 get transformed to the middle elements in line 2.
</p>
<p>
This covers the basics of the Quantitative and Time Scales, next, let's cover the Ordinal Scale.


</p>
<br>
<br>
<p>
<strong>
D3 Ordinal Scales
</strong>
</p>
<br>
<p>
Quantitative Scales - for continuous input domains, such as numbers.
<br>
Ordinal Scales - for discrete input domains, such as names or categories.
<br>
Time Scales - for time domains.
</p>
<p>
D3 provides three types of functions that map an input domain to an output range.
</p>
<p>
Ordinal scales have a discrete domain, such as a set of names or categories.
</p>
<p>
An example can be the letters of the alphabet.
</p>
<br>
<p>
D3 dot scale dot ordinal constructs a new ordinal scale with an empty domain and an empty range.
</p>
<p>
<pre><code class="javascript">d3.scale.ordinal()</code></pre>
</p>
<br>
<p>
The ordinal scale is invalid until an output range is specified.
</p>
<p>
Until it is specified, it will always return undefined as the return value.
</p>
<br>
<p>
The values passed into the domain of the D3 Scale Ordinal Function are a discreet domain.
</p>
<p>
<pre><code class="javascript">d3.scale.ordinal().domain([values])</code></pre>
</p>
<p>
In the case of the English Alphabet it could be the 26 Alphabetic Letters.
</p>
<p>
D3 does not assume an order.
</p>
<p>
It interprets the values as you pass them in as being correctly ordered.
</p>
<p>
That is - the first element in the domain will be mapped to the first element in the output range.
</p>
<p>
The second domain value will be mapped to the second range value.
</p>
<p>
The third domain value will be mapped to the third range value.
</p>
<p>
And so on.
</p>
<p>
The values passed in must be coercible to a string because of the way the Domain Values are stored internally by D3.
</p>
<br>
<p>
It is possible to have D3 infer what the domain is if you do not give it a set of domain values.
</p>
<p>
<pre><code class="javascript">d3.scale.ordinal().domain()</code></pre>
</p>
<p>
This is not a good idea.
</p>
<p>
You should set the domain explicitly.
</p>
<br>
<p>
D3 dot scale dot ordinal dot range is for a range that has discreet values.
</p>
<p>
<pre><code class="javascript">d3.scale.ordinal().range([values])</code></pre>
</p>
<p>
If values are specified it sets the output range of the ordinal scale to the specified array of values.
</p>
<p>
The first element in the domain will be mapped to the first element in the output range.
</p>
<p>
The second domain value will be mapped to the second range value.
</p>
<p>
The third domain value will be mapped to the third range value.
</p>
<p>
And so on.
</p>
<p>
If there are fewer elements in the range than the domain, the scale recycles values from the start of the range.
</p>
<p>
The range is intended for discreet range values that match the number of domain inputs.
</p>
<p>
For example - the word for the numbers in Spanish could be the domain and the range could be the word for the numbers in English.
</p>
<p>
Where both are ordered in natural order.
</p>
<p>
This is a 1 to 1 relationship where we can take the input from the domain and change it to the output from the range.
</p>
<br>
<p>
D3 dot scale dot ordinal dot range points is for a range that has a specified continuous interval.
</p>
<p>
<pre><code class="javascript">d3.scale.ordinal().rangePoints(interval[, padding])</code></pre>
</p>
<p>
The interval is a two element array representing the minimum and maximum value.
</p>
<p>
The interval is then subdivided into N evenly-spaced points where N is the number of unique values in the input domain.
</p>
<p>
The padding can be used to apply padding to the interval at the start and end of the range.       
</p>
<br>
<p>
D3 dot scale dot ordinal dot range bands and d3 dot scale dot ordinal dot range round bands are for ranges that have a specified continuous interval.
</p>
<p>
<pre><code class="javascript">d3.scale.ordinal().rangeBands(interval[, padding[, outerPadding]])</code></pre>
        d3.scale.ordinal().rangeRoundBands(interval[, padding])
</p>
<p>
The interval is a two element array representing the minimum and maximum numeric value.
</p>
<p>
This interval is then subdivided into N evenly-spaced intervals where N is the number of unique values in the input domain.
</p>
<p>
The padding corresponds to the amount of space in the range interval to allocate to padding between the bands.
</p>
<p>
The outer-padding is for the padding before and after the entire group of bands.
</p>
<p>
rangeRoundBands is the same as rangeBands with the added bonus that the band width and offset is a integer value, in order to avoid anti-aliasing artifacts.
</p>
<br>
<p>
Once a Range Band Ordinal Scale Function has been set,rangeBand() will returns the band width.
</p>
<p>
<pre><code class="javascript">d3.scale.ordinal().rangeBand()</code></pre>
</p>
<p>
This method is used in conjunction with rangeBands or rangeRoundBands.
</p>
<p>
This can be useful to double check your work.
        


</p>
<br>
<br>
<p>
<strong>
D3 Ordinal Scales - Categorical Colors
</strong>
</p>
<br>
<p>
D3 comes with 4 types of ordinal color scales.
</p>
<p>
<pre><code class="javascript">d3.scale.category10()

d3.scale.category20()

d3.scale.category20b()

d3.scale.category20c()</code></pre>
</p>
<p>
Each scale comes with a range of html colors.
</p>
<p>
The category10 scale comes with a range of 10 categorical colors.
</p>
<p>
The category20 scale comes with a range of 20 categorical colors.
</p>
<p>
The category20b scale comes with a range of 20 categorical colors that are different from the category20 colors.
</p>
<p>
and the category20c scale comes with a range of 20 categorical colors that are different from both the category20 colors and the category20b colors.
</p>
<p>
These category colors are used very frequently for color encoding of data.
</p>
<br>
<p>
Next, Let's check out some ordinal scales example as well as categorical color examples in the JavaScript Console.
</p>
<br>
<br>
<p>
<strong>
D3 Ordinal Scale Examples
</strong>
</p>
<br>
<p>
First let's define the ordinalScale variable we will use.
</p>
<p>
<pre><code class="javascript">var ordinalScale = d3.scale.ordinal();

ordinalScale;</code></pre>
</p>
<p>
As you can see the ordinalScale is a function.
</p>
<br>
<p>
Remembering that the scale is invalid until we provide an output range, let's try passing in a number and a string.
</p>
<p>
<pre><code class="javascript">ordinalScale(1);

ordinalScale("A");</code></pre>
</p>
<p>
Both return undefined as we would expect them to.
</p>
<br>
<p>
Next, let's define a discreet domain - the letters of the English Alphabet.
</p>
<p>
<pre><code class="javascript">var alphabet = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];</code></pre>
</p>
<p>
The alphabet variable is defined as an Array of 26 elements, each of which is a string of the letter of the English Alphabet.
</p>
<br>
<p>
Next, let's define the domain for the ordinalScale defined earlier.
</p>
<p>
<pre><code class="javascript">ordinalScale.domain(alphabet);</code></pre>
</p>
<p>
The domain of the ordinalScale is now the 26 letters.
</p>
<p>
If we pass in one of these 26 letters, it will be converted to something in the range.
</p>
<p>
If we pass in the letter A - 
</p>
<p>
If it is a 1-1 pairing, then the 1st letter of the alphabet will be converted to the first element in the range.
</p>
<p>
If it is a rangePoints range, then it will be converted to the 1st of 26 evenly-spaced points where 26 is the number of unique values in the input domain.
</p>
<p>
If it is a rangeBoundBands range or rangeBand, then it will be converted to the 1st of 26 evenly-spaced bands where 26 is the number of unique values in the input domain.
</p>
<br>
<p>
Before we try different ranges, let's check to see if the function is valid yet.
</p>
<p>
<pre><code class="javascript">ordinalScale(1);

ordinalScale("A");</code></pre>
</p>
<p>
Both return undefined as we would expect it to.
</p>
<p>
We have not defined the range yet, so the ordinal scale is invalid until the range is defined.
</p>
<br>
<p>
Let's define two possible ranges based on the numbers 1 to 26.
</p>
<p>
<pre><code class="javascript">var numbersUP = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26];

var numbersDN = [26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1];</code></pre>
</p>
<p>
  We will try using both possible ranges to do a one to one mapping from the domain to the range in the ordinal scale.
</p>
<br>
<p>
First, let's use the numbersUP variable.
</p>
<p>
<pre><code class="javascript">ordinalScale.range(numbersUP);</code></pre>
</p>
<p>
The function is now defined.
</p>
<br>
<p>
Let's test a few letters
</p>
<p>
<pre><code class="javascript">ordinalScale("A");

ordinalScale("B");

ordinalScale("E");

ordinalScale("Z");</code></pre>
</p>
<p>
The ordinal Scale worked!
</p>
<p>
It mapped the alphabet letter strings we passed into the ordinalScale function and converted them to the numbers from the numbersUP array.
</p>
<p>
The first element "A" was mapped to the number 1
</p>
<p>
The second element "B" was mapped to the number 2
</p>
<p>
The fifth element "E" was mapped to the number 5
</p>
<p>
The 26th element "Z" was mapped to the number 26
</p>
<p>
And so on...
</p>
<br>
<p>
Let's redefine the ordinalScale range to be the numbers down array.
</p>
<p>
<pre><code class="javascript">var ordinalScale = d3.scale.ordinal();

ordinalScale.domain(alphabet);

ordinalScale.range(numbersDN);</code></pre>
</p>
<p>
The function is now defined.
</p>
<br>
<p>
Let's test a few letters
</p>
<p>
<pre><code class="javascript">ordinalScale("A");

ordinalScale("B");

ordinalScale("E");

ordinalScale("Z");</code></pre>
</p>
<p>
The ordinal Scale worked!
</p>
<p>
It mapped the alphabet letter strings we passed into the ordinalScale function and converted them to the numbers from the numbersDN array.
</p>
<p>
The first element "A" was mapped to the number 26
</p>
<p>
The second element "B" was mapped to the number 25
</p>
<p>
The fifth element "E" was mapped to the number 22
</p>
<p>
The 26th element "Z" was mapped to the number 1
</p>
<p>
And so on...
</p>
<p>
This shows that if it is a 1 to 1 mapping in the range, then the first domain element gets matched up to the first range element.
</p>
<p>
It does regardless of what order you think it should be.
</p>
<p>
This is worth paying attention to if you are passing in an ordered or unordered array as the range.
</p>
<br>
<p>
Next - let's take a look at setting the rangePoints of the ordinalScale.
</p>
<p>
<pre><code class="javascript">var ordinalScale = d3.scale.ordinal();

ordinalScale.domain(alphabet);

ordinalScale.rangePoints([1,26]);</code></pre>
</p>
<p>
Here the range is defined as a continuous interval between 1 to 26.
</p>
<p>
The interval will be subdivided into 26 evenly-spaced points because 26 is the number of unique discreet values in the input domain.
</p>
<br>
<p>
Let's test a few letters
</p>
<p>
<pre><code class="javascript">ordinalScale("A");

ordinalScale("B");

ordinalScale("E");

ordinalScale("Z");</code></pre>
</p>
<p>
The ordinal Scale worked!
</p>
<p>
The letter "A" was mapped to point 1
</p>
<p>
The letter "B" was mapped to point 2
</p>
<p>
The letter "E" was mapped to point 5
</p>
<p>
The letter "Z" was mapped to point 26.
</p>
<p>
The way step size between points in the rangePoints works is that it subtracts the minimum number from the maximum and then divides it by the number of unique discreet values minus 1
</p>
<p>
In this case, the math is 26 - 1 divided by 26 -1, so we get the step size to be 1.
</p>
<p>
Which is why it maps to whole integers.
</p>
<br>
<p>
Next - let's take a look at setting the rangeBands of the ordinalScale.
</p>
<p>
<pre><code class="javascript">var ordinalScale = d3.scale.ordinal();

ordinalScale.domain(alphabet);

ordinalScale.rangeBands([1,27]);</code></pre>
</p>
<p>
Here the range is defined as the continuous interval between 1 to 27.
</p>
<p>
The range will be converted to 26 evenly-spaced bands where 26 is the number of unique discreet values in the input domain.
</p>
<p>
Which explains the number 27.
</p>
<p>
For points, there are 26 points between 1 and 26 inclusive
</p>
<p>
While there are 26 bands between the number 1 and 27 inclusive.
</p>
<br>
<p>
Before we test a few letters, let's check to see what the ordinalScale rangeBand is...
</p>
<p>
<pre><code class="javascript">ordinalScale.rangeBand();</code></pre>
</p>
<p>
The RangeBand returns the band width, which is 1.
</p>
<p>
This method is used in conjunction with rangeBands or rangeRoundBands.
</p>
<br>
<p>
Let's test a few letters
</p>
<p>
<pre><code class="javascript">ordinalScale("A");

ordinalScale("B");

ordinalScale("E");

ordinalScale("Z");</code></pre>
</p>
<p>
The ordinal Scale worked!
</p>
<p>
The letter "A" was mapped to point 1
</p>
<p>
The letter "B" was mapped to point 2
</p>
<p>
The letter "E" was mapped to point 5
</p>
<p>
and The letter "Z" was mapped to point 26.
</p>
<p>
Notice that the Letter Z was mapped to the point 26 and not 27.
</p>
<p>
This is because the letter Z is in the band between 26 and 27, so it shows up on the 26.
</p>
<br>
<p>
Finally, let's take a look at the categorical colors.
</p>
<p>
<pre><code class="javascript">var color = d3.scale.category10();</code></pre>
</p>
<p>
This defines color as a D3 ordinal scale that has 10 categorical colors.
</p>
<br>
<p>
Let's test the scale with 10 numbers to see how it works
</p>
<p>
<pre><code class="javascript">[color(1), color(2), color(3), color(4), color(5), color(6), color(7),color(8), color(9), color(10)];</code></pre>
</p>
<p>
It's done in an array so we can see all of the 10 numbers.
</p>
<p>
As you can see this generates 10 HTML Colors
</p>
<p>
This is used frequently in the examples and is very handy to have around.
</p>
<br>
<p>
And with that we explored the basics of D3 Ordinal Scales.
</p>
<p>
Now that we have covered D3 Linear Scales, D3 Time Scales and D3 Ordinal Scales we have the necessary scale tools to start building the basic D3 charts.
</p>
        </div>
      </div>
    ☺</div>


<hr>
<h3 id="lesson41">Basic Chart - Scatterplot<h3>
    <div>
     <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>You will use the TSV data from the D3js.org website Scatterplot Example to see how a full D3 Scatterplot data visualization is built</li>
<li>Notice that the styling is done in the &lt;style&gt; &lt;/style&gt; section of the HTML document</li>
<li>Notice the D3 Margin Convention</li>
<li>Notice the D3 Linear Scale for the X-Axis</li>
<li>Notice the D3 Linear Scale for the Y-Axis</li>
<li>Notice the D3 Ordinal Scale for color - d3.scale.category10()</li>
<li>Notice the D3 SVG Axis Component creation and definition of the X-Axis and Y-Axis</li>
<li>Notice the D3 Type-specific XHR call - d3.tsv(...)</li>
<li>Notice the setting of the domain for the X-Axis and Y-Axis scales</li>
<li>Notice the use of the D3 .nice() functionality</li>
<li>Notice the D3 SVG Axis Component instantiation of the X-Axis and Y-Axis</li>
<li>Notice the D3 Data Join</li>
<li>Notice how D3 helps create visual representations of the data</li>
<li>Notice how a second D3 Data Join is used to create the legend for the Scatterplot Visualization </li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/putting-it-all-together">Putting It All Together</a></li>
<li><a href="https://www.dashingd3js.com/lessons/javascript-callback-functions">JavaScript Callback Functions</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-requests">D3 Requests</a></li>
<li><a href="https://www.dashingd3js.com/lessons/loading-data-from-server">Loading Data From Server</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-line-chart">Basic Chart - Line Chart</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-ordinal-scales">D3 Ordinal Scales</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            Basic Chart - Scatterplot
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
Visual Code Walk Through
</strong>
</p>
<br>
<p>
[ Image: Scatterplot Example ]
</p>
<p>
We will use the TSV Data from the D3js.org website Scatterplot Example.
</p>
<br>
<p>
[ Image: Data for Scatterplot Example ]
</p>
<p>
We will save this data into a file called data.tsv
</p>
<p>
This file will be located in the folder where we will run the python SimpleHTTPServer command.
</p>
<p>
This file is the one that will be loaded asynchronously using the D3.tsv request functionality.
</p>
<br>
<p>
Let's walk through the D3.js code together.
</p>
<p>
BROWSER HIGHLIGHT First section
</p>
<p>
<pre><code class="html">&lt;!-DOCTYPE...........&lt;meta....&gt;</code></pre>
</p>
<p>
We start at the top of the document.
</p>
<p>
First is the Document Type Declaration.
</p>
<p>
This tells the browser how to render the page in a standards compliant mode.
</p>
<p>
This specific doctype is the correct declaration for HTML5.
</p>
<p>
Next comes the meta character set.
</p>
<p>
This sets the character set to UTF-8.
</p>
<p>
If you are using non-minified D3.js this is important because the D3 javaScript file needs this particular type of encoding.
</p>
<br>
<p>
The next section is the style definition of the document.
</p>
<p>
BROWSER Highlight &lt;style&gt;
</p>
<p>
This is where the CSS style of the HTML and SVG DOM Elements are defined.
</p>
<p>
This allows for separation of concerns.
</p>
<p>
The D3 code processes the data and creates the DOM Elements and the CSS styles them.
</p>
<br>
<p>
This CSS defines the style for the body element.
</p>
<p>
BROWSER Highlight body { ...}
</p>
<p>
Here, the CSS specifies that the font should be 10px tall and should use a sans-serif font.
</p>
<br>
<p>
The next section defines the style for the axis path and line.
</p>
<p>
BROWSER Highlight .axis.... }
</p>
<p>
The .axis path and .axis line are both HTML classes that have a style associated with them.
</p>
<p>
Here the code is saying no fill and sets the color of the stroke to hashmark 000 which is the HTML Color for black
</p>
<p>
And finally, it tells the browser that the SVG Content should use the shape-rendering attribute of crisp edges.
</p>
<br>
<p>
The next section defines the style for a DOM element class called "dot"
</p>
<p>
BROWSER Highlight .dot {.....}
</p>
<p>
This defines the stroke of the outside of the circle that will be assigned to each data point.
</p>
<p>
The stroke in this case will be black.
</p>
<p>
Note that the inside color of the circle is not defined.
</p>
<p>
This is because the inside color will depend on the data.
</p>
<p>
So we leave the inside color definition to the D3 JavaScript Code.
</p>
<br>
<p>
Next we go into the JavaScript Sections of the document.
</p>
<br>
<p>
First, we load the D3.js code from the web.
</p>
<p>
BROWSER Highlight <script src....></script>
</p>
<p>
You can use this or a local version for personal and educational projects.
</p>
<p>
If you are doing a commercial project you should use your own version hosted on your own server or content delivery network.
</p>
<p>
This ensures that you are aware of what version you are using and it doesn't change without your knowledge.
</p>
<br>
<p>
Next, we go into the D3 code.
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 40},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;</code></pre>
</p>
<p>
This is the D3 Margin Convention.
</p>
<p>
It specifies what margins the Inner Drawing Space will have in order to separate it from the overall SVG Container.
</p>
<p>
Then the width and height for the Inner Drawing Space are defined in terms of the margins and the overall width and height of the SVG Container.
</p>
<p>
The SVG Container will be 500 pixels tall by 960 pixels wide.
</p>
<br>
<p>
Next we have a scale linear function for the x-axis data.
</p>
<p>
<pre><code class="javascript">var x = d3.scale.linear()
    .range([0, width]);</code></pre>
</p>
<p>
This code creates a linear scaling function where the range goes from 0 to the width of the Inner Drawing Space.
</p>
<p>
So as the x axis variable grows it will move from the left to the right.
</p>
<br>
<p>
Next we have a scale linear function for the y-axis data.
</p>
<p>
<pre><code class="javascript">var y = d3.scale.linear()
    .range([height, 0]);</code></pre>
</p>
<p>
This code creates a scaling function where the range goes from the height of the inner drawing space to 0.
</p>
<p>
Why backwards?
</p>
<p>
Because this inverts the SVG Coordinate Space along the Y-Axis.
</p>
<p>
Let me repeat that - this inverts the SVG Coordinate Space along the Y-Axis.
</p>
<p>
Which means that the origin point will now be at the bottom left instead of the top left.
</p>
<p>
So as the y axis variable grows it will move up rather than down.
</p>
<br>
<p>
Next we have an Ordinal Scale that will be used to color the fill of the SVG Circle Elements
</p>
<p>
<pre><code class="javascript">var color = d3.scale.category10();</code></pre>
</p>
<p>
This code creates a categorical color scale function that produces 10 HTML colors.
</p>
<p>
Based on the Data, D3 will do the color choosing for us.
</p>
<br>
<p>
Next we create the X-Axis function
</p>
<p>
<pre><code class="javascript">var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");</code></pre>
</p>
<p>
We pass in the x-scale function we created earlier and give the axis an orientation of bottom.
</p>
<p>
This means that the text will be below the line.
</p>
<p>
How can we pass in the x scale function before we give it a domain?
</p>
<p>
The reason we can do this is because the x scale function is a function.
</p>
<p>
Until we call it, we can continue to modify the function.
</p>
<p>
So the xAxis function itself now contains the x-scale function.
</p>
<p>
Nothing is executed until the x-axis function itself is called.
</p>
<br>
<p>
Then we create the Y-Axis the same way
</p>
<p>
<pre><code class="javascript">var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");</code></pre>
</p>
<p>
We pass in the y-scale function we created earlier and give the axis an orientation of left.
</p>
<p>
This orientation will make the axis vertical and make the text appear on the left of the line.
</p>
<br>
<p>
The next code creates the SVG Container and the Inner Drawing Space.
</p>
<p>
<pre><code class="javascript">var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
First the code selects the body and then appends an SVG Container.
</p>
<p>
Then the code defines the width and height attributes of the SVG Container in terms of the inner drawing space width and height and the relevant margins.
</p>
<p>
Then the code appends an SVG Group Element which will be the Inner Drawing Space.
</p>
<p>
This Inner Drawing Space is transform translated to the right and down by the relevant margins.
</p>
<p>
All of this is assigned to the variable SVG which everything else in the code will use as the reference drawing space.
</p>
<br>
<p>
The next code is where the D3 code magic happens.
</p>
<p>
BROWSER HIGHLIGHT all d3.tsv
</p>
<p>
This is where D3 does an XHR type specific call to the server to get the "data.tsv" file.
</p>
<p>
Once the server responds with the file, the D3.tsv function calls the callback function with two arguments, the error and the data.
</p>
<p>
In this case, the callback function is an anonymous function.
</p>
<br>
<p>
Let's go through the callback function section by section.
</p>
<br>
<p>
First, we have code that iterates through the array of JavaScript objects
</p>
<p>
<pre><code class="javascript">data.forEach(function(d) {
    d.sepalLength = +d.sepalLength;
    d.sepalWidth = +d.sepalWidth;
});</code></pre>
</p>
<p>
For each JavaScript object it does two things:
</p>
<p>
One - it converts the sepalLength from a string to a number
</p>
<p>
and Two - it converts the sepalWidth from a string to a number.
</p>
<br>
<p>
The D3 forEach iteration method is used on the data array.
</p>
<p>
<pre><code class="javascript">forEach</code></pre>
</p>
<p>
Is an iteration method D3 provides for iterating through a JavaScript array.
</p>
<p>
It applies the function specified to each element of the array.
</p>
<p>
In this case, it is applying an anonymous function to each element.
</p>
<p>
This function redefines the values it finds to the same keys in the same objects.
</p>
<p>
This is to convert the data to a more usable type of data.
</p>
<p>
Since each value of the key,value pairs is a JavaScript String, this code iterates through the JavaScript Objects and redefines the values from strings to numbers for the sepalLength and sepalWidth.
</p>
<br>
<p>
The + sign in front of the d dot sepalLength converts the string to a number.
</p>
<p>
<pre><code class="javascript">d.sepalLength = +d.sepalLength;</code></pre>
</p>
<p>
This is a quick way to convert a string to a number in JavaScript.
</p>
<br>
<p>
The + sign in front of the d dot sepalWidth converts the string to a number.
</p>
<p>
<pre><code class="javascript">d.sepalWidth = +d.sepalWidth;</code></pre>
</p>
<p>
This is a quick way to convert a string to a number in JavaScript.
</p>
<br>
<p>
Next, we set the domain for the x scale function
</p>
<p>
<pre><code class="javascript">x.domain(d3.extent(data, function(d) { return d.sepalWidth; })).nice();</code></pre>
</p>
<p>
Now that we have the data, we can set the domain of the x scale function by using the D3.extent method.
</p>
<p>
The D3.extent function returns an array containing the minimum and maximum sepalWidths.
</p>
<p>
This array then gets passed to the domain.
</p>
<p>
Then using the chaining syntax we call the dot nice function.
</p>
<br>
<p>
The dot nice open parenthesis close parenthesis function is something new that has not been covered before.
</p>
<p>
<pre><code class="javascript">.nice()</code></pre>
</p>
<p>
Dot nice extends the domain so that it starts and ends on nice round values.
</p>
<p>
This method typically modifies the scale's domain, and may only extend the bounds to the nearest round value.
</p>
<p>
When using the dot nice functionality, it's often called nicing.
</p>
<p>
Nicing is particularly useful if the domain is computed from data which may be irregular.
</p>
<br>
<p>
Next, we set the domain for the y scale function
</p>
<p>
<pre><code class="javascript">y.domain(d3.extent(data, function(d) { return d.sepalLength; })).nice();</code></pre>
</p>
<p>
Now that we have the data, we can set the domain of the y scale function by using the D3.extent method.
</p>
<p>
The D3.extent function returns an array containing the minimum and maximum sepalLengths.
</p>
<p>
This array then gets passed to the domain.
</p>
<p>
Then using the chaining syntax, we call the dot nice function.
</p>
<br>
<p>
Next, we call D3.axis operator for the x-axis.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
  .append("text")
    .attr("class", "label")
    .attr("x", width)
    .attr("y", -6)
    .style("text-anchor", "end")
    .text("Sepal Width (cm)");</code></pre>
</p>
<p>
First the code appends an SVG Group Element to hold the x-axis.
</p>
<p>
Then the group element is given the class of "x axis"
</p>
<p>
Then it is transform translated by the height of the inner drawing space.
</p>
<p>
This transform translate moves the G element containing the X-Axis elements to the bottom of the Inner Drawing Space.
</p>
<p>
Then, the xAxis function is called.
</p>
<p>
This works correctly because we have now defined the x scaling function domain and range.	
</p>
<p>
Finally, we append text to the X Axis which will be used as an axis label.
</p>
<p>
The SVG Text element is given a DOM ELEMENT class attribute.
</p>
<p>
Then the y and x attributes are defined.
</p>
<p>
The style is defined as a text-anchor and placed at the end of the X axis.
</p>
<p>
And lastly, the text for the SVG Text is defined.
</p>
<p>
Overall, this places a small label on the X Axis.
</p>
<br>
<p>
Next, we call D3.axis operator for the y-axis.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "y axis")
    .call(yAxis)
  .append("text")
    .attr("class", "label")
    .attr("transform", "rotate(-90)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Sepal Length (cm)");</code></pre>
</p>
<p>
First the code appends an SVG Group Element to hold the y-axis.
</p>
<p>
Then the group element is given the class of y axis
</p>
<p>
Then then yAxis function is called.
</p>
<p>
This works correctly because we have now defined the y scaling function domain and range.
</p>
<p>
Finally, we append text to the Y Axis which will be used as an axis label.
</p>
<p>
The SVG Text element is given a DOM ELEMENT class attribute.
</p>
<p>
This text is transformed by rotating it -90 degrees.
</p>
<p>
Then the y and dy attributes are defined.
</p>
<p>
The style is defined as a text-anchor and placed at the end of the Y axis.
</p>
<p>
And lastly, the text for the SVG Text is defined.
</p>
<p>
Overall, this places a small label on the Y Axis.
</p>
<br>
<p>
Next we draw the dots that represent the data in the graph.
</p>
<p>
<pre><code class="javascript">svg.selectAll(".dot")
    .data(data)
  .enter().append("circle")
    .attr("class", "dot")
    .attr("r", 3.5)
    .attr("cx", function(d) { return x(d.sepalWidth); })
    .attr("cy", function(d) { return y(d.sepalLength); })
    .style("fill", function(d) { return color(d.species); });</code></pre>
</p>
<p>
This is the D3 pattern.
</p>
<p>
We selectAll a class of DOM Elements which do not yet exist.
</p>
<p>
We bind the data to these elements.
</p>
<p>
We choose the enter selection.
</p>
<p>
We append and merge the SVG Circle Elements with the placeholder elements created by the Data Functionality.
</p>
<p>
Then we add specific attributes to the SVG Circle Elements to create them specifically from the data.
</p>
<p>
The DOM Element Class is defined as dot for all of the circles.
</p>
<p>
The radius is defined as 3.5 for all of the circles.
</p>
<p>
The cx attribute is defined as the sepalWidth
</p>
<p>
The cy attribute is defined as the sepalLength
</p>
<p>
And the fill color is defined using the Ordinal Categorical Color Scale Category10 .
</p>
<p>
This makes it so that every data point in the data will have it's own specific cx, cy and fill color.
</p>
<br>
<p>
A very important thing happens when we assign the fill color that is worth paying very close attention to.
</p>
<p>
<pre><code class="javascript">.style("fill", function(d) { return color(d.species); });</code></pre>
</p>
<p>
This code does two things at once.
</p>
<p>
In addition to having the Category Scale choose a color for us
</p>
<p>
This also adds the species name to the domain of the category function if it doesn't already exist.
</p>
<p>
Let me say that again, in addition to have the category scale choose a color for us
</p>
<p>
This also adds the species name to the domain of the category function if it doesn't already exist.
</p>
<p>
Which means that if we pass in a species name to the color Ordinal Scale, it will always return the same color.
</p>
<p>
It also means that after all the circles have been created, the domain of the Color Ordinal Scale will have a list of all the species that were created.
</p>
<p>
This is very useful as you'll see shortly.
</p>
<br>
<p>
Lastly, we create a Legend for the Scatterplot Chart.
</p>
<p>
<pre><code class="javascript">var legend //............</code></pre>
</p>
<p>
This is done in three separate sections of code.
</p>
<p>
The first section creates a legend for each of the Species Types
</p>
<p>
The second section creates a rectangle that contains the color of that species for each of the Species Types.
</p>
<p>
The third section creates the text of the species name for each of the Species Types.
</p>
<br>
<p>
Let's walk through each section.
</p>
<br>
<p>
The first section creates an SVG Group Element with a class of legend for each Species Type.
</p>
<p>
<pre><code class="javascript">var legend = svg.selectAll(".legend")
    .data(color.domain())
  .enter().append("g")
    .attr("class", "legend")
    .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });</code></pre>
</p>
<p>
This follows the D3 pattern.
</p>
<p>
We selectAll a class of DOM Elements which do not yet exist.
</p>
<p>
We bind the data to these elements.
</p>
<p>
The data here is the domain of the color Ordinal Scale.
</p>
<p>
This is where it was very useful that the color fill of the circles not only choose a color, but also added each species type to the domain of the color ordinal scale.
</p>
<p>
We choose the enter selection.
</p>
<p>
We append and merge the SVG Group Elements with the placeholder elements created by the Data Functionality.
</p>
<p>
Then we add specific attributes to the SVG Group Elements to create them specifically from the data.
</p>
<p>
The DOM Element Class is defined as legend for all of the SVG Group Elements created by the data.
</p>
<p>
Then each legend is transform translated to a specific part of the graph based on the index.
</p>
<p>
This is so that the Legends will all be on top of one another in the same part of the chart.
</p>
<br>
<p>
The second section creates a rectangle that contains the color of that species for each of the Species Types.
</p>
<p>
<pre><code class="javascript">legend.append("rect")
    .attr("x", width - 18)
    .attr("width", 18)
    .attr("height", 18)
    .style("fill", color);</code></pre>
</p>
<p>
This code takes the selection of All the legends created in the previous code section and appends SVG Rectangles.
</p>
<p>
The rectangle's width and height attributes are set to hard-coded values.
</p>
<p>
The rectangle's x attribute is set so that it is 18 pixels off of the right edge of the chart.
</p>
<p>
This is done by subtracting 18 from the width variable, which is the width of the inner drawing space.
</p>
<p>
Lastly, the fill of each color is defined by the color Ordinal Scale.
</p>
<p>
One thing to notice here is that the passing of the data object is not explicit.
</p>
<p>
D3 implicitly understands that it should use the Data bound to the specific Legend.
</p>
<p>
Thus it it is able to use the data passed into the style call for the legend without having it be specified.
</p>
<br>
<p>
The third section creates the text of the species name for each of the Species Types.
</p>
<p>
<pre><code class="javascript">legend.append("text")
    .attr("x", width - 24)
    .attr("y", 9)
    .attr("dy", ".35em")
    .style("text-anchor", "end")
    .text(function(d) { return d; });</code></pre>
</p>
<p>
This code takes the selection of All the legends created in the first code section and appends SVG Text.
</p>
<p>
The SVG Text's y and dy attributes are set to hard-coded values.
</p>
<p>
The SVG Text's x attribute is set so that it is 24 pixels off of the right edge of the chart.		
</p>
<p>
This is done by subtracting 24 from the width variable, which is the width of the Inner Drawing Space.
</p>
<p>
Lastly, the actual text of the SVG Text element is defined by the anonymous function which returns the data attached to each SVG Group Element with the class of Legend.
</p>
<p>
The function is defined explicitly to make sure the right data is assigned. 
</p>
<br>
<p>
And that is the end of the callback function and the end of the d3.tsv function.
</p>
<p>
<pre><code class="javascript">});</code></pre>
</p>
<p>
When this is done the graph will have been fully generated.
</p>
<br>
<p>
Let's now build this part by part in JavaScript.
</p>
<br>
<br>
<p>
<strong>
JavaScript Code Build
</strong>
</p>
<br>
<p>
Because the building of the chart happens inside of the callback function, we will use a more simple anonymous callback function
</p>
<p>
<pre><code class="javascript">d3.tsv("data.tsv", function(error, data){...});

// =>

var callbackError;

var callbackData;

d3.tsv("data.tsv", function(error, data){
    callbackError = error;
    callbackData = data;
});</code></pre>
</p>
<br>
<p>
We do this in this way for two reasons:
</p>
<p>
one - it's easier to do in the JavaScript console as we build the chart piece by piece
</p>
<p>
and two, it reinforces the idea of the callback function and how it works.
</p>
<p>
Though, to be honest, the preferred way of coding it when you code it into your web page is the way it's done in the example.
</p>
<p>
That way it is clear that it is a callback function and it is all in one place.
</p>
<br>
<p>
Alright, to the JavaScript Console.
</p>
<br>
<p>
CLEAR CHROME BROWSER CACHE
</p>
<br>
<p>
We start by saving the example data into the data.tsv file.
</p>
<p>
This file lives in the folder where we will start the Python SimpleHTTPServer.
</p>
<p>
save the data.
</p>
<br>
<p>
Next, we start the Python SimpleHTTPServer from the command line
</p>
<p>
<pre><code class="python">cd Desktop/d3_projects/

python -m SimpleHTTPServer</code></pre>
</p>
<p>
Now, we have the server going and have the data file ready to be served up.
</p>
<br>
<p>
Next, we make sure the index.html file is saved in the right place and has D3 being loaded into it.
</p>
<p>
Show index file and save it.
</p>
<p>
BROWSER - go to the 0.0.0.0:8000/ or localhost:8000/
</p>
<p>
We can see the web page.
</p>
<br>
<p>
We open the Chrome Developer tools and test to make sure D3 loaded correctly then clear the screen.
</p>
<p>
<pre><code class="javascript">d3.version;

clear();</code></pre>
</p>
<p>
D3 loaded correctly.
</p>
<p>
Now we clear the screen.
</p>
<br>
<p>
Next, we go step by step building the visualization.
</p>
<br>
<p>
We start by defining the callbackError and callbackData variables which will be used to house the data we get back from the d3.tsv function.
</p>
<p>
<pre><code class="javascript">var callbackError;

var callbackData;</code></pre>
</p>
<br>
<p>
The first step from the example is defining the margins and the width and height of the Inner Drawing Space.
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 40},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;</code></pre>
</p>
<br>
<p>
Next - define the x scaling function as well as the range of the function
</p>
<p>
<pre><code class="javascript">var x = d3.scale.linear()
    .range([0, width]);</code></pre>
</p>
<br>
<p>
Next - define the y scaling function as well as the range of the function
</p>
<p>
Remember to pay attention to the fact that the range has height first and then 0 - which inverts the y-axis.
</p>
<p>
<pre><code class="javascript">var y = d3.scale.linear()
    .range([height, 0]);</code></pre>
</p>
<br>
<p>
Next - define the xAxis function and provide it with a scale and orientation.
</p>
<p>
<pre><code class="javascript">var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");</code></pre>
</p>
<br>
<p>
Next - define the yAxis function and provide it with a scale and orientation as well.
</p>
<p>
<pre><code class="javascript">var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");</code></pre>
</p>
<br>
<p>
Next - define the SVG Container and the Inner Drawing Space
</p>
<p>
<pre><code class="javascript">var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
BROWSER - Open the Body element, the SVG element and show the inner SVG Group Element.
</p>
<p>
This is the first sign of anything occurring in the browser.
</p>
<p>
Up to now we have just been defining functions that will use or be used by the data that is passed in.
</p>
<br>
<p>
This code is where we are going to differ from the example code.
</p>
<p>
<pre><code class="javascript">d3.tsv("data.tsv", function(error,data) {
    callbackError = error;
    callbackData  = data;
});</code></pre>
</p>
<p>
Instead of defining an anonymous callback function that does all the generating of the chart in one go, we will define a callback function that assigns the data and error to variables.
</p>
<p>
We'll then use these variables to build the Scatterplot chart.
</p>
<br>
<p>
Let's check what the d3.tsv call assigned to the callbackError variable.
</p>
<p>
<pre><code class="javascript">callbackError;</code></pre>
</p>
<p>
The callbackError is null, which means the D3.tsv call worked correctly.
</p>
<br>
<p>
Let's check what the d3.tsv call assigned to the callbackData variable.
</p>
<p>
<pre><code class="javascript">callbackData;</code></pre>
</p>
<p>
The callbackData is an array of 150 elements, which means the D3.tsv call worked correctly.
</p>
<br>
<p>
Let's take a look at the first element of this array.
</p>
<p>
<pre><code class="javascript">callbackData[0];</code></pre>
</p>
<p>
You can see that it is a JavaScript object that has the key,value pairs for sepalLenght, sepalWidth, petalLength, petalWidth and species.
</p>
<p>
Each value is currently a string.
</p>
<br>
<p>
Next - we use the D3 Array forEach iterator to go through the array and change the string values to Numbers.
</p>
<p>
<pre><code class="javascript">callbackData.forEach(function(d) {
    d.sepalLength = +d.sepalLength;
    d.sepalWidth = +d.sepalWidth;
});</code></pre>
</p>
<br>
<p>
Let's take a look now at the first element of this array.
</p>
<p>
<pre><code class="javascript">callbackData[0];</code></pre>
</p>
<p>
You can see that the values for sepalLength and sepalWidth are no longer strings - they are now numbers.
</p>
<br>
<p>
To check to make sure the sepalLength is now a JavaScript number we can use the typeof JavaScript function:
</p>
<p>
<pre><code class="javascript">typeof(callbackData[0]['sepalLength']);</code></pre>
</p>
<p>
Which tell us it is a number.
</p>
<br>
<p>
To check to make sure the sepalWidth is now a JavaScript number we can use the typeof JavaScript function:
</p>
<p>
<pre><code class="javascript">typeof(callbackData[0]['sepalWidth']);</code></pre>
</p>
<p>
Which tell us it is a number.
</p>
<br>
<p>
Satisfied that both sepalLength and sepalWidth are both numbers, let's move on.
</p>
<br>
<p>
Next - define the domain of the x scale function
</p>
<p>
<pre><code class="javascript">x.domain(d3.extent(callbackData, function(d) { return d.sepalWidth; })).nice();</code></pre>
</p>
<br>
<p>
Let's check to see what the extent was for the x-scale
</p>
<p>
<pre><code class="javascript">d3.extent(callbackData, function(d) { return d.sepalWidth; });</code></pre>
</p>
<p>
We can see that the lowest sepalWidth is 2 and the highest sepalWidth is 4.4.
</p>
<br>
<p>
Let's also check to see what the domain of the x scale function is
</p>
<p>
<pre><code class="javascript">x.domain();</code></pre>
</p>
<p>
You can see that the domain is the same as what the extent function provided.
</p>
<p>
This means that the nicing provided by the nice function did not alter the domain.
</p>
<br>
<p>
Next - define the domain of the y scale function
</p>
<p>
<pre><code class="javascript">y.domain(d3.extent(callbackData, function(d) { return d.sepalLength; })).nice();</code></pre>
</p>
<br>
<p>
Let's check to see what the extent was for the y-scale
</p>
<p>
<pre><code class="javascript">d3.extent(callbackData, function(d) { return d.sepalLength; });</code></pre>
</p>
<p>
We can see that the lowest sepalLength is 4.3 and the highest sepalLength is 7.9
</p>
<br>
<p>
Let's also check to see what the domain of the y scale function is
</p>
<p>
<pre><code class="javascript">y.domain()</code></pre>
</p>
<p>
You can see that the domain is NOT same as what the extent function provided.
</p>
<p>
This means that the nicing provided by the nice function did alter the domain.
</p>
<p>
It made the ends nicer.
</p>
<p>
Instead of the lowest value being 4.3 it is now 4.0
</p>
<p>
Instead of the highest value being 7.9 it is now 8.0
</p>
<p>
This is what using the nice function can do for us.
</p>
<br>
<p>
Next - define the Categorical Color Ordinal Scale
</p>
<p>
<pre><code class="javascript">var color = d3.scale.category10();</code></pre>
</p>
<br>
<p>
Next - the x-axis is created
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
  .append("text")
    .attr("class", "label")
    .attr("x", width)
    .attr("y", -6)
    .style("text-anchor", "end")
    .text("Sepal Width (cm)");</code></pre>
</p>
<p>
Note again that the transform translate moves the x-axis Group element to the bottom of the Inner Drawing Space.
</p>
<p>
On my screen, you can see the start of the x-axis as Chrome developer tools are taking up about 2/3s of the web page.
</p>
<p>
That said, you can see the number 2.0 to the number 2.8.
</p>
<p>
BROWSER - click into the G element
</p>
<p>
If we click into the SVG Group Element for the Inner Drawing Space
</p>
<p>
You can see the SVG Group element with the class "x axis".
</p>
<p>
This is the X axis.
</p>
<br>
<p>
Next - the y-axis is created.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "y axis")
    .call(yAxis)
  .append("text")
    .attr("class", "label")
    .attr("transform", "rotate(-90)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Sepal Length (cm)");</code></pre>
</p>
<p>
You can see the y-axis and the text anchor declaring that it is the Sepal Length in Centimeters.
</p>
<p>
BROWSER - click into the G element
</p>
<p>
If we click into the SVG Group Element for the Inner Drawing Space
</p>
<p>
You can see the SVG Group element with the class "y axis".
</p>
<p>
This is the y axis.
</p>
<br>
<p>
Now we create the dots according to the data.
</p>
<p>
<pre><code class="javascript">svg.selectAll(".dot")
    .data(callbackData)
  .enter().append("circle")
    .attr("class", "dot")
    .attr("r", 3.5)
    .attr("cx", function(d) { return x(d.sepalWidth); })
    .attr("cy", function(d) { return y(d.sepalLength); })
    .style("fill", function(d) { return color(d.species); });</code></pre>
</p>
<p>
And there you have it - you can see the data represented as dots.
</p>
<br>
<p>
Because we are not applying any CSS to style the dots, let's do the stroke line of the circles in D3.
</p>
<p>
<pre><code class="javascript">svg.selectAll(".dot").attr("stroke","black");</code></pre>
</p>
<p>
This is done in CSS in the example.
</p>
<br>
<p>
Lastly, let's create the legend to the graph in three parts
</p>
<br>
<p>
First, we create the 3 SVG Group elements with the class of legend.
</p>
<p>
<pre><code class="javascript">ar legend = svg.selectAll(".legend")
    .data(color.domain())
  .enter().append("g")
    .attr("class", "legend")
    .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });</code></pre>
</p>
<p>
BROWSER - Scroll down the elements.
</p>
<p>
Though the Chrome Developer Tools are currently covering up the legend, we can see the DOM elements are there.
</p>
<br>
<p>
Second, we create the rectangles filled with color inside of the 3 legends.
</p>
<p>
<pre><code class="javascript">legend.append("rect")
    .attr("x", width - 18)
    .attr("width", 18)
    .attr("height", 18)
    .style("fill", color);</code></pre>
</p>
<p>
BROWSER - Click into the first legend
</p>
<p>
Here you can see the SVG Rectangle and the attributes that were defined for it.
</p>
<br>
<p>
Lastly, we create the text that goes along with the legends
</p>
<p>
<pre><code class="javascript">legend.append("text")
    .attr("x", width - 24)
    .attr("y", 9)
    .attr("dy", ".35em")
    .style("text-anchor", "end")
    .text(function(d) { return d; });</code></pre>
</p>
<p>
BROWSER - Click into the text element and click on "setosa"
</p>
<p>
Here you can see the SVG text element as well as the text inside of the element.
</p>
<br>
<p>
And there we go, we have the finished Scatterplot chart.
</p>
<br>
<p>
Let's close the Chrome Developer tools to get a better look.
</p>
<p>
BROWSER - close the Chrome Developer Tools.
</p>
<p>
BROWSER - zoom out.
</p>
<p>
You can see the full picture.
</p>
<br>
<p>
The only difference between this and the example was the styling applied to the various DOM Elements.
</p>
<br>
<p>
And with that we built the Basic Chart Scatterplot.
</p>
<p>
We used Data served from a web server and processed it through an asynchronous XHR call provided by the D3.tsv type specific method.
</p>
        </div>
      </div>
    
    ☺</div>


<hr>
<h3 id="lesson42">Basic Chart - Bar Chart<h3>
    <div>
        <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>You will use the TSV data from the D3js.org website Scatterplot Example to see how a full D3 Scatterplot data visualization is built</li>
<li>Notice that the styling is done in the &lt;style&gt; &lt;/style&gt; section of the HTML document</li>
<li>Notice the D3 Margin Convention</li>
<li>Notice the D3 Formatting Function for the percentage formatting</li>
<li>Notice the D3 Ordinal Scale with rangeRoundBands for the X-Axis</li>
<li>Notice the D3 Linear Scale for the Y-Axis</li>
<li>Notice the D3 SVG Axis Component creation and definition of the X-Axis and Y-Axis</li>
<li>Notice the tickFormatting for the Y-Axis</li>
<li>Notice the D3 Type-specific XHR call - d3.tsv(...)</li>
<li>Notice the setting of the domain for the X-Axis and Y-Axis scales</li>
<li>Notice the D3 SVG Axis Component instantiation of the X-Axis and Y-Axis</li>
<li>Notice the D3 Data Join</li>
<li>Notice how D3 helps create visual representations of the data</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-line-chart">Basic Chart - Line Chart</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-ordinal-scales">D3 Ordinal Scales</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-ordinal-scales">Basic Chart - Scatterplot</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            Basic Chart - Bar Chart
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
Visual Code Walk Through
</strong>
</p>
<br>
<p>
[ Image: Bar Char Example ]
</p>
<p>
We will use the TSV Data from the D3js.org website Bar Chart Example.
</p>
<br>
<p>
[ Image: Data for Bar Chart Example ]
</p>
<p>
We will save this data into a file called data.tsv
</p>
<p>
This file will be located in the folder where we will run the python SimpleHTTPServer command.
</p>
<p>
This file is the one that will be loaded asynchronously using the D3.tsv request functionality.
</p>
<br>
<p>
Let's walk through the D3.js code together.
</p>
<p>
BROWSER HIGHLIGHT First section
</p>
<p>
<pre><code class="html">&lt;!-DOCTYPE...........&lt;meta....&gt;</code></pre>
</p>
<p>
We start at the top of the document.
</p>
<p>
First is the Document Type Declaration.
</p>
<p>
This tells the browser how to render the page in a standards compliant mode.
</p>
<p>
This specific doctype is the correct declaration for HTML5.
</p>
<p>
Next comes the meta character set.
</p>
<p>
This sets the character set to UTF-8.
</p>
<p>
If you are using non-minified D3.js, this is important because the D3 JavaScript file needs this particular type of encoding.
</p>
<br>
<p>
The next section is the style definition of the document.
</p>
<p>
BROWSER HIGHLIGHT &lt;style&gt;
</p>
<p>
This is where the CSS style of the HTML and SVG DOM Elements are defined.
</p>
<p>
This allows for separation of concerns.
</p>
<p>
The D3 code processes the data and creates the DOM Elements and the CSS styles them.
</p>
<br>
<p>
This CSS defines the style for the body element.
</p>
<p>
BROWSER HIGHLIGHT body { ...}
</p>
<p>
Here, the CSS specifies that the font should be 10px tall and should use a sans-serif font.
</p>
<br>
<p>
The next section defines the CSS style for the axis path and axis line html Classes.
</p>
<p>
BROWSER Highlight .axis.... }
</p>
<p>
The CSS specifies that no fill is needed.
</p>
<p>
Sets the stroke to the Hexadecimal number for the HTML Color Black
</p>
<p>
And also tells the browser that the SVG Content should use the shape-rendering attribute of crisp edges.
</p>
<br>
<p>
The next section defines the style for a DOM element class called "bar"
</p>
<p>
BROWSER HIGHLIGHT .bar {.....}
</p>
<p>
This defines the fill to blue for all of these DOM elements.
</p>
<br>
<p>
The next section defines the style for the x-axis path.
</p>
<p>
BROWSER HIGHLIGHT .x.axis ... }
</p>
<p>
Here the code is specifying that we do not want to display the path.
</p>
<p>
Why not just not draw it?
</p>
<p>
Because the code later uses the D3.axis functionality that auto generates the axis tick marks, spacing and line to connect all the ticks.
</p>
<p>
So rather than having to figure out how to not have the D3.axis functionality not draw the line that connects all the ticks, this CSS just hides it.
</p>
<br>
<p>
Next we go into the JavaScript Sections of the document.
</p>
<br>
<p>
First, we load the D3.js code from the web.
</p>
<p>
BROWSER HIGHLIGHT <script src....></script>
</p>
<p>
You can use this or a local version for personal and educational projects.
</p>
<p>
If you are doing a commercial project you should use your own version hosted on your own server or content delivery network.
</p>
<p>
This ensures that you are aware of what version you are using and it doesn't change without your knowledge.
</p>
<br>
<p>
Next, we go into the D3 code.
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 40},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;</code></pre>
</p>
<p>
This is the D3 Margin Convention.
</p>
<p>
It specifies what margins the Inner Drawing Space will have, in order to separate it from the overall SVG Container.
</p>
<p>
Then the width and height for the Inner Drawing Space are defined in terms of the margins and the overall width and height of the SVG Container.
</p>
<p>
The SVG Container will be 500 pixels tall by 960 pixels wide.
</p>
<br>
<p>
Next, we have a number formatting function.
</p>
<p>
<pre><code class="javascript">var formatPercent = d3.format(".0%");</code></pre>
</p>
<p>
The idea behind this code is that it will take in a number and convert it to a specific formatting.
</p>
<p>
D3 has a core library of formatting functions for numbers, dates and comma-separated values.
</p>
<p>
The formatting function has many types of formats available like binary, octal, rounded percentage, exponent and others.
</p>
<p>
The formatting function also allows you to add pre-fixes to numbers.
</p>
<p>
This allows you to add things like the character M to stand for Millions.
</p>
<p>
The formatting function also allows you to add the plus sign, minus sign, spaces and even specify whether the number is right or left aligned.
</p>
<p>
This particular code converts a number to a decimal percentage format.
</p>
<p>
So 0 point 1 1 gets converted to 11 percentage sign.
</p>
<br>
<p>
Next we have an ordinal scale function for the x-axis data.
</p>
<p>
<pre><code class="javascript">var x = d3.scale.ordinal()
    .rangeRoundBands([0, width], .1);</code></pre>
</p>
<p>
This code creates an ordinal scaling function where the range goes from 0 to the width of the Inner Drawing Space.
</p>
<p>
This ordinal scaling function is using the Range Round Bands to set the bands.
</p>
<p>
Also, the point 1 is the the padding added to offset the bands from the edge of the interval.
</p>
<br>
<p>
Next we have a scale linear function for the y-axis data.
</p>
<p>
<pre><code class="javascript">var y = d3.scale.linear()
    .range([height, 0]);</code></pre>
</p>
<p>
This code creates a linear scaling function where the range goes from the height of the inner drawing space to 0.
</p>
<p>
Why backwards?
</p>
<p>
Because this inverts the SVG Coordinate Space along the Y-Axis.
</p>
<p>
Let me repeat that - this inverts the SVG Coordinate Space along the Y-Axis.
</p>
<p>
Which means that the origin point will now be at the bottom left instead of the top left for numbers passed into this scaling function.
</p>
<p>
So as the y axis variable grows it will move up rather than down.
</p>
<br>
<p>
Next we create the X-Axis function
</p>
<p>
<pre><code class="javascript">var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");</code></pre>
</p>
<p>
We pass in the x-scale function we created earlier and give the axis an orientation of bottom.
</p>
<p>
This means that the text will be below the line.
</p>
<p>
Note that we pass in the x scale function before we give it a domain.
</p>
<p>
The reason we can do this is because the x scale function is a function.
</p>
<p>
Until we call it, we can continue to modify the function.
</p>
<p>
So the xAxis function itself now contains the x-scale function.
</p>
<p>
Nothing is executed until the x-axis function itself is called.
</p>
<br>
<p>
Then we create the Y-Axis the same way
</p>
<p>
<pre><code class="javascript">var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left")
    .tickFormat(formatPercent);</code></pre>
</p>
<p>
We pass in the y-scale function we created earlier and give the axis an orientation of left.
</p>
<p>
This orientation will make the axis vertical and make the text appear on the left of the line.
</p>
<p>
One new thing in this code is the dot tickformat() code.
</p>
<br>
<p>
The dot tickformat() functionality sets or gets the value formatter for labels of the D3 axis component.
</p>
<p>
<pre><code class="javascript">.tickFormat(formatPercent);</code></pre>
</p>
<p>
In this case, we are passing the number formatting function defined earlier to set the value formatter for the D3 Axis Component Generator Function.
</p>
<p>
This ensures that when the text labels for the ticks are generated, that they will have the format that was specified earlier.
</p>
<p>
So the Y axis labels will have the format of percentages rather than decimal numbers.
</p>
<p>
Again, instead of having a y-axis label be zero point 11, it will be 11 percent.
</p>
<br>
<p>
The next code creates the SVG Container and the Inner Drawing Space.
</p>
<p>
<pre><code class="javascript">var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
First the code selects the body and then appends an SVG Container.
</p>
<p>
Then the code defines the width and height attributes of the SVG Container in terms of the Inner Drawing Space width and height and the relevant margins.
</p>
<p>
Then the code appends an SVG Group Element which will be the Inner Drawing Space.
</p>
<p>
This Inner Drawing Space is transform translated to the right and down by the relevant margins.
</p>
<p>
All of this is then assigned to the variable SVG which everything else in the code will use as the reference drawing space.
</p>
<br>
<p>
The next code is where D3 asynchronously gets the data from the server and creates a bar chart.
</p>
<br>
<p>
BROWSER HIGHLIGHT all d3.tsv
</p>
<p>
D3 does an XHR type specific call to the server to get the "data.tsv" file.
</p>
<p>
Once the server responds with the file, the D3.tsv function calls the callback function with two arguments, the error and the data.
</p>
<p>
The anonymous callback function then uses the error and data variables to create the D3 Data Visualization.
</p>
<br>
<p>
Let's go through the callback function section by section.
</p>
<br>
<p>
First, we have code that iterates through the data variable which is an array of JavaScript objects 
</p>
<p>
<pre><code class="javascript">data.forEach(function(d) {
    d.frequency = +d.frequency;
});</code></pre>
</p>
<p>
For each JavaScript object it does one things:
</p>
<p>
It converts the frequency from a string to a number
</p>
<br>
<p>
The D3 forEach iteration method is used on the data array.
</p>
<p>
<pre><code class="javascript">forEach</code></pre>
</p>
<p>
Is an iteration method D3 provides for iterating through a JavaScript array.
</p>
<p>
It applies the function specified to each element of the array.
</p>
<p>
In this case, it is applying an anonymous function to each element.
</p>
<p>
This function redefines the values it finds to the same keys in the same objects.
</p>
<p>
This is used to convert the data to a more usable type of data.
</p>
<p>
Since each value of the key,value pairs is a JavaScript String, this code iterates through the JavaScript Objects and redefines the values from strings to numbers for the frequency variable.
</p>
<br>
<p>
The + sign in front of the d dot frequency converts the string to a number.
</p>
<p>
<pre><code class="javascript">d.frequency = +d.frequency;</code></pre>
</p>
<p>
This is a quick way to convert a string to a number in JavaScript.
</p>
<br>
<p>
Next, we set the domain for the x scale function
</p>
<p>
<pre><code class="javascript">x.domain(data.map(function(d) { return d.letter; }));</code></pre>
</p>
<p>
Now that we have the data, we can use the map function to generate an array of all the possible letters in the specific order of the JavaScript Objects in the callbackData variable.
</p>
<p>
We use this newly created array to set the domain of the Ordinal X Scale function.
</p>
<br>
<p>
Next, we set the domain for the y scale function
</p>
<p>
<pre><code class="javascript">y.domain([0, d3.max(data, function(d) { return d.frequency; })]);</code></pre>
</p>
<p>
Now that we have the data, we can set the domain of the y scale function by using the D3.max functionality.
</p>
<p>
The domain of the Y function is a continuous linear function, so the domain will be defined as going from 0 to the max frequency found in the data.
</p>
<p>
The d3.max function uses an anonymous function to go through all of the JavaScript objects in the data variable to look for the max frequency.
</p>
<p>
Once this is found, this number is used to set the domain of the y scaling function.
</p>
<br>
<p>
Next, we call D3.axis operator for the x-axis.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);</code></pre>
</p>
<p>
First the code appends an SVG Group Element to hold the x-axis.
</p>
<p>
Then the group element is given the class of "x axis"
</p>
<p>
Then it is transform translated by the height of the Inner Drawing Space.
</p>
<p>
This transform translate moves the G element containing the X-Axis elements to the bottom of the Inner Drawing Space.
</p>
<p>
Then, the xAxis function is called.
</p>
<p>
This works correctly because we have now defined the x scaling function domain and range. 
</p>
<br>
<p>
Next, we call D3.axis operator for the y-axis.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "y axis")
    .call(yAxis)
  .append("text")
    .attr("transform", "rotate(-90)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Frequency");</code></pre>
</p>
<p>
First the code appends an SVG Group Element to hold the y-axis.
</p>
<p>
Then the group element is given the class of "y axis"
</p>
<p>
Then then yAxis function is called.
</p>
<p>
This works correctly because we have now defined the y scaling function domain and range.
</p>
<p>
Finally, we append text to the Y Axis which will be used as an axis label.
</p>
<p>
This text is then transformed by rotating it -90 degrees.
</p>
<p>
Then the y and dy attributes are defined.
</p>
<p>
The style is defined as a text-anchor and placed at the end of the Y axis.
</p>
<p>
And lastly, the text for the SVG Text is defined as "Frequency"
</p>
<p>
Overall, this places a small label on the Y Axis.
</p>
<br>
<p>
Next we draw the bars that represent the data in the graph.
</p>
<p>
<pre><code class="javascript">svg.selectAll(".bar")
    .data(data)
  .enter().append("rect")
    .attr("class", "bar")
    .attr("x", function(d) { return x(d.letter); })
    .attr("width", x.rangeBand())
    .attr("y", function(d) { return y(d.frequency); })
    .attr("height", function(d) { return height - y(d.frequency); });</code></pre>
</p>
<p>
This is the D3 pattern.
</p>
<p>
We selectAll a class of DOM elements which do not yet exist.
</p>
<p>
We bind data to these elements.
</p>
<p>
We choose the enter selection.
</p>
<p>
We append and merge the SVG Rectangle Elements with the placeholder elements created by the Data Functionality.
</p>
<p>
Then we add SVG Rectangle Specific Attributes based on the data bound to the Rectangle elements.
</p>
<p>
Each rectangle gets the class of "bar".
</p>
<p>
This is used in the CSS to style the fill of the rectangles the color steelblue.
</p>
<p>
Then the x coordinate is determined by passing the letter of the Data Object bound to the specific element to the X Ordinal Scaling Function.
</p>
<p>
The X Ordinal Scaling Function takes in the X and produces a number in the range specified by the rangeRoundBands.
</p>
<p>
The Width of the rectangle is determined by the rangeBand of the X Ordinal Scaling Function.
</p>
<p>
The y coordinate is determined by passing the frequency of the Data Object bound to the specific element to the y Linear Scaling Function.
</p>
<p>
Lastly, the height of the rectangle is calculated as the difference of the height of the Inner Drawing Space and the frequency of the Object after it has gone through the y Linear Scaling Function.
</p>
<p>
This is done in this way because the Y axis has been inverted by the y scaling function for values passed into it, but not for the construction of SVG Rectangles.
</p>
<p>
We'll take a look at the Chrome Developer Tools in the JavaScript Section to really drive this point home.
</p>
<br>
<p>
And that is the end of the callback function and the end of the d3.tsv function.
</p>
<p>
<pre><code class="javascript">});</code></pre>
</p>
<p>
When this is done the graph will have been fully generated.
</p>
<br>
<p>
Let's now build this part by part in JavaScript.
</p>
<br>
<br>
<p>
<strong>
JavaScript Code Build
</strong>
</p>
<br>
<p>
Because the building of the chart happens inside of the callback function, we will use a more simple anonymous callback function.
</p>
<p>
<pre><code class="javascript">d3.tsv("data.tsv", function(error, data){...});

// =>

var callbackError;

var callbackData;

d3.tsv("data.tsv", function(error, data){
    callbackError = error;
    callbackData = data;
});</code></pre>
</p>
<p>
Notice that the order of the error and data arguments matter in the callback function definition.
</p>
<p>
The d3.tsv function is going to call the anonymous callback function with two variables.
</p>
<p>
The error will alway be first and the data will always be second.
</p>
<p>
So it's important to keep this order.
</p>
<p>
We use a more simple anonymous callback function for two reasons:
</p>
<p>
one - it's easier to do in the JavaScript console as we build the chart piece by piece
</p>
<p>
and two, it reinforces the idea of the callback function and how it works.
</p>
<p>
Though, to be honest, the preferred way of coding it when you code it into your web page is the way it's done in the example.
</p>
<p>
That way it is clear that it is a callback function and it is all in one place.
</p>
<br>
<p>
Alright, to the JavaScript Console.
</p>
<br>
<p>
CLEAR CHROME BROWSER CACHE
</p>
<br>
<p>
We start by saving the example data into the data.tsv file.
</p>
<br>
<p>
This file lives in the folder where we will start the Python SimpleHTTPServer.
</p>
<p>
Save the data.
</p>
<br>
<p>
Next, we start the Python SimpleHTTPServer from the command line
</p>
<p>
<pre><code class="python">cd Desktop/d3_projects/

python -m SimpleHTTPServer</code></pre>
</p>
<br>
<p>
Now, we have the server going and have the data file ready to be served up.
</p>
<br>
<p>
Next, we make sure the index.html file is saved in the right place and has D3 being loaded into it.
</p>
<p>
Show index file and save it.
</p>
<br>
<p>
BROWSER - go to the 0.0.0.0:8000/ or localhost:8000/
</p>
<p>
We can see the web page.
</p>
<br>
<p>
We open the Chrome Developer tools and test to make sure D3 loaded correctly and then clear the screen.
</p>
<p>
<pre><code class="javascript">d3.version;

clear();</code></pre>
</p>
<p>
D3 loaded correctly.
</p>
<p>
Now we clear the screen.
</p>
<br>
<p>
Next, we go step by step building the visualization.
</p>
<br>
<p>
We start by defining the callbackError and callbackData variables which will be used to house the data we get back from the d3.tsv function.
</p>
<p>
<pre><code class="javascript">var callbackError;

var callbackData;</code></pre>
</p>
<br>
<p>
The first step is defining the margins and the width and height of the Inner Drawing Space.
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 40},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;</code></pre>
</p>
<br>
<p>
Next we define the number formatting that will be used to format the numbers on the Y Axis.
</p>
<p>
<pre><code class="javascript">var formatPercent = d3.format(".0%");</code></pre>
</p>
<br>
<p>
Let's test the formatPercent functionality with 0 point 1 1
</p>
<p>
<pre><code class="javascript">formatPercent(0.11);</code></pre>
</p>
<p>
You can see that it returns the string of one one percentage sign - that is, 11 percent.
</p>
<br>
<p>
Next - define the x ordinal scaling function as well as the range round bands with padding.
</p>
<p>
<pre><code class="javascript">var x = d3.scale.ordinal()
    .rangeRoundBands([0, width], .1);</code></pre>
</p>
<br>
<p>
Next - define the y scaling function as well as the range of the function
</p>
<br>
<p>
Remember to pay attention to the fact that the range has height first and then 0.
</p>
<p>
<pre><code class="javascript">var y = d3.scale.linear()
    .range([height, 0]);</code></pre>
</p>
<br>
<p>
Next - define the xAxis function and provide it with a scale and orientation.
</p>
<p>
<pre><code class="javascript">var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");</code></pre>
</p>
<br>
<p>
Next - define the yAxis function and provide it with a scale and orientation as well as the tick formatting function.
</p>
<p>
<pre><code class="javascript">var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left")
    .tickFormat(formatPercent);</code></pre>
</p>
<br>
<p>
Next - define the SVG Container and the Inner Drawing Space
</p>
<p>
<pre><code class="javascript">var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
BROWSER - Open the Body element, the SVG element and show the inner SVG Group Element.
</p>
<p>
This is the first sign of anything occurring in the browser.
</p>
<p>
Up to now we have just been defining functions that will use or be used by the data that is passed in.
</p>
<br>
<p>
This code is where we are going to differ from the example code.
</p>
<p>
<pre><code class="javascript">d3.tsv("data.tsv", function(error,data) {
    callbackError = error;
    callbackData  = data;
});</code></pre>
</p>
<p>
Instead of defining an anonymous callback function that does all the generating of the chart in one go, we will define a callback function that assigns the data and error to variables.
</p>
<p>
We'll then use these variables to build the bar chart.    
</p>
<br>
<p>
Let's check what the d3.tsv call assigned to the callbackError variable.
</p>
<p>
<pre><code class="javascript">callbackError;</code></pre>
</p>
<p>
The callbackError is null, which means the D3.tsv call worked correctly.
</p>
<br>
<p>
Let's check what the d3.tsv call assigned to the callbackData variable.
</p>
<p>
<pre><code class="javascript">callbackData;

callbackData.length;</code></pre>
</p>
<p>
The callbackData variable is an array of 26 elements, which means the D3.tsv call worked correctly.
</p>
<p>
We use the dot length array function because if it's a small number of elements, the JavaScript Console displays all of them rather than a count.
</p>
<br>
<p>
Let's take a look at the first element of this array.
</p>
<p>
<pre><code class="javascript">callbackData[0];</code></pre>
</p>
<p>
You can see that it is a JavaScript object that has the key,value pairs for letter and frequency.
</p>
<p>
Each value is currently a string.
</p>
<br>
<p>
Next - we use the D3 Array forEach iterator to go through the array and change the string values to Numbers.
</p>
<p>
<pre><code class="javascript">callbackData.forEach(function(d) {
    d.frequency = +d.frequency;
});</code></pre>
</p>
<br>
<p>
Let's take a look now at the first element of this array.
</p>
<p>
<pre><code class="javascript">callbackData[0];</code></pre>
</p>
<p>
You can see that the value for frequency is longer a string - is is now a number.
</p>
<br>
<p>
To check to make sure the frequency is now a JavaScript number we can use the typeof JavaScript function:
</p>
<p>
<pre><code class="javascript">typeof(callbackData[0]['frequency']);</code></pre>
</p>
<p>
Which tell us it is a number.
</p>
<br>
<p>
Satisfied that the frequency is a number, let's move on.
</p>
<br>
<p>
Next - define the domain of the x ordinal scale function
</p>
<p>
<pre><code class="javascript">x.domain(callbackData.map(function(d) { return d.letter; }));</code></pre>
</p>
<br>
<p>
Let's check to see what array was passed into the ordinal scale domain
</p>
<p>
<pre><code class="javascript">callbackData.map(function(d) { return d.letter; });</code></pre>
</p>
<p>
We can see that the array passed in was an array of 26 capital letters where each one is a string.
</p>
<br>
<p>
Let's also check to see what the domain of the x ordinal scale function is
</p>
<p>
<pre><code class="javascript">x.domain();</code></pre>
</p>
<p>
You can see that it's the same array.
</p>
<br>
<p>
Next - define the domain of the y scale function
</p>
<p>
<pre><code class="javascript">y.domain([0, d3.max(callbackData, function(d) { return d.frequency; })]);</code></pre>
</p>
<br>
<p>
Let's check to see what the max frequency was.
</p>
<p>
<pre><code class="javascript">d3.max(callbackData, function(d) { return d.frequency; });</code></pre>
</p>
<p>
We can see that the max frequency was 0 point 1 2 7 0 2
</p>
<br>
<p>
Let's also check to see what the domain of the y scale function is
</p>
<p>
<pre><code class="javascript">y.domain()</code></pre>
</p>
<p>
You can see that the minimum number of the domain is zero as was defined.
</p>
<p>
And that the max number of the domain is the 0 point 1 2 7 0 2 number that the d3 dot max function gave us.
</p>
<br>
<p>
Next - the x-axis is created
</p>
<p>
<pre><code class="javascript">svg.append("g")</code></pre>
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
</p>
<p>
Note again that the transform translate moves the x-axis Group element to the bottom of the Inner Drawing Space.
</p>
<p>
On my screen, you can see the start of the x-axis as Chrome developer tools are taking up about 2/3s of the web page.
</p>
<p>
That said, you can see the letters A to the letter K.
</p>
<p>
BROWSER - click into the G element
</p>
<p>
If we click into the SVG Group Element for the Inner Drawing Space
</p>
<p>
You can see the SVG Group element with the class "x axis".
</p>
<p>
This is the X axis.
</p>
<br>
<p>
Next - the y-axis is created.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "y axis")
    .call(yAxis)
  .append("text")
    .attr("transform", "rotate(-90)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Frequency");</code></pre>
</p>
<p>
You can see the y-axis and the text anchor declaring that it is the Frequency in Percent.
</p>
<p>
BROWSER - click into the G element
</p>
<p>
If we click into the SVG Group Element for the Inner Drawing Space
</p>
<p>
You can see the SVG Group element with the class "y axis".
</p>
<p>
This is the y axis.
</p>
<br>
<p>
Now we create the bars according to the data.
</p>
<p>
<pre><code class="javascript">svg.selectAll(".bar")
    .data(callbackData)
  .enter().append("rect")
    .attr("class", "bar")
    .attr("x", function(d) { return x(d.letter); })
    .attr("width", x.rangeBand())
    .attr("y", function(d) { return y(d.frequency); })
    .attr("height", function(d) { return height - y(d.frequency); });</code></pre>
</p>
<p>
And there you have it - you can see the data represented as bars.     
</p>
<br>
<p>
Because we are not applying any CSS to style the bars, let's do the fill of the rectangles in D3.
</p>
<p>
<pre><code class="javascript">svg.selectAll(".bar").attr("fill","steelblue");</code></pre>
</p>
<p>
This is done in CSS in the example.
</p>
<br>
<p>
Before we close the Chrome Developer Tools, let's look at the rectangle for letter A.
</p>
<p>
BROWSER - Click on the First Rectangle
</p>
<p>
BROWSER - Double click on the height.
</p>
<p>
BROWSER - Make it 145
</p>
<p>
When we make the height 145, notice that it shrunk up!
</p>
<p>
Why did this happen?
</p>
<p>
This happens because SVG rectangles are drawn in SVG Coordinate Space.
</p>
<p>
Which means the x and y point define the top left corner
</p>
<p>
The width defines the width
</p>
<p>
and the height defines the height.
</p>
<p>
Which in the case of the SVG Coordinate system, means that as the height grows it moves towards the bottom of the chart.
</p>
<p>
While the Y scaling function provides scaling that inverts the chart, it doesn't actually invert the chart.
</p>
<p>
This is why the height of the rectangle is defined as the height of the Inner Drawing Space minus the y scaling function of the frequency of the letter.
</p>
<br>
<p>
And there we go, we have the finished Bar Chart.
</p>
<br>
<p>
Let's close the Chrome Developer tools to get a better look.
</p>
<p>
BROWSER - close the Chrome Developer Tools.
</p>
<p>
BROWSER - zoom out.
</p>
<p>
You can see the full picture.
</p>
<p>
The only difference between this and the example was the styling applied to the various DOM Elements.
</p>
<br>
<p>
And with that we built the Basic Chart Bar Chart.
</p>
<p>
We used Data served from a web server and processed it through an asynchronous XHR call provided by the D3.tsv type specific method.
</p>
        </div>
      </div>

    
    
    </div>


<hr>
<h3 id="lesson43">Basic Chart - Bar Chart With Negative Values<h3>
    <div>
    <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>Notice that the styling is done in the &lt;style&gt; &lt;/style&gt; section of the HTML document</li>
<li>Notice that this example is different from the others because it does not use a web server to serve the data, it just defines the data at the top of the JavaScript</li>
<li>Notice the D3 Margin Convention</li>
<li>Notice the use of the JavaScript Global Object called Math</li>
<li>Notice the D3 Linear Scale for the X-Axis</li>
<li>Notice the D3 Ordinal Scale with rangeRoundBands for the Y-Axis</li>
<li>Notice the definition of the domain for the Y-Axis</li>
<li>Notice the D3 SVG Axis Component creation, definition, and instantiation of the X-Axis</li>
<li>Notice that _NO_ D3 SVG Axis Component is created nor defined for the Y-Axis</li>
<li>Notice the D3 Data Join</li>
<li>Notice how D3 helps create visual representations of the data</li>
<li>Notice how the JavaScript Ternary Operator Syntax is used to assign a class attribute to the SVG Rect DOM elements that specify the style of whether the bar is positive or negative</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-line-chart">Basic Chart - Line Chart</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-scatterplot">Basic Chart - Scatterplot</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-bar-chart">Basic Chart - Bar Chart</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            Basic Chart - Bar Chart With Negative Values
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
Visual Code Walk Through
</strong>
</p>
<br>
<p>
[ Image: Bar Chart Example ]
</p>
<p>
We will use the Data from the D3js.org website Bar Chart with Negative Values Example.
</p>
<br>
<p>
From this video on, we will be highlighting the areas that are new or different from previous videos.
</p>
<br>
<p>
First we start the with DocType, Meta Character Set and the CSS styling.
</p>
<p>
BROWSER HIGHLIGHT First section
</p>
<p>
<pre><code class="html">&lt;!-DOCTYPE ....&lt;/style&gt;</code></pre>
</p>
<p>
This is the standard doctype setting, meta character set definition and the CSS styling of the DOM Elements we will generate through the use of the D3.js.
</p>
<p>
The new styling elements are the dot bar dot negative and dot bar dot positive definitions.
</p>
<p>
These will be used to style the bars that have negative data and the bars that have positive data.
</p>
<p>
This means that we will be using if/then conditional statements in the D3 code to properly assign the HTML Classes that get the correct CSS Styling.
</p>
<br>
<p>
Next we go into the JavaScript Sections of the document.
</p>
<br>
<p>
First, we load the D3.js JavaScript Library from the web.
</p>
<p>
BROWSER HIGHLIGHT &lt;script src....&gt;&lt;/script&gt;
</p>
<p>
This uses the D3 code hosted by the d3js.org website.
</p>
<br>
<p>
Next, we go into the D3 code.
</p>
<br>
<p>
This example is different from the others because we are not using a web server to serve the data.
</p>
<p>
In this case we are just using a small array of numbers for the dataset.
</p>
<p>
<pre><code class="javascript">var data = [-15, -20, -22, -18, 2, 6, -26, -18];</code></pre>
</p>
<p>
This array has positive and negative values.
</p>
<p>
Note that the data is not an array of JavaScript objects, it is an array of numbers.
</p>
<br>
<p>
Next, we see the D3 Margin convention setup to specify what the SVG container size is as well as define the Inner Drawing Space.
</p>
<p>
<pre><code class="javascript">var margin = {top: 30, right: 10, bottom: 10, left: 10},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;</code></pre>
</p>
<p>
The SVG Container will be 500 pixels tall by 960 pixels wide.
</p>
<br>
<p>
Next, we have the JavaScript Global Object called Math.
</p>
<p>
This object has built-in properties and methods for mathematical constants and functions.
</p>
<p>
The method we use here is max.
</p>
<p>
This returns the largest of zero or more numbers.
</p>
<p>
<pre><code class="javascript">var x0 = Math.max(-d3.min(data), d3.max(data));</code></pre>
</p>
<p>
In this case, we are passing to it the negative of the smallest number in the dataset according to d3.min.
</p>
<p>
Since we know we have negative numbers in the dataset, putting a negative sign in front of it will make it positive.
</p>
<p>
Second, we pass in the largest number in the dataset.
</p>
<p>
Since we know we have positive numbers in the dataset, this will be a positive number.
</p>
<p>
Passing two positive numbers into the Math dot max function gives us the biggest absolute value of a number in the dataset.
</p>
<p>
This is used later to setup the domain of the X Scaling Function.
</p>
<p>
For now, we assign this number to the x zero variable.
</p>
<br>
<p>
Next, we have an linear scale function for the x-axis data.
</p>
<p>
<pre><code class="javascript">var x = d3.scale.linear()
    .domain([-x0, x0])
    .range([0, width])
    .nice();</code></pre>
</p>
<p>
This code creates a linear scaling function where the domain is defined as going from the negative value of the largest absolute value of the dataset going to the positive value of the same largest absolute value of the dataset.
</p>
<p>
This ensures that the 0 of the domain will be found in the middle of the chart.
</p>
<p>
The range is then defined as going from 0 to the width of the Inner Drawing Space.
</p>
<p>
Lastly, the scale is "niced" using the dot nice function to extend it to the nearest round numbers.
</p>
<br>
<p>
Next, we have an ordinal scale function for the y-axis data.
</p>
<p>
<pre><code class="javascript">var y = d3.scale.ordinal()
    .domain(d3.range(data.length))
    .rangeRoundBands([0, height], .2);</code></pre>
</p>
<p>
This code creates an ordinal scaling function where the range goes from 0 to the height of the Inner Drawing Space.
</p>
<p>
This ordinal scaling function is using the Range Round Bands to set the bands.
</p>
<p>
Also, the point 2 is the padding added to offset the bands from the edge of the interval.
</p>
<p>
This code is also setting the domain to an array of numbers as specified by the d3 dot range of the length of the data array.
</p>
<p>
This is new.
</p>
<br>
<p>
D3 dot range is functionality provided by D3 for working with arrays.
</p>
<p>
<pre><code class="javascript">d3.range(data.length)</code></pre>
</p>
<p>
This functionality generates an array containing an arithmetic progression.
</p>
<p>
Here we are passing in 1 number.
</p>
<p>
So this functionality will generate an array that starts with element 0 being 0, element 1 being 1, all the way to element 7 being 7.
</p>
<p>
The functionality does not include the number to stop at in the array.
</p>
<p>
So it will create an array of numbers from 0 to the length of the data array minus 1.
</p>
<br>
<p>
Next we create the X-Axis function
</p>
<p>
<pre><code class="javascript">var xAxis = d3.svg.axis()
    .scale(x)
    .orient("top");</code></pre>
</p>
<p>
We pass in the x-scale function we created earlier and give the axis an orientation of top.
</p>
<p>
This means that the text will be above the line.
</p>
<br>
<p>
Note that we do not create a Y-Axis function.
</p>
<p>
This is because the array is a one dimensional array of data.
</p>
<p>
So while we represent it in two dimensions as a bar chart, the Y axis doesn't contain any information.
</p>
<br>
<p>
The next code creates the SVG Container and the Inner Drawing Space.
</p>
<p>
<pre><code class="javascript">var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<br>
<p>
The next code is where D3 creates the rectangles to represent the positive and negative valued bars for the bar chart.
</p>
<p>
<pre><code class="javascript">svg.selectAll(".bar")
    .data(data)
  .enter().append("rect")
    .attr("class", function(d) { return d < 0 ? "bar negative" : "bar positive"; })
    .attr("x", function(d) { return x(Math.min(0, d)); })
    .attr("y", function(d, i) { return y(i); })
    .attr("width", function(d) { return Math.abs(x(d) - x(0)); })
    .attr("height", y.rangeBand());</code></pre>
</p>
<p>
We will go through this code line by line to make sure it's clear what happens at each step.
</p>
<br>
<p>
The first three lines are the D3 building process.
</p>
<p>
<pre><code class="javascript">svg.selectAll(".bar")
    .data(data)
  .enter().append("rect")</code></pre>
</p>
<p>
We select DOM elements, bind the data, choose the enter selection and append the DOM elements to merge them with placeholder elements.
</p>
<br>
<p>
The next line assigns a class to the rectangles created based on the data that was bound to the specific rectangle.
</p>
<p>
<pre><code class="javascript">.attr("class", function(d) { return d < 0 ? "bar negative" : "bar positive"; })</code></pre>
</p>
<p>
This code assigns an attribute to the SVG Rectangle using the JavaScript Ternary Operator Syntax.
    </p>
<p>
The anonymous function is then used to return the value of the Ternary Operator Functionality result so that the attribute is set correctly.
</p>
<br>
<p>
JavaScript Ternary Operator

</p>
<p>
<pre><code class="javascript">// Instead of this:
var variable;
if (condition) { 
    variable = trueValue;
} else {
    variable = falseValue;
}

// We can write this:
var variable = condition ? trueValue : falseValue;</code></pre>
</p>
<p>
Javascript Ternary Operator Syntax is a way to write simple if/else statements on one line instead of many lines.
</p>
<p>
As you can see on the screen, the first way is a perfectly valid way to write an if/else statement that assigns to a variable two different values depending on whether the conditional is true or false.
</p>
<p>
The second statement, does the exact same thing just in a much shorter and cleaner syntax.
</p>
<p>
It takes up one line.
</p>
<br>
<p>
Going back to the code, this line uses the Ternary Operator Syntax.
</p>
<p>
<pre><code class="javascript">d < 0 ? "bar negative" : "bar positive"</code></pre>
</p>
<p>
The Ternary Operator Syntax has the conditional statement check to see if the data point is less than zero.
</p>
<p>
If it is, then the string "bar negative" is returned
</p>
<p>
Otherwise, the string "bar positive" is returned.
</p>
<br>
<p>
The next line of code is the most important part of the chart.
</p>
<p>
<pre><code class="javascript">.attr("x", function(d, i) { return x(Math.min(0, d)); })</code></pre>
</p>
<p>
This is where the x value gets set for where the SVG Rectangle will be drawn from.
</p>
<p>
SVG Rectangles are drawn from the top left point.
</p>
<p>
The SVG Rectangle width and height cannot be negative.
</p>
<p>
So we have to pay close attention to whether the data is negative or positive to choose how to position the x coordinate for the SVG Rectangle.
</p>
<p>
The way this is done is by using the JavaScript Math Object Method min.
</p>
<p>
If the data point is positive, then we are drawing a positive rectangle which means the top left point should be at the zero x-axis coordinate.
</p>
<p>
If the data point is negative, then we are drawing a negative rectangle which means that the top left point should start at the negative data point scaled through the x-axis scaling function.
</p>
<p>
This ensures that the top left point is defined correctly.
</p>
<br>
<p>
The next line separates the bars from each other according to the index of the number within the data array.
</p>
<p>
<pre><code class="javascript">.attr("y", function(d, i) { return y(i); })</code></pre>
</p>
<p>
This code takes in the index number from the data bound to the specific rectangle and passes it to the y ordinal scaling function.
</p>
<p>
This will return a number from the range round band.
</p>
<p>
This ensures the rectangles are placed neatly and nicely on the Y-Axis.
</p>
<br>
<p>
The next line defines the width of the rectangle.
</p>
<p>
<pre><code class="javascript">.attr("width", function(d) { return Math.abs(x(d) - x(0)); })</code></pre>
</p>
<p>
First, we get the data point that was bound to the rectangle and pass it to the x scaling function.
</p>
<p>
Then we subtract from this number the x scaling function result of passing 0 into it.
</p>
<p>
If the data point was positive, then this will result in a positive number.
</p>
<p>
Because we are subtracting the two numbers after they have been scaled, they will be correctly scaled to fit in the SVG Coordinate Space.
</p>
<p>
This result is then passed to the JavaScript Math Object absolute value method.
</p>
<p>
This returns the absolute value of this subtraction.
</p>
<p>
Which is then used to set the width of the rectangle.
</p>
<br>
<p>
Next, we define the height for the SVG rectangles with the HTML class of bar.
</p>
<p>
<pre><code class="javascript">.attr("height", y.rangeBand());</code></pre>
</p>
<p>
The height is just the band as was calculated from the Y range round band ordinal scale function.
</p>
<p>
This ensures all the rectangles have the same height and spacing.
</p>
<br>
<p>
Next, we call D3.axis operator for the x-axis.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "x axis")
    .call(xAxis);</code></pre>
</p>
<p>
First the code appends an SVG Group Element to hold the x-axis.
</p>
<p>
Then, the xAxis function is called.
</p>
<br>
<p>
Lastly, we create the Y axis using an SVG Straight Line.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "y axis")
  .append("line")
    .attr("x1", x(0))
    .attr("x2", x(0))
    .attr("y1", 0)
    .attr("y2", height);</code></pre>
</p>
<p>
Note that we do not call the D3.axis operator because we did not define or create a yAxis function.
</p>
<p>
All we need to do is to drawn a straight line from the x-coordinate 0 point at the top of the Inner Drawing space to the x-coordinate 0 point at the bottom of the Inner Drawing Space.
</p>
<p>
This is done by defining the x1, y1, x2, and y2 attributes for the SVG Straight Line Basic Object.
</p>
<br>
<p>
And that is the end of the D3 JavaScript Functionality.
</p>
<p>
<pre><code class="javascript">&lt;/script&gt;</code></pre>
</p>
<p>
When this is done the graph will have been fully generated.
</p>
<br>
<p>
Let's now build this part by part in JavaScript.
</p>
<br>
<br>
<p>
<strong>
JavaScript Code Build
</strong>
</p>
<br>
<p>
We start by opening an HTML web page that already has D3 linked to it.
 </p>
<br>
<p>
We then open the Chrome Developer tools and test to make sure D3 loaded correctly and then clear the screen.
</p>
<p>
<pre><code class="javascript">d3.version;

clear();</code></pre>
</p>
<br>
<p>
Next, we go step by step building the visualization.
</p>
<br>
<p>
First we copy the data array from the D3js.org Example for the Bar Chart with Negative Values.
</p>
<p>
<pre><code class="javascript">var data = [-15, -20, -22, -18, 2, 6, -26, -18];</code></pre>
</p>
<br>
<p>
Then we define the margins and the width and height of the Inner Drawing Space.
</p>
<p>
<pre><code class="javascript">var margin = {top: 30, right: 10, bottom: 10, left: 10},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;</code></pre>
</p>
<br>
<p>
Next we define the X0 which dictates based on the data passed in what the max X and Min X will be for the bar chart.
</p>
<p>
<pre><code class="javascript">var x0 = Math.max(-d3.min(data), d3.max(data));</code></pre>
</p>
<br>
<p>
Let's check what the minimum number and the maximum number of the data set are:
</p>
<p>
<pre><code class="javascript">[d3.min(data), d3.max(data)];</code></pre>
</p>
<p>
We use an array to compute both numbers on the same line.
</p>
<p>
We can see that the smallest number is -26.
</p>
<br>
<p>
Let's check what X0 is
</p>
<p>
<pre><code class="javascript">x0;</code></pre>
</p>
<p>
X0 is 26, which is what was expected.
</p>
<br>
<p>
Next - define the x linear scaling function based on the domain, range and nicing of the values.
</p>
<p>
<pre><code class="javascript">var x = d3.scale.linear()
    .domain([-x0, x0])
    .range([0, width])
    .nice();</code></pre>
</p>
<br>
<p>
Let's check to see what the domain of the x scaling function became once we used the nice function.
</p>
<p>
<pre><code class="javascript">x.domain();</code></pre>
</p>
<p>
We can see that the domain now goes from -30 to 30, rather than the -26 to 26 that was initial passed to the domain.
</p>
<p>
Again, this is the nicing function coming into action.
</p>
<br>
<p>
Next - define the y ordinal scaling function.
</p>
<p>
<pre><code class="javascript">var y = d3.scale.ordinal()
    .domain(d3.range(data.length))
    .rangeRoundBands([0, height], .2);</code></pre>
</p>
<p>
The domain is created from the array of numbers from 0 to the length of the data array minus 1.
</p>
<p>
The range is created from the range round bands according to the height of the Inner Drawing Space.
</p>
<br>
<p>
Let's check to see what the data array length is
</p>
<p>
<pre><code class="javascript">data.length;</code></pre>
</p>
<p>
We can see that the data array length is 8 elements.
</p>
<br>
<p>
Next - let's check to see what passing the number 8 to the d3.range function does...
</p>
<p>
<pre><code class="javascript">d3.range(data.length);</code></pre>
</p>
<p>
As expected, it creates an array of numbers starting at 0 and going up 1 by 1 to the number 7.
</p>
<p>
Where 7 is the length of the data array minus 1.
</p>
<br>
<p>
Next - define the xAxis function and provide it with a scale and orientation.
</p>
<p>
<pre><code class="javascript">var xAxis = d3.svg.axis()
    .scale(x)
    .orient("top");</code></pre>
</p>
<br>
<p>
Next - define the SVG Container and the Inner Drawing Space
</p>
<p>
<pre><code class="javascript">var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
BROWSER - Open the Body element, the SVG element and show the inner SVG Group Element.
</p>
<p>
This is the first sign of anything occurring in the browser.
</p>
<p>
Up to now we have just been defining functions that will use or be used by the data that is passed in.
</p>
<br>
<p>
Next - comes the code that will create the rectangles.
</p>
<p>
Before we do that, let's go through the exercise of creating a rectangle for the very first number in the data array.
</p>
<p>
This number is -15.
</p>
<br>
<p>
First, we append an SVG Rectangle to the Inner Drawing Space
</p>
<p>
<pre><code class="javascript">svg.append("rect");</code></pre>
</p>
<p>
BROWSER - highlight the Rectangle element.
</p>
<p>
You can see the rectangle.
</p>
<br>
<p>
Next, let's add the rectangle attributes according to how the D3 example code does it.
</p>
<br>
<p>
First, we have to assign a class to it based on the JavaScript Ternary Operator Syntax.
</p>
<p>
<pre><code class="javascript">data[0];

data[0] < 0 ? "bar negative" : "bar positive";</code></pre>
</p>
<p>
Data 0 is -15.
</p>
<p>
So because -15 is less than zero, the if/then statement tells us to use the "bar negative" string.
</p>
<br>
<p>
Let's add this attribute to the rectangle.
</p>
<p>
<pre><code class="javascript">d3.select("rect").attr("class","bar negative");</code></pre>
</p>
<p>
BROWSER - Click on element
</p>
<p>
You can see that the rectangle now has the class of "bar negative".
</p>
<br>
<p>
Next, we define the x-coordinate point on the Inner Drawing Space for where the rectangle should be drawn from.
</p>
<p>
<pre><code class="javascript">Math.min(0, data[0]);</code></pre>
</p>
<p>
We calculate which is smaller - zero or the first element of the data array.
</p>
<p>
-15 is smaller.
</p>
<br>
<p>
We then pass the -15 to the x-scaling function.
</p>
<p>
<pre><code class="javascript">x(-15);</code></pre>
</p>
<p>
This tells us that top left point of the rectangle will start at the Inner Space X-Coordinate point of 235.
</p>
<br>
<p>
So we assign the x attribute to the rectangle.
</p>
<p>
<pre><code class="javascript">d3.select("rect").attr("x",235);</code></pre>
</p>
<br>
<p>
Next we calculate the Inner Space Y-Coordinate point for the first element in the data set array.
</p>
<p>
<pre><code class="javascript">y(0);</code></pre>
</p>
<p>
Since the data set is defined in an array and arrays are zero-index based, the first index number is 0.
</p>
<p>
y ordinal scaling function of 0 gives us 12.
</p>
<p>
This tells us that the top left point of the rectangle will start at the Inner Drawing Space Y-Coordinate point of 12.
</p>
<br>
<p>
So we assign the y attribute to the rectangle.
</p>
<p>
<pre><code class="javascript">d3.select("rect").attr("y",12);</code></pre>
</p>
<br>
<p>
Next we calculate the width of the rectangle.
</p>
<p>
<pre><code class="javascript">Math.abs(x(data[0]) - x(0));</code></pre>
</p>
<p>
This tells us that the width of the rectangle will be 235.
</p>
<br>
<p>
So we assign the width attribute to the rectangle.
</p>
<p>
<pre><code class="javascript">d3.select("rect").attr("width",235);</code></pre>
</p>
<br>
<p>
Next we calculate the height of the rectangle.
</p>
<p>
<pre><code class="javascript">y.rangeBand();</code></pre>
</p>
<p>
This tells us that the height of the rectangle will be 45.
</p>
<br>
<p>
So we assign the height attribute to the rectangle.
</p>
<p>
<pre><code class="javascript">d3.select("rect").attr("height",45);</code></pre>
</p>
<p>
BROWSER - CLICK on rectangle
</p>
<p>
And now you can see the rectangle on the screen.
</p>
<br>
<p>
Let's delete the rectangle from the Chrome Developer Tool Elements Section in order to have a clear chart to draw all the rectangles on.
</p>
<p>
BROWSER - Delete the rectangle.
</p>
<br>
<p>
Next we create the bars.
</p>
<p>
<pre><code class="javascript">svg.selectAll(".bar")
    .data(data)
  .enter().append("rect")
    .attr("class", function(d) { return d < 0 ? "bar negative" : "bar positive"; })
    .attr("x", function(d) { return x(Math.min(0, d)); })
    .attr("y", function(d, i) { return y(i); })
    .attr("width", function(d) { return Math.abs(x(d) - x(0)); })
    .attr("height", y.rangeBand());</code></pre>
</p>
<p>
You can now see all the bars.
</p>
<br>
<p>
Let's take a look at the first bar to see if it looks familiar.
</p>
<p>
BROWSER HIGHLIGHT - first bar
</p>
<p>
It looks exactly like what we calculated earlier.
</p>
<p>
The x is at 235
</p>
<p>
The y is at 12
</p>
<p>
The width is 235
</p>
<p>
and the height is 45.
</p>
<br>
<p>
Because we are not applying any CSS to style the bars, let's do the styling of the rectangles in D3.
</p>
<p>
<pre><code class="javascript">d3.selectAll(".bar.negative").attr("fill","brown");

d3.selectAll(".bar.positive").attr("fill","steelblue");</code></pre>
</p>
<br>
<p>
Let's finish up by adding the x and y axis lines.
</p>
<br>
<p>
First we add the x axis by calling the D3 axis operator for the x axis.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "x axis")
    .call(xAxis);</code></pre>
</p>
<br>
<p>
Then we add the y axis by drawing the SVG Straight Line.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "y axis")
  .append("line")
    .attr("x1", x(0))
    .attr("x2", x(0))
    .attr("y1", 0)
    .attr("y2", height)
    .style("fill","none")
    .style("stroke","#000")
    .style("shape-rendering", "crispEdges");</code></pre>
</p>
<p>
Note that we added three extra style attributes at the end to make sure the line was visible.
</p>
<p>
In the example, this styling is applied in the CSS section of the document.
</p>
<br>
<p>
And there we go, we have the finished Bar Chart.
</p>
<br>
<p>
Let's close the Chrome Developer tools to get a better look.
</p>
<p>
BROWSER - close the Chrome Developer Tools.
</p>
<p>
BROWSER - zoom out.
</p>
<p>
You can see the full picture.
</p>
<br>
<p>
The only difference between this and the example was the styling applied to the various DOM Elements.
</p>
<br>
<p>
And with that we built the Basic Chart Bar Chart with Negative Values.
</p>
<br>
<p>
We used a Linear Scaling Function to properly place the X and Y points for the SVG rectangles based on whether the data values were positive or negative.
</p>
<br>
<p>
We also used an Ordinal Scaling Function to place the rectangles equally spaced along the Y Axis.
</p>
        </div>
      </div>

    
    ☺</div>


<hr>
<h3 id="lesson44">Basic Chart - Area Chart<h3>
    <div>
        <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>You will use the TSV data from the D3js.org website Area Chart Example to see how a full D3 Area Chart Example data visualization is built</li>
<li>Notice that the styling is done in the &lt;style&gt; &lt;/style&gt; section of the HTML document</li>
<li>Notice the D3 Margin Convention</li>
<li>Notice the use of the D3 Time Formatting function and parsing</li>
<li>Notice the D3 Time Scale for the X-Axis</li>
<li>Notice the D3 Linear Scale for the Y-Axis</li>
<li>Notice the D3 SVG Axis component creation and definition for the X-Axis and Y-Axis</li>
<li>Notice the D3 SVG Area Path Generator Function and the accessor functions</li>
<li>Notice the D3 TSV Type-Specific AJAX call to get the data</li>
<li>Notice the .domain being set for the X and Y Axis</li>
<li>Notice the data join is done using the D3 .datum() operator</li>
<li>Notice how D3 helps create visual representations of the data</li>
<li>Notice the instantiation of the X-Axis and Y-Axis</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-line-chart">Basic Chart - Line Chart</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-scatterplot">Basic Chart - Scatterplot</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-bar-chart">Basic Chart - Bar Chart</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-bar-chart-with-negative-values">Basic Chart - Bar Chart With Negative Values</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            Basic Chart - Area Chart
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
Visual Code Walk Through
</strong>
</p>
<br>
<p>
[ Image: Area Chart Example ]
</p>
<p>
We will use the Data from the D3js.org website Area Chart example.
</p>
<br>
<p>
[ Image: Data for Area Chart Example ]
</p>
<p>
We will save this data into a file called data.tsv
</p>
<p>
This file is the one that will be loaded asynchronously using the D3.tsv request functionality.
</p>
<br>
<p>
First we start the with DocType, Meta Character Set and the CSS styling.
</p>
<p>
BROWSER HIGHLIGHT First section
</p>
<p>
<pre><code class="html">&lt;!-DOCTYPE ....&lt;/style&gt;</code></pre>
</p>
<p>
This is the standard doctype setting, meta character set definition and the CSS styling of the DOM Elements we will generate through the use of the D3js code.
</p>
<br>
<p>
Next we go into the JavaScript Sections of the document.
</p>
<br>
<p>
First, we load the D3.js JavaScript Library from the web.
</p>
<p>
BROWSER HIGHLIGHT &lt;script src....&gt;&lt;/script&gt;
</p>
<p>
This uses the D3 code hosted by the d3js.org website.
</p>
<br>
<p>
Next, we go into the D3 code that will create the area chart.
</p>
<br>
<p>
The D3 Margin convention sets up the SVG container size is as well as defines the Inner Drawing Space.
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 50},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;</code></pre>
</p>
<p>
The SVG Container will be 500 pixels tall by 960 pixels wide.
</p>
<br>
<p>
Next we have a date formatting function.
</p>
<p>
<pre><code class="javascript">var parseDate = d3.time.format("%d-%b-%y").parse;</code></pre>
</p>
<p>
The idea behind this code is that it will take a string formatted in the way specified and convert it into a JavaScript Date Object.
</p>
<p>
This takes in a string that has a date then a dash then the three letter code for a month then a dash and finally a two digit number for the year.
</p>
<p>
This takes in the data from the data.tsv file and converts the dates to JavaScript Date Objects.  
</p>
<br>
<p>
Next we have a timescale function for the x-axis data.
</p>
<p>
<pre><code class="javascript">var x = d3.time.scale()
    .range([0, width]);</code></pre>
</p>
<p>
This code will create a scaling function where the range goes from zero to the width of the Inner Drawing Space.
</p>
<p>
We will set the domain later after we have loaded in the data.
</p>
<br>
<p>
Next we have a scale linear function for the y-axis data.
</p>
<p>
<pre><code class="javascript">var y = d3.scale.linear()
    .range([height, 0]);</code></pre>
</p>
<p>
This code will create a scaling function where the range goes from the height of the inner drawing space to 0.
</p>
<p>
The height and the number zero are reversed so that numbers passed into this scaling function will be converted to numbers that act as if the SVG Coordinate Space has been inverted along the Y-Axis.
</p>
<p>
So as the y axis variable grows it will move up rather than down.
</p>
<br>
<p>
Next we create the X-Axis function
</p>
<p>
<pre><code class="javascript">var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");</code></pre>
</p>
<p>
We pass in the x-scale function we created earlier and then give the axis an orientation of bottom.
</p>
<p>
This means that the text will be below the line.
</p>
<p>
We can pass in the x-scaling function before we define the domain because we have not evaluated the xAxis function so we still have time to define the domain.
</p>
<br>
<p>
Then we create the Y-Axis the same way
</p>
<p>
<pre><code class="javascript">var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");</code></pre>
</p>
<p>
We pass in the y-scaling function we created earlier and give the axis an orientation of left.
</p>
<p>
This orientation will make the axis vertical and make the text appear on the left of the line.
</p>
<br>
<p>
The next code is new for us.
</p>
<p>
<pre><code class="javascript">var area = d3.svg.area()
    .x(function(d) { return x(d.date); })
    .y0(height)
    .y1(function(d) { return y(d.close); });</code></pre>
</p>
<p>
The D3 dot svg dot area function is an SVG Shape that D3 provides for us.
</p>
<p>
It is defined by specifying two linear functions where the x coordinate is the same for both, but the y-coordinates are different.
</p>
<p>
The polygon is then defined as the area inside of the two lines.
</p>
<p>
The y0 and y1 are the two different linear accessor functions.
</p>
<p>
In this case, y0 will be the height of the inner drawing space - which means it will be at the bottom of the Inner Drawing Space all the way across the width of the graph.
</p>
<p>
The y1 will be the closing price for each data point that is then scaled through the y linear scaling function.
</p>
<p>
The area between the y1 and the y0 will then be filled in.
</p>
<p>
The way D3 does this is by returning an SVG path that is a closed piecewise linear curve.
</p>
<p>
The way this works is that x and y0 proceed to make a path from left to right and then the x and y1 proceed to close the path by going from right to left.
</p>
<p>
Finally, the inside is filled in.
</p>
<br>
<p>
The next code creates the SVG Container and the Inner Drawing Space.
</p>
<p>
<pre><code class="javascript">var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<br>
<p>
The next code is where the D3 does the asynchronous call to the server to get the data and then builds the chart.
</p>
<p>
BROWSER HIGHLIGHT all d3.tsv
</p>
<p>
In this case, the callback function is an anonymous function.     
</p>
<br>
<p>
Let's go through the callback function section by section.
</p>
<br>
<p>
First, we have code that iterates through the array of JavaScript objects
</p>
<p>
<pre><code class="javascript">data.forEach(function(d) {
    d.date = parseDate(d.date);
    d.close = +d.close;
});</code></pre>
</p>
<p>
For each JavaScript object it does two things:
</p>
<p>
One, it converts the date string to a JavaScript Date Object
</p>
<p>
and two, and it converts the closing price from a string to a number.     
</p>
<br>
<p>
Next, we set the domain for the x-scale function
</p>
<p>
<pre><code class="javascript">x.domain(d3.extent(data, function(d) { return d.date; }));</code></pre>
</p>
<p>
Now that we have the data, we can set the domain of the x scale function by using the D3 dot extent method.
</p>
<p>
This returns an array containing the minimum and maximum Dates.
</p>
<p>
An anonymous function is used to get the date out of the Data Objects.
</p>
<br>
<p>
Next, we set the domain for the y-scale function
</p>
<p>
<pre><code class="javascript">y.domain([0, d3.max(data, function(d) { return d.close; })]);</code></pre>
</p>
<p>
Now that we have the data, we can set the domain of the y-scale function by using the D3 dot max functionality.
</p>
<p>
The domain of the Y function is a continuous linear function, so the domain will be defined as going from 0 to the max closing price found in the data.
</p>
<br>
<p>
And then finally, we draw the closed piecewise linear curve SVG path that is the graph of the data.
</p>
<p>
<pre><code class="javascript">svg.append("path")
    .datum(data)
    .attr("class", "area")
    .attr("d", area);</code></pre>
</p>
<p>
This is the D3 pattern.
</p>
<p>
We define the drawing space.
</p>
<p>
We append a path
</p>
<p>
We use datum(data) since there is only one piece of a data generated which is the path variable.
</p>
<p>
The path instructions are generated by the D3 Path Generator functionality using that one array.
</p>
<p>
Then we give the path a class of area.
</p>
<p>
This is how the CSS knows to provide styling to the area.
</p>
<p>
And finally, we add the attribute d, which is the D3 Path Generator Function.
</p>
<p>
This will take in the data that was passed into the datum and generate the path based on the d3 dot svg dot area function.
</p>
<p>
One thing to notice here is that the passing of the data object is not explicit.
</p>
<p>
D3 implicitly understands that it should use the Data bound to the SVG path object.
</p>
<p>
Thus it it is able to use the data passed into the datum call without having it be specified.     
</p>
<br>
<p>
Next, we call the D3 dot axis operator for the x-axis.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);</code></pre>
</p>
<p>
First the code appends an SVG Group Element to hold the x-axis.
</p>
<p>
Then the group element is given the class of "x axis"
</p>
<p>
Then it is transform translated by the height of the inner drawing space.
</p>
<p>
Then the xAxis function is called.
</p>
<p>
This creates the full X Axis.
</p>
<br>
<p>
Finally, we call the D3 dot axis operator for the y-axis.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "y axis")
    .call(yAxis)
  .append("text")
    .attr("transform", "rotate(-90)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Price ($)");</code></pre>
</p>
<p>
First the code appends an SVG Group Element to hold the y-axis.
</p>
<p>
Then the group element is given the class of "y axis"
</p>
<p>
Then then yAxis function is called.
</p>
<p>
Then we append text to the Y Axis for an axis label.
</p>
<p>
This creates the full Y Axis.
</p>
<br>
<p>
And that is the end of the callback function and the end of the d3.tsv function.
</p>
<p>
<pre><code class="javascript">});</code></pre>
</p>
<p>
When this is done, the graph will have been fully generated.
</p>
<br>
<p>
Let's now build this part by part in JavaScript.
</p>
<br>
<br>
<p>
<strong>
JavaScript Code Build
</strong>
</p>
<br>
<p>
Because in the example the building of the chart happens inside of the callback function, we will use a more simple anonymous function in the JavaScript Console.
</p>
<p>
<pre><code class="javascript"> d3.tsv("data.tsv", function(error, data){...});

//=>

var callbackError, callbackData;

d3.tsv("data.tsv", function(error, data){
    callbackError = error;
    callbackData = data;
});</code></pre>
</p>
<br>
<p>
Alright, to the JavaScript Console.
</p>
<br>
<p>
CLEAR CHROME BROWSER CACHE
</p>
<br>
<p>
We start by saving the example data into the data.tsv file which lives in the folder where we will start the Python SimpleHTTPServer.
</p>
<br>
<p>
save the data.
</p>
<br>
<p>
Next, we start the Python SimpleHTTPServer from the command line
</p>
<p>
<pre><code class="python">cd Desktop/d3_projects/

python -m SimpleHTTPServer</code></pre>
</p>
<p>
Now, we have the server going and have the data file ready to be served up.
</p>
<br>
<p>
Next, we make sure the index.html file is saved in the right place and has D3 being loaded into it.
</p>
<p>
Show index file and save it.
</p>
<p>
BROWSER - go to the 0.0.0.0:8000/
</p>
<p>
We can see the web page.
</p>
<br>
<p>
We open the Chrome Developer Tools and test to make sure D3 loaded correctly and then clear the screen.
</p>
<p>
<pre><code class="javascript">d3.version;

clear();</code></pre>
</p>
<br>
<p>
Next, we go step by step building the visualization.
</p>
<br>
<p>
We start by defining the callbackError and callbackData variables which will be used to house the data we get back from the d3.tsv function.
</p>
<p>
<pre><code class="javascript">var callbackError, callbackData;</code></pre>
</p>
<br>
<p>
The first step from the example is defining the margins and the width and height of the Inner Drawing Space.
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 50},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;</code></pre>
</p>
<br>
<p>
Next - define the date parsing function.
</p>
<p>
<pre><code class="javascript">var parseDate = d3.time.format("%d-%b-%y").parse;</code></pre>
</p>
<br>
<p>
Next - define the x-scaling function as well as the range of the function.
</p>
<p>
<pre><code class="javascript">var x = d3.time.scale()
    .range([0, width]);</code></pre>
</p>
<br>
<p>
Next - define the y-scaling function as well as the range of the function.
</p>
<p>
Remember to pay attention to the fact that the range has height first and then 0.
</p>
<p>
<pre><code class="javascript">var y = d3.scale.linear()
    .range([height, 0]);</code></pre>
</p>
<br>
<p>
Next - define the xAxis function and provide it with a scale and orientation.
</p>
<p>
<pre><code class="javascript">var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");</code></pre>
</p>
<br>
<p>
Next - define the yAxis function and provide it with a scale and orientation as well.
</p>
<p>
<pre><code class="javascript">var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");</code></pre>
</p>
<br>
<p>
Next - define the D3 Area Path Generator Function.
</p>
<p>
<pre><code class="javascript">var area = d3.svg.area()
    .x(function(d) { return x(d.date); })
    .y0(height)
    .y1(function(d) { return y(d.close); });</code></pre>
</p>
<p>
Remember that y0 gets drawn from left to right and y1 gets drawn from right to left.
</p>
<p>
This is a closed piecewise linear curve SVG path.
</p>
<br>
<p>
Next - define the SVG Container and the Inner Drawing Space
</p>
<p>
<pre><code class="javascript">var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
BROWSER - Open the Body element, the SVG element and show the inner SVG Group Element.
</p>
<br>
<p>
Next is where we are going to differ a bit from the code of the example.
</p>
<p>
<pre><code class="javascript">d3.tsv("data.tsv", function(error,data) {
    callbackError = error;
    callbackData  = data;
    console.log([callbackError, callbackData.length]);
});</code></pre>
</p>
<p>
Instead of defining an anonymous callback function that does all the generating of the chart in one go, we'll define a callback function that assigns the data and error to variables.
</p>
<p>
We'll then use the callbackError and callbackData variables to build the area chart.
</p>
<p>
Inside of the callback function, we have a console log of an array of the callbackError and callbackData dot length so we can see what is in each one.
</p>
<p>
We can see that the callbackError was null and that the length of the callbackData array is 1280 elements.
</p>
<br>
<p>
Next - we use the D3 Array forEach iterator to go through the 1280 element array and change the string values to either JavaScript Date Objects or Numbers.
</p>
<p>
<pre><code class="javascript">callbackData.forEach(function(d) {
    d.date = parseDate(d.date);
    d.close = +d.close;
});</code></pre>
</p>
<br>
<p>
Next - define the domain of the x scale function and then check to see what the domain is.
</p>
<p>
<pre><code class="javascript">x.domain(d3.extent(callbackData, function(d) { return d.date; }));

x.domain();</code></pre>
</p>
<br>
<p>
Next - define the domain of the y scale function and then check to see what the domain is.
</p>
<p>
<pre><code class="javascript">y.domain([0, d3.max(callbackData, function(d) { return d.close; })]);

y.domain();</code></pre>
</p>
<br>
<p>
Next - create the SVG Area by using the D3 Area Path Generator function.
</p>
<p>
<pre><code class="javascript">svg.append("path")
    .datum(callbackData)
    .attr("class", "area")
    .attr("d", area);</code></pre>
</p>
<p>
BROWSER - Click on the path class="area"
</p>
<p>
You can see that the SVG path was generated.
</p>
<br>
<p>
Next - the x-axis is created.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);</code></pre>
</p>
<p>
Note again that the transform translate moves the x-axis Group element to the bottom of the Inner Drawing Space.
</p>
<p>
BROWSER - click into the G element
</p>
<p>
If we click into the SVG Group Element for the Inner Drawing Space
</p>
<p>
You can see the SVG Group element with the class "x axis".
</p>
<p>
This is the X axis.
</p>
<br>
<p>
Lastly - the y-axis is created.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "y axis")
    .call(yAxis)
  .append("text")
    .attr("transform", "rotate(-90)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Price ($)");</code></pre>
</p>
<p>
You can see the y-axis and the price text anchor declaring that it is a price in dollars.
</p>
<p>
BROWSER - click into the G element
</p>
<p>
If we click into the SVG Group Element for the Inner Drawing Space
</p>
<p>
You can see the SVG Group element with the class "y axis".
</p>
<p>
This is the y axis.
</p>
<br>
<p>
And there we go, we have the chart.
</p>
<br>
<p>
Let's close the Chrome Developer tools to get a better look.
</p>
<p>
BROWSER - close the Chrome Developer Tools.
</p>
<p>
BROWSER - zoom out.
</p>
<p>
You can see the full picture.
</p>
<br>
<p>
The only difference between this and the example was the styling applied to the various DOM Elements.
</p>
<br>
<p>
And with that we built the Basic Chart - Area Chart.
</p>
<p>
We used Data served from a web server and processed it through an asynchronous XHR call provided by the D3.tsv type specific method.
</p>
<p>
The chart was created using the d3 dot svg dot area functionality which creates a closed piecewise linear curve that is fed into the SVG Path variable d.
</p>
        </div>
      </div>
    
    ☺</div>


<hr>
<h3 id="lesson45">Basic Chart - Grouped Bar Chart<h3>
    <div>
     <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>You will use the CSV data from the D3js.org website Grouped Bar Chart Example to see how a full D3 Grouped Bar Chart Example data visualization is built</li>
<li>Notice that the styling is done in the &lt;style&gt; &lt;/style&gt; section of the HTML document</li>
<li>Notice the D3 Margin Convention</li>
<li>Notice the D3 Ordinal Scale for the X-Axis and the rangeRoundBands</li>
<li>Notice the D3 Ordinal Scale for the secondary X-Axis (for each specific grouping of bar charts)</li>
<li>Notice the D3 Linear Scale for the Y-Axis</li>
<li>Notice the D3 Ordinal Scale for the 7 HTML colors used to encode attributes of the data</li>
<li>Notice the D3 SVG Axis component creation and definition for the X-Axis and Y-Axis</li>
<li>Notice the D3 .tickFormat to format the ticks on the Y-Axis</li>
<li>Notice the D3 Type-Specific d3.csv AJAX call</li>
<li>Notice the use of the d3.keys operator</li>
<li>Notice the use the of the .filter, .map, and .forEach array functions</li>
<li>Notice the .domain being set for the primary X-Axis, secondary X-Axis, and Y-Axis</li>
<li>Notice the D3 Data Join</li>
<li>Notice the secondary D3 Data Join with a function used to pull out data to bind to the SVG Rectangle DOM Elements</li>
<li>Notice the Third D3 Data Join for the Grouped Bar Chart Legend</li>
<li>Notice how D3 helps create visual representations of the data, grouping of data, and the legend</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-line-chart">Basic Chart - Line Chart</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-scatterplot">Basic Chart - Scatterplot</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-bar-chart">Basic Chart - Bar Chart</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-bar-chart-with-negative-values">Basic Chart - Bar Chart With Negative Values</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-area-chart">Basic Chart - Area Chart</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            Basic Chart - Grouped Bar Chart
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
Visual Code Walk Through
</strong>
</p>
<br>
<p>
[ Image: Grouped Bar Chart Example ]
</p>
<p>
We will use the Data from the D3js.org website Grouped Bar Chart example.
</p>
<br>
<p>
This chart example will demonstrate two main ideas:
</p>
<p>
The first idea is to nest an array of JavaScript objects inside of a Javascript Object to achieve a nesting of data inside of other data.    
</p>
<p>
The second idea is to use this nesting to do two bindings of data to DOM elements.
</p>
<p>
The first binding will be the big data objects which represented the states.
</p>
<p>
The second binding will be the interior array of JavaScript objects with each one creating a rectangle to represent the data.     
</p>
<br>
<p>
Text on Screen
[ Image: Data for Grouped Bar Chart Example ]
</p>
<p>
We will save the data from the example into a file called data.csv
</p>
<p>
This file is the one that will be loaded asynchronously using the D3.csv request functionality.
</p>
<br>
<p>
The document starts with the DocType, Meta Character Set and CSS styling.
</p>
<p>
BROWSER HIGHLIGHT First section
</p>
<p>
<pre><code class="html">&lt;!-DOCTYPE ....&lt;/style&gt;</code></pre>
</p>
<p>
This is the standard HTML Doctype, meta character set definition and CSS Styling for the D3 Data Visualization we are making.
</p>
<br>
<p>
Next we go into the JavaScript Sections of the document.
</p>
<br>
<p>
First, we load the D3.js JavaScript Library from the web.
</p>
<p>
BROWSER Highlight &lt;script src....&gt;&lt;/script&gt;
</p>
<p>
This uses the D3 code hosted by the d3js.org website.
</p>
<br>
<p>
Next, we go into the D3 code that will create the Grouped Bar Chart.
</p>
<br>
<p>
The D3 Margin convention sets up the SVG container size as well as defines the Inner Drawing Space.
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 40},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;</code></pre>
</p>
<p>
The SVG Container will be 500 pixels tall by 960 pixels wide.
</p>
<br>
<p>
Next we have the first of two ordinal scaling functions for the x-axis data.
</p>
<p>
<pre><code class="javascript">var x0 = d3.scale.ordinal()
    .rangeRoundBands([0, width], .1);</code></pre>
</p>
<p>
This code is used to create the ordinal scale for the big grouping elements - which are the states.
</p>
<p>
This code creates an ordinal scaling function where the range goes from 0 to the width of the Inner Drawing Space.
</p>
<p>
This ordinal scaling function is using the Range Round Bands to set the bands.
</p>
<p>
Also, the point 1 is the the padding added to offset the bands from the edge of the interval.
</p>
<br>
<p>
Next we have the second of two ordinal scaling functions for the x-axis data.
</p>
<p>
<pre><code class="javascript">var x1 = d3.scale.ordinal();</code></pre>
</p>
<p>
This code is used to create the ordinal scale for the small elements inside of the states.
</p>
<p>
The small elements are the age groups.
</p>
<p>
We do not set the domain or range for now.
</p>
<p>
These will be defined later after we have fully defined the x0 domain.
</p>
<br>
<p>
Next we have a scale linear function for the y-axis data.
</p>
<p>
<pre><code class="javascript">var y = d3.scale.linear()
    .range([height, 0]);</code></pre>
</p>
<p>
This code will create a scaling function where the range goes from the height of the Inner Drawing Space to 0.
</p>
<p>
The height and the number zero are reversed so that numbers passed into this scaling function will be converted to numbers that act as if the SVG Coordinate Space has been inverted along the Y-Axis.
</p>
<br>
<p>
Next we setup an ordinal scaling function for the colors that are going to be used for the different age ranges.
</p>
<p>
<pre><code class="javascript">var color = d3.scale.ordinal()
    .range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);</code></pre>
</p>
<p>
The range is a list of 7 html colors.
</p>
<p>
Note that the domain is not yet set.
</p>
<p>
The domain will be set as the actual rectangles for each range are being defined.
</p>
<p>
As each age range name is passed into the color, it will be added to the domain and mapped to one of the range colors.
</p>
<p>
We've seen this previously when we did the Scatterplot example.
</p>
<br>
<p>
Next we create the X-Axis function
</p>
<p>
<pre><code class="javascript">var xAxis = d3.svg.axis()
    .scale(x0)
    .orient("bottom");</code></pre>
</p>
<p>
We pass in the x0-scale function we created earlier and then give the axis an orientation of bottom.
</p>
<p>
We pass in the x0-scaling function because we want the big grouping to be based on the states.
</p>
<br>
<p>
Then we create the Y-Axis the same way
</p>
<p>
<pre><code class="javascript">var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left")
    .tickFormat(d3.format(".2s"));</code></pre>
</p>
<p>
We pass in the y-scaling function we created earlier and give the axis an orientation of left.
</p>
<p>
We also give the numbers a formatting using the d3.formatting function.
</p>
<p>
This specific type of formatting will make sure the numbers show 1 decimal place and then have the letter M append to the end of the number on the right.
</p>
<p>
This is called SI prefix formatting.
</p>
<p>
The webpage gives the example of converting a number of 10 million written out with it's 7 zeros to a number written as 1 0 and then the letter M.
</p>
<br>
<p>
The next code creates the SVG Container and the Inner Drawing Space.
</p>
<p>
<pre><code class="javascript">var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<br>
<p>
The next code is where the D3 does the asynchronous call to the server to get the data and then builds the chart.
</p>
<p>
BROWSER HIGHLIGHT all d3.csv
</p>
<p>
In this case, the callback function is an anonymous function.
</p>
<p>
Note - this example uses d3.csv for comma separated values not d3.tsv for tab separated values.
</p>
<br>
<p>
Let's go through the callback function section by section.
</p>
<br>
<p>
First, we have code that looks at the first data element and gets the keys.
</p>
<p>
Once it gets the keys, it applies a function to the array of keys that returns an array of all the elements that are not equal to the string "State".
</p>
<p>
It then assigns this array to the variable ageNames.
    var ageNames = d3.keys(data[0]).filter(function(key) { return key !== "State"; });
</p>
<p>
This is constructed in a series of steps.
</p>
<p>
First data[0] returns the first JavaScript object.
</p>
<p>
Then the d3.keys() functionality looks at each key,value pair in the object and returns only the keys.
</p>
<p>
This list of keys is returned as an array.
</p>
<p>
Next, the JavaScript Array Filter method is used to applied an anonymous function to each element of this keys array.
</p>
<p>
The anonymous function returns the element as long as it is not equal to the string "State".
</p>
<p>
The reason this is done is because of the data.
</p>
<br>
<p>
If we scroll down to the data and look at it, you can see that it's a two dimensional array.
</p>
<p>
all the data
</p>
<p>
From left to right we have the state and then all the age groups
</p>
<p>
From top to bottom we have all the states in the first column.
</p>
<p>
In all the other columns we have the population of that state in that age group.
</p>
<p>
So when we want the column names that are the age groups, we have to ignore the word "state".
</p>
<br>
<p>
Back in the code, next, we have code that iterates through the array of JavaScript objects
</p>
<p>
<pre><code class="javascript">data.forEach(function(d) {
    d.ages = ageNames.map(function(name) { return {name: name, value: +d[name]}; });
});</code></pre>
</p>
<p>
This code is going to add a new key,value pair to the JavaScript Object Associative Array.
</p>
<p>
For each JavaScript object, it adds a new key called ages.
</p>
<p>
The value that this key gets is an array of objects where each object has two key value pairs.
</p>
<br>
<p>
Inside of the object, the first key value pair is the key "name" and the value of the name of the age group range.
</p>
<p>
<pre><code class="javascript">data.forEach(function(d) {
    d.ages = ageNames.map(function(name) { return {name: name, value: +d[name]}; });
});</code></pre>
</p>
<br>
<p>
Inside of the object, the second key value pair is the key "value" and the value of the numerical amount of population for that age group.
</p>
<p>
<pre><code class="javascript">data.forEach(function(d) {
    d.ages = ageNames.map(function(name) { return {name: name, value: +d[name]}; });
});</code></pre>
</p>
<br>
<p>
Overall, this code goes through each of the JavaScript Objects and for each object generates a new key,value pair where the key is the string "ages" and the value is an array of JavaScript objects each which has an age range and a numerical population value for that age range.
</p>
<p>
<pre><code class="javascript">data.forEach(function(d) {
    d.ages = ageNames.map(function(name) { return {name: name, value: +d[name]}; });
});</code></pre>
</p>
<p>
The reason this is constructed in this way is because we are doing a grouped bar chart.
</p>
<p>
First, the data must be grouped by states.
</p>
<p>
Then inside of each of those state data objects, the data must then be grouped by age groups.
</p>
<p>
We will explore this further in the JavaScript console.
</p>
<br>
<p>
Next, we set the domain for the x0 ordinal scale function
</p>
<p>
<pre><code class="javascript">x0.domain(data.map(function(d) { return d.State; }));</code></pre>
</p>
<p>
This sets the domain of x0 as the list of all of the states found in the data set.
</p>
<br>
<p>
Next, we set the domain and range for the x1 ordinal scale function
</p>
<p>
<pre><code class="javascript">x1.domain(ageNames).rangeRoundBands([0, x0.rangeBand()]);</code></pre>
</p>
<p>
This sets the domain of x1 as the list of all of the age group names found in the data set for each state.
</p>
<p>
This is why the domain wasn't set earlier - because we didn't have the data to tell us what all of the age group names were going to be.
</p>
<p>
Then the range for the x1 ordinal scale function is set as going from 0 to the x0 rangeBand.
</p>
<p>
This x1 range is how the data stays grouped together in the chart.
</p>
<br>
<p>
Next, we set the domain for the y-scale function
</p>
<p>
<pre><code class="javascript">y.domain([0, d3.max(data, function(d) { return d3.max(d.ages, function(d) { return d.value; }); })]);</code></pre>
</p>
<p>
The domain of the Y scale function is a continuous linear function, so the domain will be defined as going from 0 to the max age group population for any one of the states in the data.
</p>
<br>
<p>
To set the domain, we have to use two nested anonymous functions.
</p>
<p>
<pre><code class="javascript">y.domain([0, d3.max(data, function(d) { return d3.max(d.ages, function(d) { return d.value; }); }) ]);</code></pre>
</p>
<p>
The outer most anonymous function goes through all of the elements in the data and passes each JavaScript object to the inner most anonymous function.
</p>
<p>
The inner most anonymous function goes through the array of values found in the key ages and figures out which is the max value.
</p>
<p>
It then returns this value.
</p>
<p>
So for each JavaScript Object, which is a different state, is figures out which is the largest population amount for the age group of that state.
</p>
<p>
Then once is has the largest number for each state, it then figures out what the largest number over all is for all the states provided.
</p>
<p>
This is why it's done in two nested anonymous functions.
</p>
<br>
<p>
Next, we call the D3 dot axis operator for the x-axis.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);</code></pre>
</p>
<p>
This creates the full X Axis.
</p>
<br>
<p>
Then, we create the y-axis and a y-axis text label.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "y axis")
    .call(yAxis)
  .append("text")
    .attr("transform", "rotate(-90)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Population");</code></pre>
</p>
<p>
This creates the full Y Axis.
</p>
<br>
<p>
This code uses the D3 pattern to bind the JavaScript Objects to SVG Group Elements.
</p>
<p>
<pre><code class="javascript">var state = svg.selectAll(".state")
    .data(data)
  .enter().append("g")
    .attr("class", "g")
    .attr("transform", function(d) { return "translate(" + x0(d.State) + ",0)"; });</code></pre>
</p>
<p>
Each JavaScript Object represents one state
</p>
<p>
So 6 SVG Group Elements will created and each one will have bound to it the data for each state.
</p>
<p>
Note that each SVG Group Element is transform translated based on the x0 ordinal function for each specific state.
</p>
<p>
This ensures that when the rectangles for each age group are constructed, that they are constructed in the right place on the graph.
</p>
<p>
This collection of SVG Group Elements is then assigned to a variable named state.
</p>
<br>
<p>
This code then uses the D3 pattern to bind the age group data to SVG rectangles for each of the age group segment found in each state.
</p>
<p>
<pre><code class="javascript">state.selectAll("rect")
    .data(function(d) { return d.ages; })
  .enter().append("rect")
     .attr("width", x1.rangeBand())
     .attr("x", function(d) { return x1(d.name); })
     .attr("y", function(d) { return y(d.value); })
     .attr("height", function(d) { return height - y(d.value); })
     .style("fill", function(d) { return color(d.name); });</code></pre>
</p>
<p>
First, we selectAll the rectangles.
</p>
<p>
Then use the array of JavaScript Objects with the age group name and age group value found in each state's JavaScript Object.
</p>
<p>
So for each SVG Group Element, this code will find the array of JavaScript Objects found at the Associative Array key "age" and construct a rectangle for each of those JavaScript Objects.
</p>
<p>
Once we have all of this data, the enter selection is selected.
</p>
<p>
Then the rectangles are constructed.
</p>
<p>
The width is based on the x1 ordinal scale function range band
</p>
<p>
The x coordinate is based on the age group name passed through the x1 ordinal scale function
</p>
<p>
The y coordinate is based on the age group value passed through the y linear scale function
</p>
<p>
The height is based on the height of the Inner Container minus the age group value passed through the y linear scale function.
</p>
<p>
This is because rectangles are built using the point at the top left.
</p>
<p>
Finally, the fill of the rectangle is chosen based on the color ordinal scale we defined earlier.
</p>
<p>
Remember that this color code does 2 things.
</p>
<p>
One - it returns a color for a given value you pass into it.
</p>
<p>
Two - for every value you pass into it, it adds it to the domain.
</p>
<p>
Which means that at the end of the code the domain of the color ordinal scale function will contain all of the age group names.
</p>
<br>
<p>
Next the legend for the chart is constructed.
</p>
<br>
<p>
First, SVG Group elements are added based on the D3 pattern.
</p>
<p>
<pre><code class="javascript">var legend = svg.selectAll(".legend")
    .data(ageNames.slice().reverse())
  .enter().append("g")
    .attr("class", "legend")
    .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });</code></pre>
</p>
<p>
SVG Group Elements are added based on the data of the age group names.
</p>
<p>
The age group names array is sliced and reversed so that the array has the oldest name of an age group "65 Years and Over" come first.
</p>
<p>
The SVG Group Elements are transform translated according to the index element so that they line up from top to bottom on top of each other.
</p>
<p>
This ensures that the sliced up and reversed array of names has the oldest age group on top going to the youngest age group on the bottom.
</p>
<br>
<p>
Then rectangles are added to the Legend SVG Group Elements based on the width of the Inner Drawing Space.
</p>
<p>
<pre><code class="javascript">legend.append("rect")
    .attr("x", width - 18)
    .attr("width", 18)
    .attr("height", 18)
    .style("fill", color);</code></pre>
</p>
<p>
The color of the rectangle is dictated by the data that was bound to each legend SVG Group Element.
</p>
<p>
Because the domain has already been set for the color ordinal scaling function, it will match up exactly to the bars that were constructed for the grouped bar chart.
</p>
<br>
<p>
Lastly, the age group name is added to each Legend SVG Group Element.
</p>
<p>
<pre><code class="javascript">legend.append("text")
    .attr("x", width - 24)
    .attr("y", 9)
    .attr("dy", ".35em")
    .style("text-anchor", "end")
    .text(function(d) { return d; });</code></pre>
</p>
<p>
The text of each legend is set according to the data bound to each of the Legend SVG Group Elements.
</p>
<br>
<p>
And that is the end of the callback function and the end of the d3.csv function.
</p>
<p>
<pre><code class="javascript">});</code></pre>
</p>
<p>
When this is done, the graph will have been fully generated.
</p>
<br>
<p>
Let's now build this part by part in JavaScript.
</p>
<br>
<br>
<p>
<strong>
JavaScript Code Build
</strong>
</p>
<br>
<p>
Because in the example the building of the chart happens inside of the callback function, we will use a more simple anonymous function in the JavaScript Console.
</p>
<p>
<pre><code class="javascript">d3.csv("data.csv", function(error, data){...});

// =>

var callbackError, callbackData;

d3.csv("data.csv", function(error, data){
    callbackError = error;
    callbackData = data;
});</code></pre>
</p>
<br>
<p>
Alright, to the JavaScript Console.
</p>
<br>
<p>
CLEAR CHROME BROWSER CACHE
</p>
<br>
<p>
From now on, we'll assume that you understand and are able to save down the data in the correct format with the correct file extension, start the Python SimpleHTTP Server, as well as check to make sure D3 is loaded.
</p>
<br>
<p>
We open the Chrome Developer Tools and go step by step building the visualization.
</p>
<br>
<p>
We start by defining the callbackError and callbackData variables which will be used to house the data we get back from the d3.csv function.
</p>
<p>
<pre><code class="javascript">var callbackError, callbackData;</code></pre>
</p>
<br>
<p>
The first step from the example is defining the margins and the width and height of the Inner Drawing Space.
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 40},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;</code></pre>
</p>
<br>
<p>
Next - define the x0 ordinal scale function and it's range round bands.
</p>
<p>
<pre><code class="javascript">var x0 = d3.scale.ordinal()
    .rangeRoundBands([0, width], .1);</code></pre>
</p>
<br>
<p>
Next - define the x1 ordinal scale function
</p>
<p>
<pre><code class="javascript">var x1 = d3.scale.ordinal();</code></pre>
</p>
<br>
<p>
Next - define the y linear scale function and it's range.
</p>
<p>
Remember to pay attention to the fact that the range has height first and then 0.
</p>
<p>
<pre><code class="javascript">var y = d3.scale.linear()
    .range([height, 0]);</code></pre>
</p>
<br>
<p>
Next - define the color ordinal scale function and it's range which will be used to color the different age groups.
</p>
<p>
<pre><code class="javascript">var color = d3.scale.ordinal()
    .range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);</code></pre>
</p>
<br>
<p>
Next - define the xAxis function and provide it with a scale and orientation.
</p>
<p>
<pre><code class="javascript">var xAxis = d3.svg.axis()
    .scale(x0)
    .orient("bottom");</code></pre>
</p>
<br>
<p>
Next - define the yAxis function and provide it with a scale, an orientation and tick formatting.
</p>
<p>
<pre><code class="javascript">var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left")
    .tickFormat(d3.format(".2s"));</code></pre>
</p>
<br>
<p>
Let's test out the D3 formatting function.
</p>
<p>
<pre><code class="javascript">d3.format(".2s")(10000000);</code></pre>
</p>
<p>
You can see that it takes in the 10 million number as a 1 and 7 zeros and converts it to the number 10 with the letter M as the right most element.
</p>
<br>
<p>
Next - define the SVG Container and the Inner Drawing Space
</p>
<p>
<pre><code class="javascript">var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
BROWSER - Open the Body element, the SVG element and show the inner SVG Group Element.
</p>
<br>
<p>
Next is where we are going to differ a bit from the code of the example.
</p>
<p>
<pre><code class="javascript">d3.csv("data.csv", function(error,data) {
    callbackError = error;
    callbackData  = data;
    console.log([callbackError, callbackData.length]);
});</code></pre>
</p>
<p>
Instead of defining an anonymous callback function that does all the generating of the chart in one go, we'll define a callback function that assigns the data and error to variables.
</p>
<p>
We'll then use the callbackError and callbackData variables to build the Grouped Bar Chart.
</p>
<p>
Inside of the callback function, we have a console log of an array of the callbackError and callbackData dot length so we can see what is in each one.
</p>
<p>
We can see that the callbackError is null and that the length of the callbackData array is 6 elements.
</p>
<br>
<p>
Once we have the data, we have to extract the age group names from the callbackData array.
</p>
<p>
<pre><code class="javascript">var ageNames = d3.keys(callbackData[0]).filter(function(key) { return key !== "State"; });

ageNames;</code></pre>
</p>
<p>
You can see all the age group names.
</p>
<br>
<p>
Let's build this step by step to make sure we understand how it works.
</p>
<br>
<p>
First we look at the first JavaScript Object
</p>
<p>
<pre><code class="javascript">callbackData[0];</code></pre>
</p>
<p>
The first JavaScript Object is for the state of California.
</p>
<br>
<p>
Next, let's use the d3.keys functionality to get the keys from all of the key, value pairs.
</p>
<p>
<pre><code class="javascript">d3.keys(callbackData[0]);</code></pre>
</p>
<p>
This returns an array of all the keys for the first JavaScript Object.
</p>
<br>
<p>
Next, let's use the JavaScript Array Filter Method with an anonymous function to generate a new array of elements where every element does not equal the string "State".
</p>
<p>
<pre><code class="javascript">d3.keys(callbackData[0]).filter(function(key) { return key !== "State"; });</code></pre>
</p>
<p>
There we go, these are all the age group names.
</p>
<br>
<p>
Before we do the Array forEach iterator, let's take another look at the first element.
</p>
<p>
<pre><code class="javascript">callbackData[0];</code></pre>
</p>
<p>
BROWSER - expand the object in the console.
</p>
<p>
When we expand the object you can see that it has all the age groups and their respective values as well as the state.
</p>
<br>
<p>
Next - use the Array forEach iterator to go through the 6 element array and create a new key,value pair inside each JavaScript object where the key is the string "ages" and the value is an array of objects where each of these new objects has the age group name and age group population size.
</p>
<p>
<pre><code class="javascript">callbackData.forEach(function(d) {
    d.ages = ageNames.map(function(name) { return {name: name, value: +d[name]}; });
});</code></pre>
</p>
<br>
<p>
Now we look at the first element again.
</p>
<p>
<pre><code class="javascript">callbackData[0];</code></pre>
</p>
<p>
BROWSER - expand the object in the console.
</p>
<p>
This time you can see that a new key,value pair has been added.
</p>
<p>
The key name is ages.
</p>
<p>
The value is an array of 7 objects.
</p>
<p>
BROWSER - expand the array
    </p>
<p>
When we expand the array we can see that it is an array of 7 objects.
    </p>
<p>
BROWSER - expand the first two object
        </p>
<p>
When we expand the first two objects inside of the array inside of the outer object, we see that each one has the keys of "name" and "value" and the values correspond to the data found in the outer object.
        </p>
<p>
This nested data structure will be useful for building the Grouped Bar Chart.
</p>
<br>
<p>
Next - define the domain of the x0 ordinal scale function and then check to see what the domain is.
</p>
<p>
<pre><code class="javascript">x0.domain(callbackData.map(function(d) { return d.State; }));

x0.domain();</code></pre>
</p>
<p>
The domain of the x0 ordinal scale function is the two letter abbreviation of each American state present in the data.
</p>
<br>
<p>
Next - define the domain and range of the x1 ordinal scale function and then check to see what the domain is.
</p>
<p>
<pre><code class="javascript">x1.domain(ageNames).rangeRoundBands([0, x0.rangeBand()]);

x1.domain();</code></pre>
</p>
<p>
The domain of the x1 ordinal scale function is the array of the strings of the 7 different types of age groups.
</p>
<br>
<p>
Next - define the domain for the y linear scale function and then check to see what the domain is.
</p>
<p>
<pre><code class="javascript">y.domain([0, d3.max(callbackData, function(d) { return d3.max(d.ages, function(d) { return d.value; }); })]);

y.domain();</code></pre>
</p>
<p>
The Y linear scale domain goes from 0 to 10,604,510.
</p>
<p>
Remember that the anonymous function inside of the anonymous function looks inside of each state object and then look through the array of objects that has the age group names and values.
</p>
<br>
<p>
Next - the x-axis is created.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);</code></pre>
</p>
<p>
BROWSER - click into the G element
</p>
<p>
If we click into the SVG Group Element for the Inner Drawing Space
</p>
<p>
You can see the SVG Group element with the class "x axis".
</p>
<p>
This is the X axis.
</p>
<br>
<p>
Next - the y-axis is created with the text label.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "y axis")
    .call(yAxis)
  .append("text")
    .attr("transform", "rotate(-90)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Population");</code></pre>
</p>
<br>
<p>
Next - create the SVG Group Elements to which the JavaScript Objects which represent each state will be bound to.
</p>
<p>
<pre><code class="javascript">var state = svg.selectAll(".state")
    .data(callbackData)
  .enter().append("g")
    .attr("class", "g")
    .attr("transform", function(d) { return "translate(" + x0(d.State) + ",0)"; });</code></pre>
</p>
<p>
Note that each SVG Group Element is transform translated to the corresponding place on the chart based on the x0 ordinal scale function.
</p>
<br>
<p>
Let's look at the data that was bound to the first two elements in the state variable.
</p>
<p>
<pre><code class="javascript">state.data()[0];

state.data()[1];</code></pre>
</p>
<p>
These two elements correspond to the California and Texas Data.
</p>
<p>
So the first two SVG Group elements will be California and Texas.
</p>
<br>
<p>
Next - for each of the SVG Group Elements just created, let's create the rectangles based on the age group breakdown and population for each age group.
</p>
<p>
<pre><code class="javascript">state.selectAll("rect")
    .data(function(d) { return d.ages; })
  .enter().append("rect")
    .attr("width", x1.rangeBand())
    .attr("x", function(d) { return x1(d.name); })
    .attr("y", function(d) { return y(d.value); })
    .attr("height", function(d) { return height - y(d.value); })
    .style("fill", function(d) { return color(d.name); });</code></pre>
</p>
<p>
The rectangles now appear.
</p>
<p>
Remember that rectangles are constructed from the top left most point.
</p>
<br>
<p>
Next - the legend for the chart is created.
</p>
<br>
<p>
First - the SVG Group Elements for the legend are created based on the data of the age group names.
</p>
<p>
<pre><code class="javascript">var legend = svg.selectAll(".legend")
    .data(ageNames.slice().reverse())
  .enter().append("g")
    .attr("class", "legend")
    .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });</code></pre>
</p>
<p>
If we scroll to the bottom of the Chrome Developer Tools Elements section, we can see the 7 SVG Group Elements with class of legend.
</p>
<br>
<p>
Next - create the rectangles that are colored based on the age group.
</p>
<p>
<pre><code class="javascript">legend.append("rect")
    .attr("x", width - 18)
    .attr("width", 18)
    .attr("height", 18)
    .style("fill", color);</code></pre>
</p>
<p>
BROWSER - move chrome developer tools to the right and then back.
</p>
<p>
If we move the Chrome Developer Tools to the right, we can see the 7 rectangles that have been crated.
</p>
<p>
BROWSER - scroll down the elements until we can see the legends, then click into one of the SVG Group elements.
</p>
<p>
If we click into the SVG Group Elements with class of legend, we can see the rectangles.
</p>
<br>
<p>
Finally - create the text that goes along with each legend and it's colored rectangle.
</p>
<p>
<pre><code class="javascript">legend.append("text")
    .attr("x", width - 24)
    .attr("y", 9)
    .attr("dy", ".35em")
    .style("text-anchor", "end")
    .text(function(d) { return d; });</code></pre>
</p>
<p>
This created the text for the legend.
</p>
<br>
<p>
And there we go, we have the chart.
</p>
<br>
<p>
Let's close the Chrome Developer tools to get a better look.
</p>
<p>
BROWSER - close the Chrome Developer Tools.
</p>
<p>
BROWSER - zoom out.
</p>
<p>
You can see the full picture.
</p>
<br>
<p>
And with that we built the Basic Chart - Grouped Bar Chart.
</p>
<br>
<p>
The chart was created using two main ideas.
</p>
<p>
The first idea was to nest an array of JavaScript objects inside of a javascript object to achieve a nesting of data inside of other data.
</p>
<p>
The second idea was to use this nesting to do two bindings of data to DOM elements.
</p>
<p>
The first binding was the big data objects which represented the states.
</p>
<p>
The second binding was the interior array of JavaScript objects with each one creating a rectangle to represent the data.
</p>
        </div>
      </div>

    
    
    ☺</div>

<hr>
<h3 id="lesson46">Basic Chart - Stacked Bar Chart<h3>
    <div>
    <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>You will use the CSV data from the D3js.org website Stacked Bar Chart Example to see how a full D3 Stacked Bar Chart Example data visualization is built</li>
<li>Notice that the styling is done in the &lt;style&gt; &lt;/style&gt; section of the HTML document</li>
<li>Notice the D3 Margin Convention</li>
<li>Notice the D3 Ordinal Scale for the X-Axis and the rangeRoundBands</li>
<li>Notice the D3 Linear Scale for the Y-Axis</li>
<li>Notice the D3 Ordinal Scale for the 7 HTML colors used to encode attributes of the data</li>
<li>Notice the D3 SVG Axis component creation and definition for the X-Axis and Y-Axis</li>
<li>Notice the D3 .tickFormat to format the ticks on the Y-Axis</li>
<li>Notice the D3 Type-Specific d3.csv AJAX call</li>
<li>Notice the use of the d3.keys operator</li>
<li>Notice the use the of the .filter, .map, and .forEach array functions</li>
<li>Notice the JavaScript array sorting method</li>
<li>Notice the .domain being set for the primary X-Axis and Y-Axis</li>
<li>Notice the D3 Data Join</li>
<li>Notice the secondary D3 Data Join with a function used to pull out data to bind to the SVG Rectangle DOM Elements</li>
<li>Notice the Third D3 Data Join for the Grouped Bar Chart Legend</li>
<li>Notice how D3 helps create visual representations of the data, stacking of data, and the legend</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-line-chart">Basic Chart - Line Chart</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-scatterplot">Basic Chart - Scatterplot</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-bar-chart">Basic Chart - Bar Chart</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-bar-chart-with-negative-values">Basic Chart - Bar Chart With Negative Values</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-area-chart">Basic Chart - Area Chart</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-grouped-bar-chart">Basic Chart - Grouped Bar Chart</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            Basic Chart - Stacked Bar Chart
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
Visual Code Walk Through
</strong>
</p>
<br>
<p>
[ Image: Stacked Bar Chart Example ]
</p>
<p>
We will cover the D3js.org website Stacked Bar Chart example. 
</p>
<br>
<p>
What is crucial to understand about this chart is that the data is a two dimensional array where we have data on 51 states and for each state we have data on 7 age groups.
</p>
<br>
<p>
So first we have to create 51 JavaScript Objects - which is one for each state.
</p>
<p>
Each of the State JavaScript Objects gets bound to an SVG Group Element.
</p>
<p>
Then for each state we have to create 7 JavaScript objects for each age group population breakdown.
</p>
<p>
The 7 JavaScript objects are aggregated into an array so that we can later use the D3 pattern of passing an array of JavaScript objects to the d3.data functionality.
</p>
<p>
Each of these Age Group JavaScript Objects gets bound to an SVG Rectangle inside of their respective SVG Group Element for the state.
</p>
<br>
<p>
Once we have that understood, the chart is created using two technical ideas which we go into more detail during the Visual Code Walk Through.  
</p>
<br>
<p>
[ Image: Data for Stacked Bar Example ]
</p>
<p>
We will save the data from the example into a file called data.csv
</p>
<p>
This file is the one that will be loaded asynchronously using the D3.csv request functionality.
</p>
<br>
<p>
The document starts with the DocType, Meta Character Set and CSS styling.
</p>
<p>
BROWSER HIGHLIGHT First section
</p>
<p>
<pre><code class="javascript">&lt;!-DOCTYPE ....&lt;/style&gt;</code></pre>
</p>
<p>
This is the standard HTML Doctype, meta character set definition and CSS Styling for the D3 Data Visualization we are making.
</p>
<br>
<p>
Next we go into the JavaScript Sections of the document.
</p>
<br>
<p>
First, we load the D3.js JavaScript Library from the web.
</p>
<p>
BROWSER Highlight &lt;script src....&gt;&lt;/script&gt;
</p>
<p>
This uses the D3 code hosted by the d3js.org website.
</p>
<br>
<p>
Next, we go into the D3 code that will create the Stacked Bar Chart.
</p>
<br>
<p>
The D3 Margin convention sets up the SVG container size as well as defines the Inner Drawing Space.
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 40},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;</code></pre>
</p>
<p>
The SVG Container will be 500 pixels tall by 960 pixels wide.
</p>
<br>
<p>
Next we have an ordinal scaling function for the x-axis data.
</p>
<p>
<pre><code class="javascript">var x = d3.scale.ordinal()
    .rangeRoundBands([0, width], .1);</code></pre>
</p>
<p>
This code creates an ordinal scaling function where the range goes from 0 to the width of the Inner Drawing Space.
</p>
<p>
This ordinal scaling function is using the Range Round Bands to set the bands.
</p>
<p>
Also, the point 1 is the the padding added to offset the bands from the edge of the interval.
</p>
<br>
<p>
Next we have a scale linear function for the y-axis data.
</p>
<p>
<pre><code class="javascript">var y = d3.scale.linear()
    .rangeRound([height, 0]);</code></pre>
</p>
<p>
This code will create a scaling function where the range goes from the height of the Inner Drawing Space to 0.
</p>
<p>
The height and the number zero are reversed so that numbers passed into this scaling function will be converted to numbers that act as if the SVG Coordinate Space has been inverted along the Y-Axis.
</p>
<p>
The RangeRound set's the scales interpolator to d3.interpolateRound which makes values outputted by scale to be exact integers. 
</p>
<br>
<p>
Next we setup an ordinal scaling function for the colors that are going to be used for the different age ranges.
</p>
<p>
<pre><code class="javascript">var color = d3.scale.ordinal()
    .range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);</code></pre>
</p>
<p>
The range is a list of 7 html colors.
</p>
<p>
Note that the domain is not yet set.
</p>
<br>
<p>
Next we create the X-Axis function
</p>
<p>
<pre><code class="javascript">var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");</code></pre>
</p>
<p>
We pass in the x-scale function we created earlier and then give the axis an orientation of bottom.
</p>
<br>
<p>
Then we create the Y-Axis the same way
</p>
<p>
<pre><code class="javascript">var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left")
    .tickFormat(d3.format(".2s"));</code></pre>
</p>
<p>
We pass in the y-scaling function we created earlier and give the axis an orientation of left.
</p>
<p>
We also give the numbers a formatting using the d3.formatting function.
</p>
<p>
This type of formatting is called SI prefix formatting.
</p>
<br>
<p>
The next code creates the SVG Container and the Inner Drawing Space.
</p>
<p>
<pre><code class="javascript">var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<br>
<p>
The next code is where the D3 does the asynchronous call to the server to get the data and then builds the chart.
</p>
<p>
BROWSER HIGHLIGHT all d3.csv
</p>
<p>
In this case, the callback function is an anonymous function.
</p>
<p>
Note - this example uses d3.csv for comma separated values not d3.tsv for tab separated values.
</p>
<br>
<p>
Let's go through the callback function section by section.
</p>
<br>
<p>
First we have code that looks at the first data element, gets the keys and then defines the domain of the Ordinal Color Scale based on those keys.
</p>
<p>
<pre><code class="javascript">color.domain(d3.keys(data[0]).filter(function(key) { return key !== "State"; }));</code></pre>
</p>
<p>
This is constructed in a series of steps.
</p>
<p>
First data[0] returns the first JavaScript object.
</p>
<p>
Then the d3.keys() functionality looks at each key,value pair in the object and returns only the keys.
</p>
<p>
This list of keys is returned as an array.
</p>
<p>
Next, the JavaScript Array Filter method is used to apply an anonymous function to each element of this keys array.
</p>
<p>
The anonymous function returns the element as long as it is not equal to the string "State".
</p>
<p>
Lastly, this array of keys, which represents all of the different types of age-groups, is used to set the domain of the Color Ordinal Scale Function.
</p>
<p>
This ensures that when an age-group in the domain is used, it will be colored the same way everywhere on the chart.
</p>
<br>
<p>
Next, this code iterates through the array of JavaScript objects and defines the coordinates which will later be used to construct the rectangles.
</p>
<p>
<pre><code class="javascript">data.forEach(function(d) {
    var y0 = 0;
    d.ages = color.domain().map(function(name) { return {name: name, y0: y0, y1: y0 += +d[name]}; });
    d.total = d.ages[d.ages.length - 1].y1;
});</code></pre>
</p>
<p>
For each JavaScript object, this code does two main things.
</p>
<p>
The first main thing is it adds a new key,value pair to the Object.
</p>
<p>
This new key,value pair has as it's key name the word "ages" and has as it's value a JavaScript object that contains three keys inside of it - the name of the age group, a y0 and y1.
</p>
<p>
y0 is the total sum of the population below that age group.
</p>
<p>
y1 is the population at that specific age group plus y0.
</p>
<p>
So for the "Under 5 Years" age group - y0 will be zero and y1 will be the population of the "Under 5 Years" age group.
</p>
<p>
For "5 to 13 years" age group, y0 will be the total sum of the population below "5 to 13 years" age group.
</p>
<p>
Y1 will be the total sum of the population below the "5 to 13 years" age group plus the population of the "5 to 13 years" age group.
</p>
<p>
This goes on for all the age groups.
</p>
<p>
The second main thing this code does once it's defined the ages key,value pair, is to figure out what the total population for that state is.
</p>
<p>
It does this by looking at the last element of the ages key,value pair object and getting the y1.
</p>
<p>
The y1, as we just defined, is the sum of all the age groups below that age group plus the population of that age group.
</p>
<p>
So the last y1 of the associative array will be the oldest age group which means it'll tell you the full population.
</p>
<p>
We will explore this further in the JavaScript console.
</p>
<br>
<p>
Next, using the JavaScript array sorting method, this code sorts the JavaScript Data Objects according to their total population.
</p>
<p>
<pre><code class="javascript">data.sort(function(a, b) { return b.total - a.total; });</code></pre>
</p>
<p>
The JavaScript array sorts the numbers as follows:
</p>
<p>
If the return value is less than zero, then sort a to a lower index than b
</p>
<p>
If the return value is zero, then leave a and b unchanged
</p>
<p>
If the return value is greater than zero, then sort b to a lower index than a.
</p>
<p>
Which means in this example, that this will sort all the elements in the data array such that it goes from the largest state population to smallest.
</p>
<p>
This is the first of two reasons why the earlier forEach Array code broke out the total population into it's own separate key,value pair.
</p>
<br>
<p>
Next, we set the domain for the x ordinal scale function
</p>
<p>
<pre><code class="javascript">x.domain(data.map(function(d) { return d.State; }));</code></pre>
</p>
<p>
This sets the domain of x as the list of all of the states found in the data set.
</p>
<p>
Note that the data set has already been sorted, so the domain will be sorted as well.
</p>
<br>
<p>
Next, we set the domain for the y-scale function
</p>
<p>
<pre><code class="javascript">y.domain([0, d3.max(data, function(d) { return d.total; })]);</code></pre>
</p>
<p>
The domain of the Y scale function is a continuous linear function, so the domain will be defined as going from 0 to the max population of all the states in the data.
</p>
<p>
This is the second of two reasons why the earlier forEach Array code broke out the total population into it's own separate key,value pair.
</p>
<br>
<p>
Next, we call the D3 dot axis operator for the x-axis.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);</code></pre>
</p>
<p>
This creates the full X Axis.
</p>
<br>
<p>
Then, we create the y-axis and a y-axis text label.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "y axis")
    .call(yAxis)
  .append("text")
    .attr("transform", "rotate(-90)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Population");</code></pre>
</p>
<p>
This creates the full Y Axis.
</p>
<br>
<p>
Then we use the D3 pattern to bind the JavaScript Objects to SVG Group Elements.
</p>
<p>
<pre><code class="javascript">var state = svg.selectAll(".state")
    .data(data)
  .enter().append("g")
    .attr("class", "g")
    .attr("transform", function(d) { return "translate(" + x(d.State) + ",0)"; });</code></pre>
</p>
<p>
Each JavaScript Object represents one state plus Washington D.C.
</p>
<p>
So 51 SVG Group Elements will created and each one will have bound to it the data for each state.
</p>
<p>
Note that each SVG Group Element is transform translated based on the x ordinal function for each specific state.
</p>
<p>
This ensures that when the rectangles for each age group are constructed, that they are constructed in the right place on the graph.
</p>
<p>
This collection of SVG Group Elements is then assigned to a variable named state.
</p>
<br>
<p>
For each state SVG Group Element, we have to construct the Stacked Bars according to the different population sizes in the different age groups.
</p>
<p>
This code uses the D3 pattern to bind the age group data to SVG rectangles for each of the age group segments found in each state.
</p>
<p>
<pre><code class="javascript">state.selectAll("rect")
    .data(function(d) { return d.ages; })
  .enter().append("rect")
    .attr("width", x.rangeBand())
    .attr("y", function(d) { return y(d.y1); })
    .attr("height", function(d) { return y(d.y0) - y(d.y1); })
    .style("fill", function(d) { return color(d.name); });</code></pre>
</p>
<p>
For each state in the state variable, we are going to do the following:
</p>
<p>
First selectAll the rectangles.
</p>
<p>
Then using the data bound to each state, we look at the ages key and get the array of objects that is the value of that key.
</p>
<p>
This array of 7 different age groups and their data, is what gets passed to the data function.
</p>
<p>
The data function creates 7 placeholder elements in total since there are 7 age groups.
</p>
<p>
The enter selection is selected.
</p>
<p>
Then the append is called which merges the placeholder elements and the SVG Rectangle elements.
</p>
<p>
Then the attributes of each rectangle are defined for each of the 7 age group rectangles.
</p>
<p>
The width is based on the x ordinal scale function range band.
</p>
<p>
The width is the same across all 7 age groups for each of the 51 states.
</p>
<p>
The y coordinate is calculated from getting the y1 of each age group in each state and then putting it through the y linear scaling function.
</p>
<p>
If you recall that the y1 is the total population up to and including that age-group it makes sense - since the SVG rectangles are defined from the top left corner.
</p>
<p>
Next, the height of the rectangle is calculated as the difference between y0 of the age group passed through the y-linear scaling function minus the y1 of the age group passed through the y-linear scaling function.
</p>
<p>
If you are wondering why they are backwards, it is because the y scaling function is backwards as well.
</p>
<p>
That is, the y scaling function range goes from height to 0 in order to have the points scaled through the function behave as if the SVG Y Axis was inverted.
</p>
<p>
Finally, the fill of the rectangle is chosen based on the color ordinal scale we defined earlier.
</p>
<br>
<p>
Next, the legend for the chart is constructed.
</p>
<br>
<p>
First, SVG Group elements are added based on the D3 pattern.
</p>
<p>
<pre><code class="javascript">var legend = svg.selectAll(".legend")
    .data(color.domain().slice().reverse())
  .enter().append("g")
    .attr("class", "legend")
    .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });</code></pre>
</p>
<p>
SVG Group Elements are added based on the data of the age group names.
</p>
<p>
The color ordinal scale domain age group names array is sliced and reversed so that the array has the oldest name of an age group "65 Years and Over" come first.
</p>
<p>
The SVG Group Elements are transform translated according to the index element so that they line up from top to bottom on top of each other.
</p>
<p>
This ensures that the sliced up and reversed array of names has the oldest age group on top going to the youngest age group on the bottom.
</p>
<br>
<p>
Then rectangles are added to the Legend SVG Group Elements based on being 18 units away from the right hand size of the Inner Drawing Space.
</p>
<p>
<pre><code class="javascript">legend.append("rect")
    .attr("x", width - 18)
    .attr("width", 18)
    .attr("height", 18)
    .style("fill", color);</code></pre>
</p>
<p>
The color of the rectangle is dictated by the data that was bound to each legend SVG Group Element.
</p>
<p>
Because the domain has already been set for the color ordinal scaling function, it will match up exactly to the bars that were constructed for the grouped bar chart.
</p>
<br>
<p>
Lastly, the age group name is added to each Legend SVG Group Element.
</p>
<p>
BROWSER HIGHLIGHT 
</p>
<p>
<pre><code class="javascript">legend.append("text")
    .attr("x", width - 24)
    .attr("y", 9)
    .attr("dy", ".35em")
    .style("text-anchor", "end")
    .text(function(d) { return d; });</code></pre>
</p>
<p>
The text of each legend is set according to the data bound to each of the Legend SVG Group Elements.
</p>
<br>
<p>
And that is the end of the callback function and the end of the d3.csv function.
</p>
<p>
<pre><code class="javascript">});</code></pre>
</p>
<p>
When this is done, the graph will have been fully generated.
</p>
<br>
<p>
Let's now build this part by part in JavaScript.
</p>
<br>
<br>
<p>
<strong>
JavaScript Code Build
</strong>
</p>
<br>
<p>
Because in the example the building of the chart happens inside of the callback function, we will use a more simple anonymous function in the JavaScript Console.
</p>
<p>
<pre><code class="javascript">d3.csv("data.csv", function(error, data){...});

// =>

var callbackError, callbackData;

d3.csv("data.csv", function(error, data){
    callbackError = error;
    callbackData = data;
});</code></pre>
</p>
<br>
<p>
Alright, to the JavaScript Console.
</p>
<br>
<p>
CLEAR CHROME BROWSER CACHE
</p>
<br>
<p>
After downloading the data to a data.csv file, starting the Python SimpleHTTP Server and making sure D3 is loaded, we open the Chrome Developer Tools and go step by step building the visualization.
</p>
<br>
<p>
We start by defining the callbackError and callbackData variables which will be used to house the data we get back from the d3.csv function.
</p>
<p>
<pre><code class="javascript">var callbackError, callbackData;</code></pre>
</p>
<br>
<p>
The first step from the example is defining the margins and the width and height of the Inner Drawing Space.
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 20, bottom: 30, left: 40},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;</code></pre>
</p>
<br>
<p>
Next - define the x ordinal scale function and it's range round bands.
</p>
<p>
<pre><code class="javascript">var x = d3.scale.ordinal()
    .rangeRoundBands([0, width], .1);</code></pre>
</p>
<br>
<p>
Next - define the y linear scale function and it's range.
</p>
<p>
Remember to pay attention to the fact that the range has height first and then 0.
</p>
<p>
Also pay attention to the fact that we are using rangeRound to make sure the scaled numbers returned are integers.
</p>
<p>
<pre><code class="javascript">var y = d3.scale.linear()
    .rangeRound([height, 0]);</code></pre>
</p>
<br>
<p>
Next - define the color ordinal scale function and it's range,  which will be used to color the different age groups.
</p>
<p>
<pre><code class="javascript">var color = d3.scale.ordinal()
    .range(["#98abc5", "#8a89a6", "#7b6888", "#6b486b", "#a05d56", "#d0743c", "#ff8c00"]);</code></pre>
</p>
<br>
<p>
Next - define the xAxis function and provide it with a scale and orientation.
</p>
<p>
<pre><code class="javascript">var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");</code></pre>
</p>
<br>
<p>
Next - define the yAxis function and provide it with a scale, an orientation and tick formatting.
</p>
<p>
<pre><code class="javascript">var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left")
    .tickFormat(d3.format(".2s"));</code></pre>
</p>
<br>
<p>
Next - define the SVG Container and the Inner Drawing Space
</p>
<p>
<pre><code class="javascript">var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
  </p>
<p>
BROWSER - Open the Body element, the SVG element and show the inner SVG Group Element.
</p>
<br>
<p>
Next is where we are going to differ a bit from the code of the example.
</p>
<p>
<pre><code class="javascript">d3.csv("data.csv", function(error,data) {
    callbackError = error;
    callbackData  = data;
    console.log([callbackError, callbackData.length]);
});</code></pre>
</p>
<p>
Instead of defining an anonymous callback function that does all the generating of the chart in one go, we'll define a callback function that assigns the data and error to variables.
</p>
<p>
We'll then use the callbackError and callbackData variables to build the Grouped Bar Chart.
</p>
<p>
Inside of the callback function, we have a console log of an array of the callbackError and callbackData dot length so we can see what is in each one of them.
</p>
<p>
We can see that the callbackError is null and that the length of the callbackData array is 51 elements which represent the 50 US States and the city of Washington D.C.
</p>
<br>
<p>
Once we have the data, we extract the age group names from the callbackData array and assign them to the domain of the color ordinal scale function.
</p>
<p>
<pre><code class="javascript">color.domain(d3.keys(callbackData[0]).filter(function(key) { return key !== "State"; }));

color.domain();</code></pre>
  </p>
<p>
You can see all the age group names.
</p>
<br>
<p>
Before we do the Array forEach iterator, let's take another look at the first element.
</p>
<p>
<pre><code class="javascript">callbackData[0];</code></pre>
</p>
<p>
BROWSER - expand the object in the console.
</p>
<p>
When we expand the object you can see that it has all the age groups and their respective values as well as the state.
</p>
<br>
<p>
Next - use the Array forEach iterator to go through the 51 element array and for each state element, create two new key,value pair inside.
</p>
<p>
The first key is the string "ages" and the value of this key is an array of JavaScript objects.
</p>
<p>
The second key is the string "total" and the value of this key is the total population for this state.
</p>
<p>
The first key's value is an array of objects where each of these new objects has three keys - the string "name", the string "y0" and the string "y1".
</p>
<p>
The key name has as it's value the age group name.
</p>
<p>
The key y0 has as it's value the sum of the population of all the age groups beneath this one.
</p>
<p>
The key y1 has as it's value the sum y0 plus the population of this particular age group.
</p>
<p>
<pre><code class="javascript">callbackData.forEach(function(d) {
    var y0 = 0;
    d.ages = color.domain().map(function(name) { return {name: name, y0: y0, y1: y0 += +d[name]}; });
    d.total = d.ages[d.ages.length - 1].y1;
});</code></pre>
</p>
<p>
These two levels of JavaScript objects defined inside of JavaScript objects is necessary to produce the Stacked Bar Charts.
</p>
<p>
The first level pertains to the states and the second level pertains to the stacked bars for each state.
</p>
<br>
<p>
Now we look at the first element again.
</p>
<p>
<pre><code class="javascript">callbackData[0];</code></pre>
</p>
<p>
BROWSER - expand the first object in the console.
</p>
<p>
Note that this state is "AL" which stands for Alabama.
</p>
<p>
This time you can see that two new key,value pairs have been added.
</p>
<p>
We look at the first Object in the key,value pair of ages and the array.
</p>
<p>
You can see that the name of the age group which is "Under 5 years", has y0 as 0 and has y1 as 310,504.
</p>
<p>
If we look slightly up, we see in the original key,value pairs of the object that the size of the population of the "Under 5 years" is 310,504 which is the same as y1.
</p>
<p>
The y0 and y1 for this object make sense.
</p>
<p>
There are 0 people under the under 5 years age group so y0 is 0.
</p>
<p>
y0 plus 310,504 which is the population of under 5 years age group is 310,504 so y1 makes sense.
</p>
<br>
<p>
Next, let's look at the second object in the key,value pair of ages.
</p>
<p>
BROWSER - expand the second object in the console.
</p>
<p>
You can see that the name of the age group is "5 to 13 years", that y0 is 310,504 and that y1 is 862,843.
</p>
<p>
y0 is 310,504 because this is the total sum of all the age groups below "5 to 13 years" which in this case is only the "under 5 years" age group.
</p>
<p>
y1 is 862,843 because it is the y0 figure plus the 552,339 figure from the "5 to 13 years" key,value pair in the original JavaScript Object.
</p>
<p>
This continues for the rest of the 7 age group specific objects.
</p>
<br>
<p>
If we look at the last object, we see that the age group it represents is "65 Years and Over".
</p>
<p>
BROWSER HIGHLIGHT "last object"
</p>
<p>
The y1 here is the total population for this age group and all the age groups below.
</p>
<p>
Which if we look at the 1st level of key,value pairs also equals the new key,value pair that was added which is the key "total" and the value of 4,661,900.
</p>
<p>
So this value makes sense as well.
</p>
<br>
<p>
Next - sort the callbackData variable so that the states with the largest populations come first and then decline in order.
</p>
<p>
<pre><code class="javascript">callbackData.sort(function(a, b) { return b.total - a.total; });</code></pre>
</p>
<br>
<p>
If we check the first element of the callbackData array
  - callbackData[0];
</p>
<p>
We can see that "CA" which stands for California is now the first state.
</p>
<p>
This is because CA has the largest population of all the states in the US for this dataset.
</p>
<br>
<p>
Next - define the domain of the x ordinal scale function and then check to see what the domain is.
</p>
<p>
<pre><code class="javascript">x.domain(callbackData.map(function(d) { return d.State; }));

x.domain();</code></pre>
  </p>
<p>
The domain of the x ordinal scale function is the two letter abbreviation of each American state present in the data sorted by order of descending population.
</p>
<br>
<p>
Next - define the domain for the y linear scale function and then check to see what the domain in.
</p>
<p>
<pre><code class="javascript">y.domain([0, d3.max(callbackData, function(d) { return d.total; })]);

y.domain();</code></pre>
</p>
<p>
The Y linear scale domain goes from 0 to 36,756,666.
</p>
<br>
<p>
Next - the x-axis is created.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);</code></pre>
</p>
<p>
BROWSER - click into the G element
</p>
<p>
If we click into the SVG Group Element for the Inner Drawing Space
</p>
<p>
You can see the SVG Group element with the class "x axis".
</p>
<br>
<p>
Next - the y-axis is created with the text label.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "y axis")
    .call(yAxis)
  .append("text")
    .attr("transform", "rotate(-90)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Population");</code></pre>
</p>
<br>
<p>
Next - create the SVG Group Elements which the JavaScript Objects which represent each state will be bound to.
</p>
<p>
<pre><code class="javascript">var state = svg.selectAll(".state")
    .data(callbackData)
  .enter().append("g")
    .attr("class", "g")
    .attr("transform", function(d) { return "translate(" + x(d.State) + ",0)"; });</code></pre>
</p>
<p>
Note that each SVG Group Element is transform translated to the corresponding place in the chart based on the x ordinal scale function.
</p>
<br>
<p>
Next - for each of the SVG Group Elements just created, let's create the rectangles based on the age group breakdown and population for each age group.
</p>
<p>
<pre><code class="javascript">state.selectAll("rect")
    .data(function(d) { return d.ages; })
  .enter().append("rect")
    .attr("width", x.rangeBand())
    .attr("y", function(d) { return y(d.y1); })
    .attr("height", function(d) { return y(d.y0) - y(d.y1); })
    .style("fill", function(d) { return color(d.name); });</code></pre>
</p>
<p>
The rectangles now appear.
</p>
<p>
Remember that rectangles are constructed from the top left most point.
</p>
<br>
<p>
If we go into the first SVG Group element, which represents California, and we hover over each rectangle, we can see how each rectangle is built on top of each other.
</p>
<p>
SVG Rectangles Elements.
</p>
<br>
<p>
Next - the legend for the chart is created.
</p>
<br>
<p>
First - the SVG Group Elements for the legend are created based on the data of the age group names from the color ordinal scale domain.
</p>
<p>
<pre><code class="javascript">var legend = svg.selectAll(".legend")
    .data(color.domain().slice().reverse())
  .enter().append("g")
    .attr("class", "legend")
    .attr("transform", function(d, i) { return "translate(0," + i * 20 + ")"; });</code></pre>
</p>
<br>
<p>
Next - create the rectangles that are colored based on the age group.
</p>
<p>
<pre><code class="javascript">legend.append("rect")
    .attr("x", width - 18)
    .attr("width", 18)
    .attr("height", 18)
    .style("fill", color);</code></pre>
</p>
<br>
<p>
Finally - create the text that goes along with each legend and it's colored rectangle.
</p>
<p>
<pre><code class="javascript">legend.append("text")
    .attr("x", width - 24)
    .attr("y", 9)
    .attr("dy", ".35em")
    .style("text-anchor", "end")
    .text(function(d) { return d; });</code></pre>
</p>
<br>
<p>
And there we go, we have the Stacked Bar Chart.
</p>
<br>
<p>
Let's close the Chrome Developer tools to get a better look.
</p>
<p>
BROWSER - close the Chrome Developer Tools.
</p>
<p>
BROWSER - zoom out.
</p>
<p>
You can see the full picture.
</p>
<br>
<p>
And with that we built the Basic Chart - Stacked Bar Chart.
</p>
<br>
<p>
What is crucial to understand about this chart is that the data is a two dimensional array where we have data on 51 states and for each state we have data on 7 age groups.
</p>
<br>
<p>
So first we have to create 51 JavaScript Objects - which is one for each state.
</p>
<p>
Each of the State JavaScript Objects gets bound to an SVG Group Element.
</p>
<p>
Then for each state we have to create 7 JavaScript objects for each age group population breakdown.
</p>
<p>
The 7 JavaScript objects are aggregated into an array so that we can later use the D3 pattern of passing an array of JavaScript objects to the d3.data functionality.
</p>
<p>
Each of these Age Group JavaScript Objects gets bound to an SVG Rectangle inside of their respective SVG Group Element for the state.
</p>
<p>
Finally, the rectangles are the colored and positioned using x and y coordinates as well as height based on their population.
</p>
        </div>
      </div>
    
    ☺</div>


<hr>
<h3 id="lesson47">Basic Chart - Multi-Series Line Chart<h3>
    <div>
        <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>You will use the TSV data from the D3js.org website Multi-Series Line Chart Example to see how a full D3 Multi-Series Line Chart Example data visualization is built</li>
<li>Notice that the data is a two dimensional array where we have data on 3 cities and for each city we have data on 366 different days</li>
<li>Notice that the styling is done in the &lt;style&gt; &lt;/style&gt; section of the HTML document</li>
<li>Notice the D3 Margin Convention</li>
<li>Notice the D3 Time Formatting function</li>
<li>Notice the D3 Time scale function for the X-Axis</li>
<li>Notice the D3 Linear Scale for the Y-Axis</li>
<li>Notice the D3 Ordinal Scale for the color - d3.scale.category10()</li>
<li>Notice the D3 SVG Axis component creation and definition for the X-Axis and Y-Axis</li>
<li>Notice the D3 SVG Path Generator Function and its accessor functions</li>
<li>Notice the D3 Type-Specific d3.tsv AJAX call</li>
<li>Notice the use of the d3.keys operator</li>
<li>Notice the use the of the .filter, .map, and .forEach array functions</li>
<li>Notice the use the .map within a .map to build an array of JavaScript objects that are organized in a D3-Friendly way</li>
<li>Notice the .domain being set for the X-Axis and Y-Axis</li>
<li>Notice the D3 Data Join</li>
<li>Notice the secondary D3 Data Join done as a .datum(...) with a function</li>
<li>Notice how D3 helps create visual representations of the data - the multi-series lines</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-line-chart">Basic Chart - Line Chart</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-scatterplot">Basic Chart - Scatterplot</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-bar-chart">Basic Chart - Bar Chart</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-bar-chart-with-negative-values">Basic Chart - Bar Chart With Negative Values</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-area-chart">Basic Chart - Area Chart</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-grouped-bar-chart">Basic Chart - Grouped Bar Chart</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-stacked-bar-chart">Basic Chart - Stacked Bar Chart</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            Basic Chart - Multi-Series Line Chart
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
Visual Code Walk Through
</strong>
</p>
<br>
<p>
[ Image: Multi-Series Line Chart ]
</p>
<p>
We will cover the D3js.org website Multi-Series Line Chart example.   
</p>
<br>
<p>
What is crucial to understand about this chart is that the data is a two dimensional array where we have data on 3 cities and for each city we have data on 366 different days.
</p>
<br>
<p>
Because the data gets processed into an Array of 366 JavaScript objects where each Object is a specific date and the temperature for three different cities, we have to change the data into a more D3 friendly format.
</p>
<p>
Because we want a line for each city, we have to reconstruct the data so that we have one JavaScript object for each city.
</p>
<p>
Then in each city, we want to have a time series of dates and temperatures on that date.
</p>
<p>
Because D3 data functionality takes in an array of JavaScript objects, we have to create a nested data set.
</p>
<p>
This data set will consist of an array of JavaScript Objects where each one represents a city.
</p>
<p>
Then inside of each object, we need a key value pair that then references an inner array of objects where each of these inner objects is a date and a temperature.
</p>
<p>
Once we have this array of objects with an inner array of objects inside each of them, we can bind the outside objects to SVG Group Elements and we can bind the inside objects to an SVG Path Element based on the D3 Path Generating Function.
</p>
<br>
<p>
We will save the data from the example into a file called data.tsv
</p>
<p>
[ Image: Data for Multi-Series Line Chart ]
</p>
<p>
This file is the one that will be loaded asynchronously using the D3.tsv request functionality.
</p>
<br>
<p>
The document starts with the DocType, Meta Character Set and CSS styling.
</p>
<p>
BROWSER HIGHLIGHT First section
</p>
<p>
<pre><code class="html">&lt;!-DOCTYPE ....&lt;/style&gt;</code></pre>
</p>
<p>
This is the standard HTML Doctype, meta character set definition and CSS Styling for the D3 Data Visualization we are making.
</p>
<br>
<p>
Next we go into the JavaScript Sections of the document.
</p>
<br>
<p>
First, we load the D3.js JavaScript Library from the web.
</p>
<p>
BROWSER Highlight &lt;script src....&gt;&lt;/script&gt;
</p>
<p>
This uses the D3 code hosted by the d3js.org website.
</p>
<br>
<p>
Next, we go into the D3 code that will create the Multi-Series Line Chart.
</p>
<br>
<p>
The D3 Margin convention sets up the SVG container size as well as defines the Inner Drawing Space.
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 80, bottom: 30, left: 50},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;</code></pre>
</p>
<br>
<p>
Next have a D3 Time Formatting function which will parse a date string formatted in a certain way and convert it into a JavaScript Date Object.
</p>
<p>
<pre><code class="javascript">var parseDate = d3.time.format("%Y%m%d").parse;</code></pre>
</p>
<br>
<p>
Next we have a timescale function for the x-axis data.
</p>
<p>
<pre><code class="javascript">var x = d3.time.scale()
    .range([0, width]);</code></pre>
</p>
<p>
This code creates a timescale scaling function where the range goes from zero to the width of the Inner Drawing Space.
</p>
<br>
<p>
Next we have a scale linear function for the y-axis data.
</p>
<p>
<pre><code class="javascript">var y = d3.scale.linear()
    .range([height, 0]);</code></pre>
</p>
<p>
This code will create a scaling function where the range goes from the height of the Inner Drawing Space to 0.
</p>
<p>
The height and the number zero are reversed so that numbers passed into this scaling function will be converted to numbers that act as if the SVG Coordinate Space has been inverted along the Y-Axis.
</p>
<br>
<p>
Next we setup an ordinal scaling function for the colors that are going to be used for the different series of data ranges.
</p>
<p>
<pre><code class="javascript">var color = d3.scale.category10();</code></pre>
</p>
<p>
We are using the category10 color scale that D3 includes.
</p>
<p>
Note that the domain is not yet set.
</p>
<br>
<p>
Next we create the X-Axis function
</p>
<p>
<pre><code class="javascript">var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");</code></pre>
</p>
<p>
We pass in the x-scale function we created earlier and then give the axis an orientation of bottom.
</p>
<br>
<p>
Then we create the Y-Axis the same way
</p>
<p>
<pre><code class="javascript">var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");</code></pre>
</p>
<p>
We pass in the y-scaling function we created earlier and give the axis an orientation of left.
</p>
<br>
<p>
Next, this code defines the D3 path generation function.
</p>
<p>
<pre><code class="javascript">var line = d3.svg.line()
    .interpolate("basis")
    .x(function(d) { return x(d.date); })
    .y(function(d) { return y(d.temperature); });</code></pre>  
</p>
<p>
This uses the D3 Path Data Generator Functionality.
</p>
<p>
For x values and y values, the code defines specific accessor functions.
</p>
<p>
The data set we are looking at is comprised of dates and temperatures.
</p>
<p>
This creates a function which will be called later.
</p>
<br>
<p>
The next code creates the SVG Container and the Inner Drawing Space.
</p>
<p>
<pre><code class="javascript">var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<br>
<p>
The next code is where the D3 does the asynchronous call to the server to get the data and then builds the chart.
</p>
<p>
BROWSER HIGHLIGHT all d3.tsv
</p>
<p>
In this case, the callback function is an anonymous function.
</p>
<p>
Note - this example uses d3.tsv for tab separated values not d3.csv for comma separated values.
</p>
<br>
<p>
Let's go through the callback function section by section.
</p>
<br>
<p>
First we have code that looks at the first data element, gets the object keys and then defines the domain of the Ordinal Color Scale based on those keys.
</p>
<p>
<pre><code class="javascript">color.domain(d3.keys(data[0]).filter(function(key) { return key !== "State"; }));</code></pre>
</p>
<p>
This is constructed in a series of steps.
</p>
<p>
First data[0] returns the first JavaScript object.
</p>
<p>
Then the d3.keys() functionality looks at each key,value pair in the object and returns only the keys.
</p>
<p>
This list of keys is returned as an array.
</p>
<p>
Next, the JavaScript Array Filter method is used to apply an anonymous function to each element of this keys array.
</p>
<p>
The anonymous function returns the element as long as it is not equal to the string "date".
</p>
<p>
Lastly, this array of keys, which represents all of the different cities, is used to set the domain of the Color Ordinal Scale Function.
</p>
<p>
This ensures that when a city in the domain is used, it will be colored the same way everywhere on the chart.
</p>
<br>
<p>
This code iterates through the array of JavaScript objects
</p>
<p>
<pre><code class="javascript">data.forEach(function(d) {
    d.date = parseDate(d.date);
});</code></pre>
</p>
<p>
For each JavaScript object it does one thing:
</p>
<p>
It converts the date string to a JavaScript Date Object.
</p>
<p>
It does this by using the parseDate function we defined earlier.
</p>
<p>
The parseData function takes in a string and using the format we specified, it creates a new JavaScript Date Object.
</p>
<p>
Then it assigns it right back to the d.date key.
</p>
<br>
<p>
Next, this code does the hard work of organizing the data in a way that is usable by the D3 pattern.
</p>
<p>
<pre><code class="javascript">var cities = color.domain().map(function(name) {
    return {
        name: name,
        values: data.map(function(d) {
            return {date: d.date, temperature: +d[name]};
        })
    };
});</code></pre>
</p>
<p>
First - a function is applied to every element in the color domain, which is the three city names.
</p>
<p>
This function returns an object with two key, value pairs.
</p>
<p>
The keys are the string "name" and the string "values"
</p>
<p>
The value of the string "name" is the name of the city
</p>
<p>
The value of the string "values" is an array of 366 objects where each objects has the date and temperature inside, based on the data from the data.tsv file.
</p>
<p>
The date is a JavaScript Date object.
</p>
<p>
The temperature is a JavaScript Number.
</p>
<p>
As you can tell, this is the nesting of data inside of data.
</p>
<p>
This will be used to first bind the cities to SVG Group Elements and then use the interior data of the cities to bind the temperatures to an SVG Path.
</p>
<p>
So overall, we get an array of 3 JavaScript objects representing the cities.
</p>
<p>
Each of these JavaScript objects has an array of JavaScript objects inside where each interior object represents a date and a temperature.
</p>
<p>
This array of 3 JavaScript objects is then assigned to the variable "cities".
</p>
<br>
<p>
Next, we set the domain for the x scale function
</p>
<p>
<pre><code class="javascript">x.domain(d3.extent(data, function(d) { return d.date; }));</code></pre>
</p>
<p>
Now that we have the data, we can set the domain of the x scale function by using the D3.extent method.
</p>
<p>
An anonymous function is used to get the date out of the Data Objects.
</p>
<p>
This returns an array containing the minimum and maximum dates which is used to set the domain for the x scale function.
</p>
<br>
<p>
Next, we set the domain for the y scale function
</p>
<p>
<pre><code class="javascript">y.domain([
    d3.min(cities, function(c) { return d3.min(c.values, function(v) { return v.temperature; }); }),
    d3.max(cities, function(c) { return d3.max(c.values, function(v) { return v.temperature; }); })
]);</code></pre>
</p>
<p>
To get the domain this code figures out the minimum and maximum temperatures for the cities.
</p>
<p>
Because the data is nested, to figure out the minimum and maximum temperatures, two anonymous functions need to be used.
</p>
<p>
The inner anonymous function figures out either the minimum or maximum temperature for a given city.
</p>
<p>
The outer anonymous function figures out what the minimum or maximum temperature is for all the cities in the data.
</p>
<br>
<p>
Next, we create the x-axis.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);</code></pre>
</p>
<br>
<p>
Then, we create the y-axis and a y-axis text label.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "y axis")
    .call(yAxis)
  .append("text")
    .attr("transform", "rotate(-90)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Temperature (ºF)");</code></pre>       
</p>
<br>
<p>
Then we use the D3 pattern to bind the City JavaScript Objects in the cities array to SVG Group Elements.
</p>
<p>
<pre><code class="javascript">var city = svg.selectAll(".city")
    .data(cities)
  .enter().append("g")
    .attr("class", "city");</code></pre>
</p>
<p>
The data operator takes in an array of three JavaScript objects.
</p>
<p>
Each JavaScript object in the array is a city.
</p>
<p>
So each SVG Group Element with a class of city will have bound to it a city JavaScript object.
</p>
<p>
This collection of SVG Group Elements is then assigned to a variable named city.
</p>
<br>
<p>
And then finally, we draw the path for each city.
</p>
<p>
<pre><code class="javascript">city.append("path")
    .attr("class", "line")
    .attr("d", function(d) { return line(d.values); })
    .style("stroke", function(d) { return color(d.name); });</code></pre>
</p>
<p>
Since each SVG Group Element already has a JavaScript Object bound to it's data attribute, we can use this object to generate the necessary data.
</p>
<p>
For each SVG Group Element in the city variable, we append a path.
</p>
<p>
For each path we then define the "d" attribute which is what generates the line.
</p>
<p>
The value of the d attribute is the set of SVG Path Instructions generated by the D3 Path Generator Function we defined earlier.
</p>
<p>
The style of the stroke is based on the city name passed to the color ordinal domain function.
</p>
<p>
Because we defined the domain earlier, all this does is return a color to be used for each specific city.
</p>
<br>
<p>
Lastly, for each city SVG Group Element, we have to add to the chart the name of the city at the very end of the line.
</p>
<p>
<pre><code class="javascript">city.append("text")
    .datum(function(d) { return {name: d.name, value: d.values[d.values.length - 1]}; })
    .attr("transform", function(d) { return "translate(" + x(d.value.date) + "," + y(d.value.temperature) + ")"; })
    .attr("x", 3)
    .attr("dy", ".35em")
    .text(function(d) { return d.name; });</code></pre>
</p>
<p>
This is done through the D3 pattern.
</p>
<p>
First append text to the SVG Group Element each city represents.
</p>
<p>
Then to this text, we bind a JavaScript object using the d3.datum operator.
</p>
<p>
The JavaScript Object is created by using the data attached to the SVG Group Element for each city.
</p>
<p>
The name key's value is the name of the city.
</p>
<p>
The value key's value is the last JavaScript Object, which represents the date and temperature, in the array of JavaScript Object that lives in the SVG Group Element.
</p>
<p>
This is the nested data.
</p>
<p>
Then this SVG text is transform translated according to the last date and temperature after they have been run through their respective scaling functions.
</p>
<p>
Then the x and dy attributes are defined.
</p>
<p>
Finally, the actual text of the SVG Text element is defined as the name of the city.
</p>
<p>
We explore this further in the JavaScript Console section.
</p>
<br>
<p>
And that is the end of the callback function and the end of the d3.tsv function.
</p>
<p>
<pre><code class="javascript">});</code></pre>
</p>
<p>
When this is done, the graph will have been fully generated.
</p>
<br>
<p>
Let's now build this part by part in JavaScript.
</p>
<br>
<br>
<p>
<strong>
JavaScript Code Build
</strong>
</p>
<br>
<p>
Because in the web example the building of the chart happens inside of a callback function, we will use a more simple anonymous function in the JavaScript Console.
</p>
<p>
<pre><code class="javascript">d3.tsv("data.tsv", function(error, data){...});

// =>

var callbackError, callbackData;

d3.tsv("data.tsv", function(error, data){
    callbackError = error;
    callbackData = data;
});</code></pre>
</p>
<br>
<p>
Alright, to the JavaScript Console.
</p>
<br>
<p>
CLEAR CHROME BROWSER CACHE
</p>
<br>
<p>
After downloading the data to a data.tsv file, starting the Python SimpleHTTP Server and making sure D3 is loaded, we open the Chrome Developer Tools and go step by step building the visualization.
</p>
<br>
<p>
We start by defining the callbackError and callbackData variables which will be used to house the data we get back from the d3.tsv function.
</p>
<p>
<pre><code class="javascript">var callbackError, callbackData;</code></pre>
</p>
<br>
<p>
The first step from the example is defining the margins and the width and height of the Inner Drawing Space.
</p>
<p>
<pre><code class="javascript">var margin = {top: 20, right: 80, bottom: 30, left: 50},
    width = 960 - margin.left - margin.right,
    height = 500 - margin.top - margin.bottom;</code></pre>
</p>
<br>
<p>
Next - define the date parsing function.
</p>
<p>
<pre><code class="javascript">var parseDate = d3.time.format("%Y%m%d").parse;</code></pre>
</p>
<br>
<p>
Next - define the x time scale function as well as the range of the function.
</p>
<p>
<pre><code class="javascript">var x = d3.time.scale()
    .range([0, width]);</code></pre>
</p>
<br>
<p>
Next - define the y linear scale function and it's range.
</p>
<p>
<pre><code class="javascript">var y = d3.scale.linear()
    .range([height, 0]);</code></pre>
</p>
<p>
Remember to pay attention to the fact that the range has height first and then 0.
</p>
<br>
<p>
Next - define the color ordinal scale function which will be used to color the different cities.
</p>
<p>
<pre><code class="javascript">var color = d3.scale.category10();</code></pre>
</p>
<p>
This is the D3 category10 color ordinal scale that comes included in the D3 library.
</p>
<br>
<p>
Next - define the xAxis function and provide it with a scale and orientation.
</p>
<p>
<pre><code class="javascript">var xAxis = d3.svg.axis()
    .scale(x)
    .orient("bottom");</code></pre>
</p>
<br>
<p>
Next - define the yAxis function and provide it with a scale and orientation.
</p>
<p>
<pre><code class="javascript">var yAxis = d3.svg.axis()
    .scale(y)
    .orient("left");</code></pre>
</p>
<br>
<p>
Next - define the D3 path Generator function.
</p>
<p>
<pre><code class="javascript">var line = d3.svg.line()
    .interpolate("basis")
    .x(function(d) { return x(d.date); })
    .y(function(d) { return y(d.temperature); });</code></pre>
</p>
<p>
This will use accessor functions to get the date and temperature from JavaScript Objects.
</p>
<p>
Then each data point will be scaled according to the x and y scaling functions.
</p>
<p>
The interpolation for this D3 Path Generator function is basis.
</p>
<br>
<p>
Next - define the SVG Container and the Inner Drawing Space
</p>
<p>
<pre><code class="javascript">var svg = d3.select("body").append("svg")
    .attr("width", width + margin.left + margin.right)
    .attr("height", height + margin.top + margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");</code></pre>
</p>
<p>
BROWSER - Open the Body element, the SVG element and show the inner SVG Group Element.        
</p>
<br>
<p>
Next is where we are going to differ a bit from the code of the example.
</p>
<p>
<pre><code class="javascript">d3.tsv("data.tsv", function(error, data) {
    callbackError = error;
    callbackData  = data;
    console.log([callbackError, callbackData.length]);
});</code></pre>
</p>
<p>
Instead of defining an anonymous callback function that does all the generating of the chart in one go, we'll define a callback function that assigns the data and error to variables.
</p>
<p>
We'll then use the callbackError and callbackData variables to build the Multi-Series Line Chart.
</p>
<p>
Inside of the callback function, we have a console log of an array of the callbackError and callbackData dot length so we can see what is in each one of them.
</p>
<p>
We can see that the callbackError is null and that the length of the callbackData array is 366 elements.
</p>
<br>
<p>
Let's look at the first element.
</p>
<p>
<pre><code class="javascript">callbackData[0];</code></pre>
</p>
<p>
It is a JavaScript Object where the keys are three different city names and the word date.
</p>
<p>
The values for the cities are temperatures and the value for the word date is the date in a specific format.
</p>
<p>
Currently the data is organized as 1 date and the values for each city.
</p>
<p>
What we would rather have are separate objects for each city and have them have a date and a temperature for the time series of dates.
</p>
<p>
This would make it easier to build a line path using the D3 pattern.
</p>
<br>
<p>
Once we have the data, we extract the city names from the callbackData array and assign them to the domain of the color ordinal scale function.
</p>
<p>
<pre><code class="javascript">color.domain(d3.keys(callbackData[0]).filter(function(key) { return key !== "date"; }));

color.domain();</code></pre>
</p>
<p>
You can see that the domain is the name of the three cities.
</p>
<br>
<p>
Before we do the Array forEach iterator, let's take another look at the first element.
</p>
<p>
<pre><code class="javascript">callbackData[0];</code></pre>
</p>
<p>
BROWSER - expand the object in the console.
</p>
<p>
When we expand the object you can see that it has a date and the three city names and their respective temperature values.
</p>
<br>
<p>
Next - we use the D3 Array forEach iterator to go through the array and change the string values to JavaScript Date Objects for each object.
</p>
<p>
<pre><code class="javascript">callbackData.forEach(function(d) {
    d.date = parseDate(d.date);
});</code></pre>
</p>
<br>
<p>
We then check to make sure the date was parsed correctly.
</p>
<p>
<pre><code class="javascript">callbackData[0];</code></pre>
</p>
<p>
Yes it was, the date is now a JavaScript Date Object.
</p>
<br>
<p>
Next, this code does the hard work of organizing the data in a way that is usable by the D3 pattern.
</p>
<p>
<pre><code class="javascript">var cities = color.domain().map(function(name) {
    return {
        name: name,
        values: callbackData.map(function(d) {
            return {date: d.date, temperature: +d[name]};
        })
    };
});</code></pre>
</p>
<br>
<p>
Let's break down what happened into smaller steps:
</p>
<br>
<p>
First - a function is applied to every element in the color domain, which is the three city names.
</p>
<p>
<pre><code class="javascript">cities;</code></pre>
</p>
<p>
BROWSER - Open all the objects
</p>
<p>
You can see that the variable cities is an array of three objects.
</p>
<p>
Each object represents one of the cities.
</p>
<p>
Each city has a values key which has a value of an array of 366 objects.
</p>
<br>
<p>
Let's look at this array for New York
</p>
<p>
<pre><code class="javascript">cities[0]['values'];</code></pre>
</p>
<p>
You can see that it is an array of 366 elements.
</p>
<br>
<p>
When we click into the array you can see that it is an array of 366 objects.
</p>
<p>
BROWSER - click into the array
</p>
<br>
<p>
When we click into the first object, you can see that it is an object with two key,value pairs - the key date and it's value of a JavaScript Date object and the key temperature with it's value of a numerical temperature.
</p>
<p>
BROWSER - click into first object.
</p>
<br>
<p>
When we click into the second object, you can see that it is the same as the first object, except that it is 1 day later than the first object and has a different temperature.
</p>
<p>
BROWSER - click into the second object.
</p>
<p>
So we can see how this code that assigned the cities created an array of objects for each city which inside of it has an array of objects each which has a date and a temperature.
</p>
<p>
By doing an array of objects inside of an array of objects, we can use the D3 pattern twice.
</p>
<br>
<p>
Next - define the domain of the x time scale function and then check to see what the domain is.
</p>
<p>
<pre><code class="javascript">x.domain(d3.extent(callbackData, function(d) { return d.date; }));

x.domain();</code></pre>
</p>
<p>
The domain of the x time scale function goes from October 1st 2011 to September 20th 2012.
</p>
<br>
<p>
Next - define the domain of the y linear scale function and then check to see what the domain is.
</p>
<p>
<pre><code class="javascript">y.domain([
    d3.min(cities, function(c) { return d3.min(c.values, function(v) { return v.temperature; }); }),
    d3.max(cities, function(c) { return d3.max(c.values, function(v) { return v.temperature; }); })
]);

y.domain();</code></pre>
</p>
<p>
Remember that since the data is really two levels of data, we have to use a JavaScript function to get the max and min temperatures for the city and then once we have those we have to get the max and min temperatures across all the cities.
</p>
<p>
The domain of the y linear scale function goes from 19.2 to 89.6 degrees Fahrenheit.
</p>
<br>
<p>
Next - the x-axis is created.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);</code></pre>
</p>
<br>
<p>
Next - the y-axis is created.
</p>
<p>
<pre><code class="javascript">svg.append("g")
    .attr("class", "y axis")
    .call(yAxis)
  .append("text")
    .attr("transform", "rotate(-90)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Temperature (ºF)");</code></pre>
</p>
<br>
<p>
Next - create the SVG Group Elements which the JavaScript Objects which represent the cities will be bound to.
</p>
<p>
<pre><code class="javascript">var city = svg.selectAll(".city")
    .data(cities)
  .enter().append("g")
    .attr("class", "city");</code></pre>
</p>
<br>
<p>
Let's take a look at the first SVG Group element with a class of city and see what data was bound to it.
</p>
<p>
<pre><code class="javascript">d3.select(".city").data();</code></pre>
</p>
<p>
Here you can see the city name as well as the values array of the 366 JavaScript objects.
</p>
<p>
BROWSER - click all the way into the first object
</p>
<p>
Where each of these objects has a date and a temperature.
</p>
<p>
BROWSER - Scroll all the way down.
</p>
<br>
<p>
Next, we use each SVG Group Element to generate a path based on the data bound to it.
</p>
<p>
<pre><code class="javascript">city.append("path")
    .attr("class", "line")
    .attr("d", function(d) { return line(d.values); })
    .style("stroke", function(d) { return color(d.name); })
    .style("fill","none");</code></pre>
</p>
<p>
Note that we added the last line of "style fill none" because we aren't using the CSS as defined in the web example.
</p>
<br>
<p>
The last thing we do is add the text of the city name at the end of each path line.
</p>
<p>
<pre><code class="javascript">city.append("text")
    .datum(function(d) { return {name: d.name, value: d.values[d.values.length - 1]}; })
    .attr("transform", function(d) { return "translate(" + x(d.value.date) + "," + y(d.value.temperature) + ")"; })
    .attr("x", 3)
    .attr("dy", ".35em")
    .text(function(d) { return d.name; })
    .attr("class","city_text");</code></pre>
</p>
<p>
BROWSER - move chrome tools to show city names.
</p>
<p>
You can see the city name.
</p>
<p>
We added in a class attribute that the website example does not have, so that we can take a closer look at what was bound as data to the SVG Text Elements.
</p>
<br>
<p>
The way this code works is that a JavaScript object is built right in the datum function and then bound immediately to the SVG Text Element.
</p>
<p>
Let's look at the what was actually bound.
</p>
<p>
<pre><code class="javascript">d3.select(".city_text").data();</code></pre>
</p>
<p>
You can see see that the data bound to the first city_text SVG text element was an object with two keys - name and value.
</p>
<p>
The value of the key "name" is the string "New York"
</p>
<p>
The value of the key "value" is an object that has the date and temperature.
</p>
<p>
The date is the last date of data that is present in the data imported.
</p>
<p>
This was constructed by using the Array index properties of the values array of objects to get the last element.
</p>
<p>
Using this object created anonymously and bound to the SVG Text element, it is then placed by using a transform translate based on the properly scaled inner date and temperature data.
</p>
<br>
<p>
And there we go, we have the Multi-Series Line Chart.
</p>
<br>
<p>
Let's close the Chrome Developer tools to get a better look.
</p>
<p>
BROWSER - close the Chrome Developer Tools.
</p>
<p>
BROWSER - zoom out.
</p>
<p>
You can see the full picture.
</p>
<br>
<p>
What is crucial to understand about this chart is that the data is a two dimensional array where we have data on 3 cities and for each city we have data on 366 different days.
</p>
<br>
<p>
Because the data gets processed into an Array of 366 JavaScript objects where each Object is a specific date and the temperature for three different cities, we have to change the data into a more D3 friendly format.
</p>
<p>
Because we want a line for each city, we have to reconstruct the data so that we have one JavaScript object for each city.
</p>
<p>
Then in each city, we want to have a time series of dates and temperatures on that date.
</p>
<p>
Because D3 data functionality takes in an array of JavaScript objects, we have to create a nested data set.
</p>
<p>
This data set will consist of an array of JavaScript Objects where each one represents a city.
</p>
<p>
Then inside of each object, we need a key,value pair that then references an inner array of objects where each of these inner objects is a date and a temperature.    
</p>
<p>
Once we have this array of objects with an inner array of objects inside each of them, we can bind the outside objects to SVG Group Elements and we can bind the inside objects to an SVG Path Element based on the D3 Path Generation Function.
</p>
        </div>
      </div>
    
    
    ☺</div>


<hr>
<h3 id="lesson48">Basic Chart - Pie Chart<h3>
    <div>
    
    
    </div>
    

 <hr>
<h3 id="lesson49">Basic Interaction - Data Tooltips<h3>
    <div>
    
    <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>A scatterplot chart has an X-Axis, Y-Axis, and Legend to help the user interpret the visual markings representing data</li>
<li>Sometimes, you will want to take this a step further and be able to hover over any of the points in the scatterplot chart and have a tool tip display the X and Y coordinates and potentially some more information about the particular data point</li>
<li>The Document Object Model has several different types of Event Drivers - Mouse events, Touch events, Keyboard events, HTML frame events, HTML form events, User Interface events, and many more</li>
<li>The d3.selection.on operator allows you to add an event listener to each element in the current selection</li>
<li>D3 invokes the listener in the same way it invokes other operator functions - by passing the current datum d, index i, and the "this" context for the current DOM element</li>
<li>D3 allows for the use of chain syntax to bind more than one event listener to any selection</li>
<li>Because event interactions can get complicated quickly, common practice is to use named functions rather than anonymous functions in the even listener definition</li>
<li>D3.event gives you the event properties at the time it was triggered, this includes a time stamp of when the event occurred, the horizontal coordinate, the vertical coordinate, and several other properties.</li>
<li>D3.event captures an event when it happens and stores it in the variable d3.event</li>
<li>When you define an event listener, it's worth remembering that you need a d3 selection of 'things' to bind the event listeners to</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/adding-a-dom-element">Adding a DOM Element</a></li>
<li><a href="https://www.dashingd3js.com/lessons/binding-data-to-dom-elements">Binding Data to DOM Elements</a></li>
<li><a href="https://www.dashingd3js.com/lessons/using-data-bound-to-dom-elements">Using Data Bound to DOM Elements</a></li>
<li><a href="https://www.dashingd3js.com/lessons/basic-chart-scatterplot">Basic Chart - Scatterplot</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            Basic Interaction - Data Tooltips
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
Basic Chart - Scatterplot Revisited
</strong>
</p>
<br>
<p>
[ Image: Scatterplot Example ]
</p>
<p>
We will use the TSV Data from the D3js.org website Scatterplot Example.
</p>
<br>
<p>
[ Image: Data for Scatterplot Example ]
</p>
<p>
We will save this data into a file called data.tsv
</p>
<p>
This file will be located in the folder where we will run the Python SimpleHTTPServer command.
</p>
<p>
This file is the one that will be loaded asynchronously using the D3.tsv request functionality.
</p>
<br>
<p>
[ Image: Scatterplot Example ]
</p>
<p>
What we want to be able to do is to hover over any of the points in the Scatterplot chart and have a tool tip display the x and y coordinates.
</p>
<p>
Not just the x and y coordinates, the x and y coordinates that match up to the scaled Axes.
</p>
<p>
To do this we will have to learn enough of the the very basics of DOM events, D3 selection.on and D3.events to get the tool tips to work correctly.
</p>
<br>
<br>
<p>
<strong>
Document Object Model Events
</strong>
</p>
<br>
<p>
Document Object Model Event Drivers
</p>
<p>
<ul>
<li>Mouse events</li>
<li>Touch events</li>
<li>Keyboard events</li>
<li>HTML frame/object events</li>
<li>HTML form events</li>
<li>User interface events</li>
</ul>
</p>
<p>
Document Object Model Events come many in different shapes and sizes.
</p>
<p>
They can be driven by the mouse, by a touch, by the key board and by a few other different types of specific actions.
</p>
<p>
Because various web browsers had significant differences in implementation and what events they responded to, the Document Object Model Event Model was standardized by the W3C in DOM Level 2.
</p>
<p>
For the purpose of this video, we will only look at a portion of the Mouse Events.
</p>
<br>
<p>
DOM Event Drivers - Mouse Events
</p>
<p>
<ul>
<li>click</li>
<li>double click</li>
<li>mouse down</li>
<li>mouse up</li>
<li>mouse over</li>
<li>mouse move</li>
<li>mouse out</li>
<li>context menu</li>
<li>drag</li>
<li>drag start</li>
<li>drag enter</li>
<li>drag over</li>
<li>drag leave</li>
<li>drag end</li>
<li>drag drop</li>
<li>drag gesture</li>
<li>drag over</li>
<li>select start</li>
<li>DOM Mouse Scroll</li>
</ul>
</p>
<p>
There are many DOM Mouse event Drivers that are considered Mouse Events.
</p>
<br>
<p>
DOM event Drivers - Mouse Events
</p>
<p>
<ul>
<li>click</li>
<li>double click</li>
<li>mouse down</li>
<li>mouse up</li>
<li>mouse over</li>
<li>mouse move</li>
<li>mouse out</li>
</ul>
</p>
<p>
The main ones are related to clicking and moving the mouse over something.
</p>
<p>
Because browsers can respond to these events, we can write exactly what happens when one of these events occurs.
</p>
<p>
Let's cover these main ones and how they are defined.   
</p>
<p>
A mouse click event fires when the mouse button is clicked over an element.
</p>
<p>
A click is defined as a mouse down and mouse up over the same screen location.
</p>
<p>
A mouse double click event fires when the mouse button is doubled clicked over an element.
</p>
<p>
A click is defined as a mouse down and mouse up over the same screen location.
</p>
<p>
A mouse down event fires when the mouse button is pressed over an element.
</p>
<p>
A mouse up event fires when the mouse button is released over an element.
</p>
<p>
A mouse over event fires when the mouse cursor is moved onto an element.
</p>
<p>
A mouse move event fires when the mouse cursor is moved while over an element.
</p>
<p>
A mouse out event fires when the mouse cursor moves away from an element.
</p>
<p>
To keep things simple, we will only focus on the mouse over and mouse out events.
</p>
<p>
Which in the case of the Scatterplot Chart, we want something to happen when we move the mouse over a point and when we move the mouse away from the point.
</p>
<br>
<p>
Events - now what?
</p>
<p>
Now that we know that there are DOM Events that the browser can detect, we have to define who we want to be listening to those events as well as what to do when those events happen.
</p>
<br>
<br>
<p>
<strong>
D3 selection.on
</strong>
</p>
<br>
<p>
The d3 selection dot on method adds an event listener to each element in the current selection.
</p>
<p>
<pre><code class="javascript">d3.selection.on(type[, listener[, capture]])</code></pre>
</p>
<p>
The type is a string of the event type that we want an event listener for.
</p>
<p>
Examples could be mouse down, mouse up, mouse over, mouse out, etc.
</p>
<p>
For our purposes, we will use the mouseover and mouseout as the two types.
</p>
<p>
D3 invokes the listener in the same way it invokes other operator functions - by passing the current datum d and index i and the this context as the current DOM element.
</p>
<br>
<p>
This example creates a selection of all the SVG Circle Elements.
</p>
<p>
<pre><code class="javascript">d3.selectAll("circle")
    .on("mouseover", function(d,i) { alert("mouseover"); })
    .on("mouseout",  function(d,i) { alert("mouseout");  });</code></pre>
</p>
<p>
Then using the d3 selection dot on, it adds a mouse over event listener to each SVG circle element.
</p>
<p>
When the mouse goes over one of the SVG Circle Elements, the anonymous function will be invoked.
</p>
<p>
Currently it will alert us with the string "mouseover"
</p>
<p>
Then using the d3 selection dot on, it adds a mouse out event listener to each SVG circle element.
</p>
<p>
When the mouse leaves one of the the SVG Circle Elements after having been on it, the anonymous function will be invoked.
</p>
<p>
Currently it will alert us with the string "mouseout"
</p>
<br>
<p>
As you can imagine, we can also use the index and the data object attached to each circle element.
</p>
<p>
<pre><code class="javascript">d3.selectAll("circle")
    .on("mouseover", function(d,i) { alert( d.value ); })
    .on("mouseout",  function(d,i) { alert( d.value );  });</code></pre>
</p>
<p>
In this example, if the data object had a key of "value", then this would return the value of the key,value pair.
</p>
<p>
This is very powerful, because now we have some interaction with the mouse.
</p>
<p>
This is one of the reasons that we have covered before why it's very important to leave the data unchanged when attaching it to DOM elements.
</p>
<br>
<p>
Because event interactions can get very complicated quickly with transitions and the duration of the transition, styling and other functionality, it's often easier to understand if you write named functions else where in the code that the selection.on can reference.
</p>
<p>
<pre><code class="javascript">function mouseover(d) { alert(d.value); } 

function mouseout (d) { alert(d.value); } 

d3.selectAll("circle")
    .on("mouseover", mouseover)
    .on("mouseout",  mouseout );</code></pre>
</p>
<br>
<p>
SVG DOM Element + Mouse Event + ??? = Data Tooltip
</p>
<p>
So far so good, we are able to attach an event listener to the SVG Dom Element.
</p>
<p>
We are also able to specify specific actions / calculations that must happen when the event is triggered through a JavaScript Function.
</p>
<p>
Note that this is the very basics of how this works and we are hand waving a great deal of the tricky bits away for now.
</p>
<p>
The thing we are missing is how we generate the tool tip.
</p>
<p>
To do that we have to cover the D3 dot event functionality.
        

</p>
<br>
<br>
<p>
<strong>
D3.event
</strong>
</p>
<br>
<p>
DOM Event Properties
</p>
<p>
The Document Object Model Event, when triggered, has a number of event properties that are helpful in different types of scenarios.
</p>
<p>
Some of these properties include the following:
</p>
<p>
A time stamp of when the event occurred
</p>
<p>
The horizontal coordinate of the event relative to whole document
</p>
<p>
The vertical coordinate of the event relative to the whole document 
</p>
<p>
And other properties that help answer questions like 
</p>
<p>
What is the type of the event?
</p>
<p>
Which HTML element is the target of the event?
</p>
<p>
Which key was pressed during the event?
</p>
<p>
Which mouse button was pressed during the event?
</p>
<p>
What was the mouse position during the event?
</p>
<br>
<p>
D3 captures an event when it happens and stores it in the variable d3.event.
</p>
<p>
<pre><code class="javascript">d3.event</code></pre>
</p>
<p>
This is a global variable that can be used in the event listener callback function registered with the d3 selection dot on operator.
</p>
<p>
After the JavaScript callback function has finished running, the current d3.event is reset.
</p>
<br>
<p>
The reason we want to capture the current event is that we can extract the X and Y coordinates of the event.
</p>
<p>
<pre><code class="javascript">d3.event.pageX

d3.event.pageY</code></pre>
</p>
<p>
These X and Y coordinates are where the event happened, which means it is where the mouse currently is.
</p>
<p>
This is useful when we are making a tool tip to show the data of a specific element.
</p>
<p>
When the event happens, we can use the X and Y coordinates to create the tool tip in that specific location.
</p>
<p>
So far so good, the last thing we want to cover is how we can make an element on the HTML page appear and disappear.
</p>
<p>
This is so that the element will appear with the relevant data when we mouse over a point and then disappear when the mouse moves out.
</p>
<br>
<br>
<p>
<strong>
Putting It All Together
</strong>
</p>
<br>
<p>
If we run the above two commands in order, the first command will color all of the SVG Circle Elements a Red Color.
</p>
<p>
<pre><code class="javascript">d3.selectAll("circle").style("fill","red");

d3.selectAll("circle").style("fill","blue");</code></pre>
</p>
<p>
The second command will then color all of the SVG Circle Elements a Blue Color.
</p>
<br>
<p>
To make an element appear and disappear from the screen we can use the opacity CSS property.
</p>
<p>
<pre><code class="javascript">// opacity CSS property</code></pre>
</p>
<p>
When the opacity property is set to 1 the element is visible.
</p>
<p>
As the opacity property goes to 0, the element will become invisible.
</p>
<br>
<p>
Using the mouseover and mouseout functions the event listener uses, we can change the style of the element to hide it using the opacity CSS property.
</p>
<p>
<pre><code class="javascript">function mouseover(d) { selection.style("opacity", 1); } 

function mouseout(d)  { selection.style("opacity", 0); }</code></pre>
</p>
<br>
<p>
The next thing we want to do is to define an HTML Div element that we can position absolutely.
</p>
<p>
<pre><code class="javascript">var div = d3.select("body").append("div")   
    .style("position", "absolute")
    .style("text-align", "center")
    .style("width", "240px")
    .style("height", "2.5em")
    .style("font", "1.5em sans-serif")
    .style("color","yellow")
    .style("background", "black")
    .style("border-radius", "8px")
    .style("border", "solid 1px green")
    .style("opacity", 0);</code></pre>
</p>
<p>
When you specify position:absolute, the element is placed exactly where you tell it to go in the HTML Document.
</p>
<p>
So we can use the d3.event.pageX and d3.event.pageY to place this HTML div element exactly over the circle when we hover over it.
</p>
<p>
This styling is taken and slightly modified from the HTML Overlay with pageX / pageY D3js.org Website Example.
</p>
<br>
<p>
We use div.html rather than div.text so that we can add an html line break into the string that we pass into it.   
</p>
<p>
<pre><code class="javascript">function mouseover(d) {
    div.html("Sepal Width: " + d.sepalWidth + "<br />" + "Sepal Length: " + d.sepalLength)
    .style("left", (d3.event.pageX + 9) + "px")
    .style("top",  (d3.event.pageY - 43) + "px")
    .style("opacity", 1);
}

function mouseout() {
    div.style("opacity", 1e-6);
}

d3.selectAll(".dot")
    .on("mouseover", mouseover)
    .on("mouseout", mouseout);</code></pre>
</p>
<p>
Lastly, we define the mouse over and mouse out functions to change the opacity as well as the location based on the d3.event pageX and pageY coordinates.
</p>
<p>
In the case of the Scatterplot, we'll select all the circles with a class of ".dot" and add the d3 selection.on mouse over and mouse out event listeners as well as specify what functions should be run when the events are triggered.
</p>
<br>
<br>
<p>
<strong>
JavaScript Console Walk Through
</strong>
</p>
<br>
<p>
After downloading the data to a data.tsv file from the Scatter Plot Example, starting the Python SimpleHTTPServer and making sure D3 is loaded, we open the Chrome Developer Tools and go step by step building the visualization.
</p>
<br>
<p>
Because we are interested in adding event listeners and their functions, we don't need to run the D3 TSV request separately.
</p>
<br>
<p>
We copy and paste all the code from the D3js.org Scatterplot Website Example.
</p>
<p>
BROWSER HIGHLIGHT Copy / Paste into the JavaScript Console.
</p>
<p>
You can see that it generates the graph correctly because we have the Python SimpleHTTPServer serving the data correctly for the D3.tsv request.
</p>
<br>
<p>
First, let's define the HTML DIV that is going to serve as the tooltip that appears and disappears when a circle is moused over.
</p>
<p>
<pre><code class="javascript">var div = d3.select("body").append("div")   
    .style("position", "absolute")
    .style("text-align", "center")
    .style("width", "240px")
    .style("height", "2.5em")
    .style("font", "1.5em sans-serif")
    .style("color","yellow")
    .style("background", "black")
    .style("border-radius", "8px")
    .style("border", "solid 1px green")
    .style("opacity", 0);</code></pre>
</p>
<p>
BROWSER - Click into the DOM Elements section and click on the DIV.
</p>
<p>
You can see that the div was appended as the last child element in the Body section.
</p>
<p>
The opacity is zero and when we hover over it, it shows up beneath the SVG Container in the HTML section of the Browser.
</p>
<p>
This is because we haven't defined the coordinates of where it should live.
</p>
<br>
<p>
Next, let's define the mouseover function.
</p>
<p>
<pre><code class="javascript">function mouseover(d) {
    div.html("Sepal Width: " + d.sepalWidth + "<br />" + "Sepal Length: " + d.sepalLength)
    .style("left", (d3.event.pageX + 9) + "px")
    .style("top",  (d3.event.pageY - 43) + "px")
    .style("opacity", 1);
}</code></pre>
</p>
<p>
The style of left and top will be updated with the relevant d3.event pageX and pageY coordinates every time a new DOM mouseover event occurs on the circles.
</p>
<p>
Note that the sepalWidth and sepalLength properties are not scaled.
</p>
<p>
The reason they are not scaled is because the axis and the circle dots have been scaled to both match the input data.
</p>
<p>
So the input data does not need to be scaled.
</p>
<br>
<p>
Next, let's define the mouseout function
</p>
<p>
<pre><code class="javascript">function mouseout() {
    div.style("opacity", 1e-6);
}</code></pre>
</p>
<p>
The only thing this function does is to make the opacity CSS property zero.
</p>
<p>
This hides the tool tip while not removing the html DIV from the page.
</p>
<p>
This is helpful because we are not generating a new DIV for every interaction, we are only moving the HTML Div and making it visible or invisible.
</p>
<br>
<p>
Finally, we select all the circles with class of dot and add two event listeners.
</p>
<p>
<pre><code class="javascript">d3.selectAll(".dot")
    .on("mouseover", mouseover)
    .on("mouseout", mouseout);</code></pre>
</p>
<p>
By using the D3.selectAll dot, we are able to add the event listeners to every single DOM element with the class of .dot.
</p>
<p>
You can see the power that the d3 selection.on gives us because we can add all different types of listeners based on the D3 selections that we make.
</p>
<p>
When we enter the command, it returns an array of 150 elements, so we know that all 150 dots now have event listeners attached to them.
</p>
<br>
<p>
And with that, the Scatterplot now has some interactivity.
</p>
<br>
<p>
Let's close the Chrome Developer tools to get a better look.
</p>
<p>
BROWSER - close the Chrome Developer Tools.
</p>
<p>
BROWSER - zoom out.
</p>
<p>
You can see the full picture.
</p>
<br>
<p>
The crucial thing to understand about the Basic Interaction - Data Tooltips for the Scatterplot chart is that anytime you move your mouse anywhere on a webpage on a web browser, you are triggering tons of events.
</p>
<p>
If there are no event listeners attached to any DOM elements, then the events fall on deaf ears.
</p>
<p>
If there are event listeners attached to DOM elements, then they will run the code they are supposed to run when events are triggered.
</p>
<br>
<p>
D3 provides a very easy way to add event listeners to DOM elements in selections as well as specify what functions should be run when these events are triggered.
</p>
<br>
<p>
Though we have barely scratched the surface of the DOM Events, D3 event bindings and what events can happen - the basics of what we learned here are applicable in the more intermediate and advanced data visualizations constructed with D3.
</p>
        </div>
      </div>

</div>
<hr>
<h3 id="lesson50">D3 Transition Basics<h3>
    <div>
        
 <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>D3 Transitions take a selection of elements and for each element it applies a transition to a part of the current definition of the element</li>
<li>The D3 Transition method is used to animate the transition of a DOM element from a current state to an end state</li>
<li>The d3.selection.transition method allows you to define what properties are changed, how the properties change, the duration of time it takes for the transition to occur, when the transition starts after it is triggered, and what the end state will look like</li>
<li>D3 Transitions are constructed as key-frame animations
<li>D3 Transitions allow you to use pre-defined 'tweening as well as use your own definitions
<li>To use the d3.selection.transition method in a useful manner, the values that are changed must be interpolatable
<li>A D3 Transition has a life-cycle that consists of "transition scheduled", "transition start", "transition running", and "transition end"
<li>D3 Transitions can use JavaScript and D3 functions to specify how all of the definitional parts are defined for each DOM element using the "d" for data, the "i" for index, and the "this" for each specific element</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/introduction-to-html">Introduction to HTML</a></li>
<li><a href="https://www.dashingd3js.com/lessons/introduction-to-css">Introduction to CSS</a></li>
<li><a href="https://www.dashingd3js.com/lessons/javascript-functions">JavaScript Functions</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 Transition Basics
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
D3 Transition Motivating Example
</strong>
</p>
<br>
<p>
Let's start with some motivating examples.
</p>
<br>
<p>
As you can see, these videos use the Chrome web browser and chrome developer tools.
</p>
<br>
<p>
This is a static file that lives in a folder on the desktop of my computer.
</p>
<br>
<p>
It is not being hosted on a server because we do not need a server yet.
</p>
<br>
<p>
Alright - so you can see the elements in the top window
</p>
<p>
We have the HTML doctype, character set, the script using the D3.js library hosted at the d3js.org website and an empty HTML body.
</p>
<p>
We also have open the JavaScript Console.
</p>
<br>
<p>
To start, let's create 5 paragraph elements that say hello and tell us their internal data.
</p>
<p>
<pre><code class="javascript">d3.select("body").selectAll("p").data([5,4,3,2,1]).enter().append("p").text(function(d,i) { return " Hello - " + d; });</code></pre>
</p>
<p>
BROWSER Open the Body Element in the ELEMENTS Section of the Chrome Browser Web Tools
</p>
<p>
We use D3 to select all the non-existent paragraph elements.
</p>
<p>
Then we pass an array of numbers to the data operator.
</p>
<p>
Then we select the enter selection.
</p>
<p>
Then we append paragraph elements to the enter selection thus merging the placeholder elements to create paragraphs.
</p>
<p>
Lastly, we use an anonymous function inside of the text operator to return the string "Hello" plus the data element for that particular paragraph element.
</p>
<p>
You can see the 5 paragraph elements.
</p>
<br>
<p>
Now that we have our 5 paragraph elements, let's do a simple transition.
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").transition().style("color","green");</code></pre>
</p>
<p>
On the screen you should have seen the paragraph text go from black to green.
</p>
<p>
In the window that shows the HTML elements you should have also seen the HTML paragraph tags change.
</p>
<p>
This command added a style attribute and value to each HTML paragraph tag.
</p>
<p>
Each HTML paragraph tag now has a style="color..." attribute, value pair.
</p>
<br>
<p>
Let's try it again and this time go from green to blue.
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").transition().style("color","blue");</code></pre>
</p>
<p>
The text inside of each HTML paragraph tag now went from green to blue.
</p>
<br>
<p>
This is the most basic example of a transition.
</p>
<p>
D3 takes a selection of elements and for each element it applies a transition to a part of the current definition of the element.
</p>
<p>
This transition creates an animation that shows what changes happened from the previous state to the new defined state.
</p>
<br>
<p>
Let's now take a look at the basics of what a transition is and how it works.
</p>
<br>
<br>
<p>
<strong>
D3 Transitions are Animations
</strong>
</p>
<br>
<p>
The D3 transition method is used to animate the transition of a DOM element from a current state to an end state.
</p>
<p>
<pre><code class="javascript">d3.selection.transition</code></pre>
</p>
<br>
<p>
The D3 transition method allows property changes to occur smoothly over a specified duration rather than instantaneously.
</p>
<p>
It is this smooth transition of properties over a specified period of time that creates the look and feel of an animation.
</p>
<br>
<p>
Breaking down the sentence of what a D3 transition is, we can see four main areas to explore.
</p>
<p>
<pre><code class="javascript">d3.selection.transition</code></pre>
</p>
<p>
<ol>
<li>property change</li>
<li>occur smoothly</li>
<li>over a specified duration</li>
<li>from start start to end state</li>
</ol>
</p>
<p>
What properties can be changed
</p>
<p>
How do the properties change smoothly
</p>
<p>
How do we specify a duration
</p>
<p>
and How can we specify the start and end state.
</p>
<br>
<p>
[ Image : Screenshot of what changed ]
</p>
<p>
When we look at a Screenshot of the example we saw earlier, we can talk about the four areas:
</p>
<p>
The property that changes is the color of the text.
</p>
<p>
How did the color change?
</p>
<p>
It was smooth and we didn't really notice it.
</p>
<p>
The duration was long enough that we saw it change though not so long that it didn't seem to take long.
</p>
<p>
The starting state was the color black while the ending state was the color green.
</p>
<p>
The second time we did a transition the starting color was green while the ending state was the color blue.
</p>
<br>
<p>
[ Image: Animated Example Of Ball Bouncing ]
</p>
<p>
Wikipedia has this image as an example of what Animation is.
</p>
<p>
Here we see six frames of a ball bouncing on a green surface.
</p>
<p>
If we were to cycle through the frames at 10 frames per second, the ball would look like it was in motion.
</p>
<p>
It is this rapid display of a sequence of images that creates an illusion of movement.
</p>
<p>
Done correctly, the animation is not jarring and it looks like natural movement.
</p>
<br>
<p>
Transitions in D3 are constructed as a key frame animation.
</p>
<p>
<pre><code class="javascript">d3.selection.transition</code></pre>
</p>
<p>
<ul>
<li>start state</li>
<li>'tweening</li>
<li>end state</li>
</ul>
</p>
<p>
A key frame animation is a type of animation where only the starting and end points are defined.
</p>
<p>
The frames in between the starting and end points are generated by the software to be a smooth transition.
</p>
<p>
This is called 'tweening taken from "inbetween"
</p>
<p>
In D3, unless otherwise specified the start state is the current state of the DOM Element.
</p>
<p>
In the motivating example, the start state of the text was the color black.
</p>
<p>
The end state was the color green.
</p>
<p>
The second time we ran the transition the start state was the current state of the DOM Element, which was green.
</p>
<p>
The end state was the color blue.
</p>
<br>
<p>
D3 created a smooth animation where the color transitioned from black to green.
</p>
<p>
<pre><code class="javascript">// Black = #000000 = rgb(0,   0,   0) 
// Green = #008000 = rgb(0, 128,   0) 
// Blue  = #0000FF = rgb(0,   0, 255)</code></pre>
</p>
<p>
Then we created another smooth animation where the color transitioned from green to blue.
</p>
<p>
In HTML we can define the colors of DOM elements using CSS properties.
</p>
<p>
We can define colors using English language words like Black, Green and Blue.
</p>
<p>
Or we can define colors using their Hexadecimal code.
</p>
<p>
Or we can define colors in a RGB Color Model.
</p>
<p>
The RGB Color Model is an additive color model in which Red, Green and Blue lights are added together in various ways to reproduce a color.
</p>
<p>
The RGB Model is named after the colors, Red, Green and Blue. 
</p>
<p>
The D3 transition smoothly created "inbetween" frames from the starting frame of the black to the ending frame of the blue.
</p>
<p>
This made the animation look natural and not jarring.
</p>
<p>
To make this animation go smoothly, D3 had to do a value interpolation over time from one color to the other.
</p>
<p>
We cover this in the next section.
</p>
<br>
<br>
<p>
<strong>
Value Interpolation Over Time.
</strong>
</p>
<br>
<p>
Let's go back to our example and slow down time.
</p>
<br>
<p>
First, let's look at the 5 paragraphs elements
</p>
<p>
BROWSER Look at the elements the first paragraph
</p>
<p>
Each paragraph has an attribute called style and a value called color semicolon and the RGB code for the color blue.
</p>
<p>
The first number is for the color red and it is zero.
</p>
<p>
The second number is for the color green and it is zero.
</p>
<p>
The third number is for the color blue and it is 255.
</p>
<br>
<p>
When we tell D3 to make a transition to change the style of the elements to a color of red, we should expect the first number to go to 255 and the last number to go to 0.
</p>
<br>
<p>
Ignoring for now the duration command and how it works, let's take a look what happens when we tell D3 to make the transition take 10 seconds.
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").transition().style("color","red").duration(10000);</code></pre>
</p>
<p>
You can see that slowly the third number (the blue number) goes to zero.
</p>
<p>
You can see that slowly the first number (the red number) goes to 255.
</p>
<br>
<p>
Let's try this again this time changing the color to black.
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").transition().style("color","black").duration(10000);</code></pre>
</p>
<p>
The color black in the RGB Color Model is 0 comma 0 comma 0.
</p>
<p>
So in this instance, we see the first number (the red number) go from 255 to 0.
</p>
<p>
It did it smoothly and evenly.
</p>
<br>
<p>
Let's do it one last time, this time specifying the color directly in the RGB code.
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").transition().style("color","rgb(128,128,128)").duration(10000);</code></pre>
</p>
<p>
As you can see, this works the same way.
</p>
<p>
Each color number slowly, smoothly and evenly went from 0 to 128.
</p>
<p>
As you can imagine, this points to D3 using some type of interpolator method to accurately figure out how to get from 0 to 128 in the span of 10 seconds.
</p>
<br>
<p>
To get the accurate blending of in-between frames from the start frame value to the end frame value, D3 uses an internal interpolator.
</p>
<p>
<pre><code class="javascript">d3.interpolate(a, b)</code></pre>
</p>
<p>
<ul>
<li>interpolateNumber</li>
<li>interpolateRgb</li>
<li>interpolateString</li>
</ul>
</p>
<p>
Depending on what type of values a and b are, the d3.interpolate method uses different interpolator functions.
</p>
<p>
If b is a number, a is coerced to a number and the interpolateNumber function is used.
</p>
<p>
If b is a color, a is coerced to an RGB color and the interpolateRgb function is used.
</p>
<p>
If b is a string, a check is made to see if it's a CSS named color, otherwise the interpolateString function is used.
</p>
<br>
<p>
When working with transitions, it is important to think about whether you can interpolate from the start frame to the end frame.
</p>
<p>
<pre><code class="javascript">d3.interpolate(a,b)</code></pre>
</p>
<p>
can you actually interpolate it?
</p>
<p>
For instance, you cannot interpolate the creation or destruction of an element.
</p>
<p>
You can certainly make it too small to see or change the color to match the background, however, the element must already exist.
</p>
<br>
<p>
With the earlier example we saw the transition of colors and by way of the RGB Color Mode, the transition of numbers.
</p>
<p>
<pre><code class="javascript">d3.interpolate(a,b)
// numbers
// colors
// geometrics transforms
// strings with embedded numbers</code></pre>
</p>
<p>
D3 also has geometric transforms based on the transform translate attribute that can be applied to SVG elements.
</p>
<p>
The last common transition you'll see is that of strings with embedded numbers.
</p>
<br>
<p>
A common example of an embedded number in a string is that of font-size.
</p>
<p>
<pre><code class="html">style="font-size:12px;"</code></pre>
</p>
<p>
This could also apply to the stroke width of SVG lines or paths generated by D3.
</p>
<p>
D3 is sophisticated enough to be able to figure out what is the number part of the string and do an interpolation.
</p>
<p>
Let's take a look at two examples in the JavaScript console.
</p>
<br>
<p>
Let's go back to our example and in slow motion change the font size.
</p>
<br>
<p>
First, notice that the style does not currently include a font.
</p>
<br>
<p>
D3 figures this out for us through the use of CSS slash DOM getComputerStyle or getAttribute.
</p>
<br>
<p>
Alright, let's transition the paragraph font-size from what it currently is to 6px over 10 seconds.
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").transition().style("font-size","6px").duration(10000);</code></pre>
</p>
<p>
Note that as soon as we pressed enter, the font-size style appeared in the HTML paragraph tags.
</p>
<p>
Then the number started decreasing from 12 pixels to 6 pixels.
</p>
<p>
Also note that when we typed in the command, we typed in 6 p x as a string.
</p>
<p>
D3 was sophisticated enough to figure out what part was the number and do an interpolation on that part.
</p>
<br>
<p>
Let's bring back the font-size without specifying a duration.
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").transition().style("font-size","12px");</code></pre>
</p>
<p>
In this case, you saw a flash of numbers as the interpolation happened quickly.
</p>
<p>
Just how quickly, we'll cover later in the Transition Duration section.
</p>
<br>
<p>
Now that that we have a better understanding of how a D3 transition is an animation of interpolate-able values between key-frames, let's take a look at the different stages of transitions.
</p>
<br>
<br>
<p>
<strong>
Stages of Transition
</strong>
</p>
<br>
<p>
The life cycle of a D3 transition is broken down into four separate phases.
</p>
<p>
<pre><code class="javascript">d3.selection.transition
// Transition Scheduled
// Transition Starts
// Transition Runs
// Transition Ends</code></pre>
</p>
<p>
Because transitions happen over time, there is a sequence of recurring callbacks.
</p>
<p>
Each phase starts when the previous phase has ended.
</p>
<p>
This is very important to pay attention to when running multiple transitions on one element
</p>
<p>
or one transition on multiple elements
</p>
<p>
or multiple transitions on multiple elements.
</p>
<br>
<p>
Mike Bostock shares a useful mnemonic in that transitions are conceived, are born, live and then die.
</p>
<p>
<pre><code class="javascript">d3.selection.transition
// Transition Scheduled : conceived
// Transition Starts : born
// Transition Runs : lives
// Transition Ends : dies</code></pre>
</p>
<br>
<p>
A transition is scheduled when it is created by the code running.
</p>
<p>
<pre><code class="javascript">d3.selection.transition
// Transition Scheduled : conceived
// Transition Starts : born  ** GRAYED OUT **
// Transition Runs : lives   ** GRAYED OUT **
// Transition Ends : dies    ** GRAYED OUT **</code></pre>
</p>
<p>
To schedule a transition, the element to which the transition is applied must exist.
</p>
<p>
In D3 version 3.0 and above, the definition of the ending key frame occurs when the transition is scheduled.
</p>
<p>
This can be the style, the attribute or the other transition methods available.
</p>
<p>
In our case, when we defined the new font-size or new color, we were scheduling and defining the transition as soon as we pressed enter in the JavaScript console.
</p>
<br>
<p>
Transitions starts when they are scheduled.
</p>
<p>
<pre><code class="javascript">d3.selection.transition
// Transition Scheduled : conceived ** GRAYED OUT **
// Transition Starts : born  
// Transition Runs : lives   ** GRAYED OUT **
// Transition Ends : dies    ** GRAYED OUT **</code></pre>
</p>
<p>
If a delay has been specified and defined, then they will start after the delay in milliseconds has occurred.
</p>
<p>
Otherwise, if no delay has been specified and defined, then the transition will start immediately.
</p>
<p>
When the transition starts, the start event is dispatched.
</p>
<br>
<p>
When the start event is dispatched the transition starts to generate in-between frames.
</p>
<p>
<pre><code class="javascript">d3.selection.transition
// Transition Scheduled : conceived ** GRAYED OUT **
// Transition Starts : born  ** GRAYED OUT **
// Transition Runs : lives   
// Transition Ends : dies    ** GRAYED OUT **</code></pre>
</p>
<p>
These frames are generated until the transition ends.
</p>
<p>
The way the frames are drawn on the screen is controlled by the easing control timing.
</p>
<p>
The default easing function D3 uses is "cubic-in-out"
</p>
<p>
This specific type of easing functions has a slow start and end and then does a cubic-bezier interpolation function in between.
</p>
<p>
So while the interpolation is linear, the time steps are controlled by the easing function to make the transition look better.
</p>
<p>
Which makes it look like time slows down at the start and end of the transition and runs at normal speed during the life of the transition.
</p>
<br>
<p>
When the transition has covered its duration and delayed start time, the transition ends.
</p>
<p>
<pre><code class="javascript">d3.selection.transition
// Transition Scheduled : conceived ** GRAYED OUT **
// Transition Starts : born  ** GRAYED OUT **
// Transition Runs : lives   ** GRAYED OUT **
// Transition Ends : dies</code></pre>
</p>
<p>
A final frame is invoked and then the end event is dispatched.
</p>
<p>
The end key frame value is set exactly when the Transition Ends.
</p>
<br>
<p>
Now that we know the life cycle of how the D3 transition works and behaves, let's next take a look at how to actually change the scheduled start time of the transition and how to change the duration of the transition.
</p>
<p>
<pre><code class="javascript">d3.selection.transition
// Transition Scheduled : conceived
// Transition Starts : born  
// Transition Runs : lives
// Transition Ends : dies </code></pre>
</p>
<br>
<br>
<p>
<strong>
Delaying Transition Start
</strong>
</p>
<br>
<p>
As we covered before, the transition will start after the delay is run.
</p>
<p>
<pre><code class="javascript">d3.selection.transition
// Transition Scheduled
// Transition Starts ** Highlight **
// Transition Runs
// Transition Ends</code></pre>
</p>
<p>
If there is no delay, then the transition will start immediately.
</p>
<p>
Otherwise, if there is a delay, then the transition starts when the delay is over.
</p>
<br>
<p>
The transition delay is calculated in milliseconds.
</p>
<p>
<pre><code class="javascript">d3.selection.transition.delay(delay)
// delay = constant
// delay = function</code></pre>
</p>
<p>
The transition delay can be a constant value or it can be a function.
</p>
<br>
<p>
If the delay is a constant value, then all the elements within the selection are given the same delay.
</p>
<p>
<pre><code class="javascript">d3.selection.transition.delay(delay)
// delay = constant ** HIGHLIGHT **
// delay = function</code></pre>
</p>
<p>
The transition will then start for all the elements at the same time.
</p>
<br>
<p>
If the delay is a function, depending on the function, different elements within the selection will be given different delays.
</p>
<p>
<pre><code class="javascript">d3.selection.transition.delay(delay)
// delay = constant 
// delay = function ** HIGHLIGHT **</code></pre>
</p>
<p>
The transition will then start at different times for different elements.
</p>
<br>
<p>
This is the first example we are going to run in the JavaScript Console.
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").transition().delay(2000).style("font-size","8px");</code></pre>
</p>
<p>
Note that in milliseconds, two thousand is 2 seconds.
</p>
<p>
Here we will change the font size of the paragraph elements to be 8 pixels.
</p>
<p>
The transition will occur for all the paragraph elements in the selection at the same time because the delay is a constant value.
</p>
<br>
<p>
This is the second example we are going to run in the JavaScript Console.
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").transition().style("font-size","17px").delay(function(d,i){
    if (i % 2 === 0) {
        return 2000;
    } else {
        return 4000;
    }
});</code></pre>
</p>
<p>
The first thing to notice is that we can define the delay of the transition after defining the end frame.
</p>
<p>
It works perfectly either way.
</p>
<p>
The second thing to notice is that we are going to use an anonymous JavaScript function to given different elements different delays.
</p>
<p>
Within the delay method, if we have a function, then the d for the current element datum, the i for the current index and the "this" context are all passed to it.
</p>
<p>
Which means that in this instances we are going to set different delays to each element based on whether the index of the element is even or odd.
</p>
<p>
If the element index is even, then it will be delayed 2 seconds before it starts it's transition.
</p>
<p>
If the element index is odd, then it will be delayed 4 seconds before it starts it's transition.
</p>
<p>
It's worth remembering that D3 selections are 0-indexed.
</p>
<br>
<p>
This is the third example we are going to run in the JavaScript Console.
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").transition().style("font-size","7px").delay(function(d,i){
    return d * 1000;
});</code></pre>
</p>
<p>
In the previous example, we used the index of the current DOM element.
</p>
<p>
This time we are going to use the data attached to the current DOM element to specify how long the delay will be.
</p>
<p>
If you recall, the data attached to the elements were the numbers 5, 4, 3, 2 and 1.
</p>
<p>
So the last element will transition after 1 second,
</p>
<p>
the second to last element will transition after 2 seconds, 
</p>
<p>
and so on and so forth until the first element transitions after 5 seconds.
</p>
<br>
<p>
Alright - let's go to the JavaScript console to test out the transition delays.
</p>
<br>
<p>
We continue with our examples where we left off.
</p>
<br>
<p>
First, let's run the transition delay example where all the elements transition after 2 seconds.
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").transition().delay(2000).style("font-size","8px");</code></pre>
</p>
<p>
Notice that nothing happened for 2 seconds and then all the elements transitions at the same time.
</p>
<br>
<p>
Next, let's run the transition delay example where the elements transition after 2 seconds or 4 seconds depending on whether their selection index is even or odd.
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").transition().style("font-size","17px").delay(function(d,i){
    if (i % 2 === 0) {
        return 2000;
    } else {
        return 4000;
    }
});</code></pre>
</p>
<p>
As we just spoke about, D3 selections are 0-indexed.
</p>
<p>
Which means that the first element - the paragraph "Hello - 5" has an index of 0.
</p>
<p>
0 modulus two in JavaScript is zero, so that's why three elements transitioned after 2 seconds.
</p>
<p>
DOM Elements with the index of 2 and 4 then transitioned after 4 seconds.
</p>
<br>
<p>
Finally, let's run the the transition delay example where the elements transition based on the data attached to the DOM elements.
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").transition().style("font-size","7px").delay(function(d,i){ return d * 1000;});</code></pre>
</p>
<p>
The D3 API calls this a "data driven animation"
</p>
<br>
<p>
If we take a look at the data that is encapsulated in the d3.selectAll("p") selection
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").data();</code></pre>
</p>
<p>
We can see that the data is 5, 4, 3, 2 and 1.
</p>
<p>
Which as we covered earlier meant that the last element was going to wait 1 second to transition while the 1st element was going to take 5 seconds to transition.
</p>
<br>
<p>
Now that we have looked at how to delay the transition, let's next look at how to change the duration of the transition.
</p>
<br>
<br>
<p>
<strong>
Modifying Transition Duration
</strong>
</p>
<br>
<p>
The transition runs according to the duration specified.
</p>
<p>
<pre><code class="javascript">d3.selection.transition
// Transition Scheduled
// Transition Starts
// Transition Runs   ** Highlight **
// Transition Ends</code></pre>
</p>
<p>
The D3 transition default duration is 250ms.
</p>
<p>
If no duration is specified, then the default duration is used.
</p>
<br>
<p>
The transition duration is calculated in milliseconds.
</p>
<p>
<pre><code class="javascript">d3.selection.transition.duration(duration)
// duration = constant
// duration = function</code></pre>
</p>
<p>
The transition can be a constant value or it can be a function.
</p>
<br>
<p>
If the duration is a constant value, then all of the elements within the selection are given the same duration.
</p>
<p>
<pre><code class="javascript">d3.selection.transition.duration(duration)
// duration = constant ** HIGHLIGHT **
// duration = function</code></pre>
</p>
<p>
The transition will take the same amount of time for all the elements.
</p>
<br>
<p>
If the duration is a function, depending on the function, different elements within the selection will be given different duration times.
</p>
<p>
<pre><code class="javascript">d3.selection.transition.duration(duration)
// duration = constant 
// duration = function ** HIGHLIGHT **</code></pre>
</p>
<p>
The transition will then end at different times for different elements.
</p>
<br>
<p>
This is the first example we are going to run in the JavaScript Console.
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").transition().duration(2000).style("font-size","8px");</code></pre>
</p>
<p>
Note that in milliseconds, two thousand is 2 seconds.
</p>
<p>
Here we will change the font size of the paragraph elements to the 8 pixels.
</p>
<p>
The duration of the transition will be 2 seconds for all the paragraph elements in the selection because the duration is a constant value.
</p>
<br>
<p>
This is the second example we are going to run in the JavaScript Console.
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").transition().style("font-size","17px").duration(function(d,i){
    if (i % 2 === 0) {
       return 2000;
    } else {
       return 4000;
    }
});</code></pre>
</p>
<p>
The first thing to notice is that we can define the duration of the transition after defining the end frame.
</p>
<p>
It works perfectly either way.
</p>
<p>
The second thing to notice is that we are going to use an anonymous JavaScript function to given different elements different durations.
</p>
<p>
Within the duration method, if we have a function, then the d for the current element datum, the i for the current index and the "this" context are all passed to it.
</p>
<p>
Which means that in this instances we are going to set different durations for each element based on whether the index of the element is even or odd.
</p>
<p>
If the element index is even, then the transition will take a duration of 2 seconds.
</p>
<p>
If the element index is odd, then the transition will take a duration of 4 seconds.
</p>
<p>
It's worth remembering that D3 selections are 0-indexed.
</p>
<br>
<p>
This is the third example we are going to run in the JavaScript Console.
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").transition().style("font-size","7px").duration(function(d,i){
    return d * 1000;
});</code></pre>
</p>
<p>
In the previous example, we used the index of the current DOM element.
</p>
<p>
This time we are going to use the data attached to the current DOM element to specify how long the transition duration will be.
</p>
<p>
If you recall, the data attached to the elements were the numbers 5, 4, 3, 2 and 1.
</p>
<p>
So the last element will have a duration of 1 second,
</p>
<p>
the second to last element will have a duration of 2 seconds, 
</p>
<p>
and so on and so forth until the first element has a duration of 5 seconds.
</p>
<p>
Alright - let's go to the JavaScript console to test out the transition durations.
</p>
<br>
<p>
We continue with our examples where we left off.
</p>
<br>
<p>
First, let's run the transition duration example where all of the elements transitions have a duration of 2 seconds.
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").transition().duration(2000).style("font-size","8px");</code></pre>
</p>
<p>
Notice that the duration for the transition took 2 seconds for all of the elements.
</p>
<br>
<p>
Next, let's run the transition duration example where the element's transition duration is either 2 seconds or 4 seconds depending on whether their selection index is odd or even.
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").transition().style("font-size","17px").duration(function(d,i){
    if (i % 2 === 0) {
        return 2000;
    } else {
        return 4000;
    }
});</code></pre>
</p>
<p>
As we just spoke about, D3 selections are 0-indexed.
</p>
<p>
Which means that the first element - the paragraph "Hello - 5" has an index of 0.
</p>
<p>
0 modulus two in JavaScript is zero, so that's why three elements had a transition duration of 2 seconds.
</p>
<p>
DOM Elements with the index of 2 and 4 had a transition duration of 4 seconds.
</p>
<br>
<p>
Finally, let's run the the transition duration example where the elements transition duration is based on the data attached to the DOM elements.
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").transition().style("font-size","7px").duration(function(d,i){ return d * 1000; });</code></pre>
</p>
<p>
The D3 API calls this a "data driven animation"
</p>
<br>
<p>
If we take a look at the data that is encapsulated in the d3.selectAll("p") selection
</p>
<p>
<pre><code class="javascript">d3.selectAll("p").data();</code></pre>
</p>
<p>
We can see that the data is 5, 4, 3, 2 and 1.
</p>
<p>
Which as we covered earlier meant that the last element was going to have a transition duration of 1 second while the 1st element was going to take 5 seconds to do the full transition.
</p>
<br>
<p>
And with that we have covered how D3 transitions work, as well as basic examples and functionality.
</p>
        </div>
      </div>        
        
        
        
        
    </div>

<hr>
<h3 id="lesson51">D3 SVG Transition Animations<h3>
    <div>
         <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>SVG Basic Shapes are Rectangle, Circle, Ellipse, Straight Line, Polyline, Polygon, and Path</li>
<li>D3 allows for animation of SVG Basic Shape properties like shape, location / position, and appearance</li>
<li>D3 Transitions can be delayed by a specified amount of time</li>
<li>D3 Transitions can have a specific duration defined</li>
<li>The D3 Transition delay and duration can be given a constant or a function that returns the specific value for each element</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/introduction-to-css">Introduction to CSS</a></li>
<li><a href="https://www.dashingd3js.com/lessons/fundamentals-of-svg">Fundamentals of SVG</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-and-svg-basic-shapes">D3 and SVG Basic Shapes</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-transition-basics">D3 Transition Basics</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 SVG Transition Animations
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
D3 and SVG Basic Shapes Revisited
</strong>
</p>
<br>
<p>
SVG Basic Shapes
</p>
<p>
<ul>
<li>Rectangle</li>
<li>Circle</li>
<li>Ellipse</li>
<li>Straight Line</li>
<li>Polyline</li>
<li>Polygon</li>
<li>Path</li>
</ul>
</p>
<p>
The basic shapes that SVG provides are
</p>
<p>
the rectangle
</p>
<p>
the circle
</p>
<p>
the ellipse
</p>
<p>
the straight line
</p>
<p>
and the polyline, polygon and path.
</p>
<p>
For this video, we will ignore the polyline, polygon and path for now.
</p>
<br>
<p>
An SVG Rectangle
</p>
<p>
<pre><code class="html">&lt;svg&gt;
    &lt;rect x="0" y="0" width="5" height="100" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
The SVG rectangle takes in four main inputs.
</p>
<p>
The x and y - which is where the rectangle is drawn from and the height and width.
</p>
<p>
Remember - the SVG coordinate space starts at the top left and goes to the bottom right as x and y coordinates increase.
</p>
<p>
So as the height increases, the rectangle will get longer down
</p>
<p>
And as the width increases, the rectangle will get longer to the right.
</p>
<br>
<p>
An SVG Rectangle, Created with D3
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("rect");

d3.select("rect").attr("x","25").attr("y","25").attr("width","50").attr("height","100");</code></pre>
</p>
<p>
With D3, we can append an SVG container and then append the SVG rectangle basic shape.
</p>
<p>
Then we can define the attributes of the rectangle to have it appear on the screen.
</p>
<p>
As we will see shortly, transitions can be applied to each of these attributes.
</p>
<p>
One other aspect of the rectangle that can be transitioned is the color fill.
</p>
<br>
<p>
An SVG Circle
</p>
<p>
<pre><code class="html">&lt;svg&gt;
    &lt;circle cx="25" cx="25" r="15" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
The SVG circle takes in three main inputs.
</p>
<p>
The cx and cy - which is where the center of the circle is drawn from
</p>
<p>
and the r which is the radius of the circle.
</p>
<br>
<p>
An SVG Circle, Created with D3
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("circle");

d3.select("circle").attr("cx","25").attr("cy","25").attr("r","15");</code></pre>
</p>
<p>
With D3, we can append an SVG container and then append the SVG circle basic shape.
</p>
<p>
Then we can define the attributes of the circle to have it appear on the screen.
</p>
<p>
As we will see shortly, each of these attributes can be transitioned as it is a number.
</p>
<p>
One other aspect of the circle that can be transitioned is the color fill.
</p>
<br>
<p>
An SVG Ellipse 
</p>
<p>
<pre><code class="html">&lt;svg&gt;
    &lt;ellipse cx="65" cy="65" rx="10" ry="25" /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
The SVG ellipse takes in four main inputs.
</p>
<p>
The cx and cy - which is where the center of the ellipse is drawn from
</p>
<p>
and the x radius of the ellipse and the y radius of the ellipse.
</p>
<br>
<p>
An SVG Ellipse, Created with D3
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("ellipse");

d3.select("ellipse").attr("cx","65").attr("cy","65").attr("rx","10").attr("ry","25");</code></pre>
</p>
<p>
With D3, we can append an SVG container and then append the SVG ellipse basic shape.
</p>
<p>
Then we can define the attributes of the ellipse to have it appear on the screen.
</p>
<p>
As we will see shortly, each of these attributes can be transitioned as it is a number.
</p>
<p>
One other aspect of the ellipse that can be transitioned is the color fill.
</p>
<br>
<p>
An SVG Straight Line
</p>
<p>
<pre><code class="html">&lt;svg&gt;
    &lt;line x1="5" x1="5" x2="40" x2="40" stroke="gray" stroke-width="5"  /&gt;
&lt;/svg&gt;</code></pre>
</p>
<p>
The SVG Straight Line takes in six main inputs.
</p>
<p>
The x1 and y1 - which is where the line starts
</p>
<p>
The x2 and y2 - which is where the line ends
</p>
<p>
and stroke and stroke-width which is the color of the line and the stroke width.
</p>
<p>
The stroke and stroke-width are necessary because an SVG line is dimensionless.
</p>
<p>
So by applying a stroke-width greater than zero, we can see the line.
</p>
<br>
<p>
An SVG Straight Line, Created with D3
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("line");

d3.select("line").attr("x1","5").attr("y1","5").attr("x2","40").attr("y2","40").attr("stroke","gray").attr("stroke-width","5");</code></pre>
</p>
<p>
With D3, we can append an SVG container and then append the SVG straight line basic shape.
</p>
<p>
Then we can define the attributes of the straight line to have it appear on the screen.
</p>
<p>
As we will see shortly, each of these attributes can be transitioned as it is a number.
</p>
<br>
<p>
Let's now take a look at a few SVG basic Shape D3 transition animations.
</p>
<br>
<br>
<p>
<strong>
D3 Transition Animations
</strong>
</p>
<br>
<p>
SVG Basic Shapes
</p>
<p>
<ul>
<li>Rectangle</li>
<li>Circle</li>
<li>Ellipse</li>
<li>Straight Line</li>
</ul>
</p>
<p>
For each SVG Basic shape, we will go through an example of animating 2 of the inputs of each shape.
</p>
<br>
<p>
Things To Animate
</p>
<p>
<ul>
<li>Shape</li>
<li>Location / Position</li>
<li>Appearance</li>
</ul>
</p>
<p>
When thinking about animations, it's helpful to think of the three types of things you can change for each shape.
</p>
<p>
You can change it's shape - is it larger, smaller, wider, narrower, skewed in one direction or the other.
</p>
<p>
You can change where it's drawn - is it near the origin or somewhere else in the x-y coordinate space.
</p>
<p>
and You can change it's appearance - what color it is and what opacity it has.
</p>
<p>
You can mix and match as you see fit to make some really interesting animations.
</p>
<p>
For the examples, we will stick with mainly shape and location/position.
</p>
<p>
The SVG Straight Line will work with appearance transition animations.
</p>
<br>
<p>
Rectangle Animation Example 1
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("rect");

d3.select("rect").attr("x","25").attr("y","25").attr("width","50").attr("height","100");

d3.select("rect").transition().attr("height","300");</code></pre>
</p>
<p>
For this example, we will have the SVG Rectangle increase it's height from 100 to 300.
</p>
<p>
This will elongate the rectangle along the Y-Axis.
</p>
<p>
Because we do not specify a delay or duration, the animation will start immediately and take 250 milliseconds.
</p>
<br>
<p>
Rectangle Animation Example 2
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("rect");

d3.select("rect").attr("x","25").attr("y","25").attr("width","50").attr("height","100");

d3.select("rect").transition().attr("x","5");</code></pre>
</p>
<p>
For this example, we will have the SVG Rectangle move it's starting "x" drawing point from 25 to 5.
</p>
<br>
<p>
Circle Animation Example 1
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("circle");

d3.select("circle").attr("cx","25").attr("cy","25").attr("r","15");

d3.select("circle").transition().attr("cy","250");</code></pre>
</p>
<p>
For this example, we will have the SVG Circle move it's "cy" point from 25 to 250.
</p>
<p>
This will move the circle from near the top of the window to the bottom of the window.
</p>
<br>
<p>
Circle Animation Example 2
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("circle");

d3.select("circle").attr("cx","25").attr("cy","25").attr("r","15");

d3.select("circle").transition().attr("r","45");</code></pre>
</p>
<p>
For this example, we will have the SVG Circle increase it's radius from 15 to 45 units.
</p>
<p>
Part of the circle falls outside of the SVG Viewport so it will appear to be cut off.
</p>
<p>
Again, because we do not specify a delay or duration, the animation will start immediately and take 250 milliseconds.
</p>
<br>
<p>
Ellipse Animation Example 1
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("ellipse");

d3.select("ellipse").attr("cx","65").attr("cy","65").attr("rx","10").attr("ry","25");

d3.select("ellipse").transition().attr("ry","55");</code></pre>
</p>
<p>
For this example, we will have the SVG Ellipse increase it's "ry" radius from 25 to 55.
</p>
<p>
This will elongate the Ellipse along the Y-axis.
</p>
<br>
<p>
Ellipse Animation Example 2
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("ellipse");

d3.select("ellipse").attr("cx","65").attr("cy","65").attr("rx","10").attr("ry","25");

d3.select("ellipse").transition().attr("cy","205");</code></pre>
</p>
<p>
For this example, we will have the SVG Ellipse increase it's "cx" point from 65 to 205.
</p>
<p>
This will move the ellipse down our screen along the Y-axis.
</p>
<br>
<p>
Straight Line Animation Example 1
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("line");

d3.select("line").attr("x1","5").attr("y1","5").attr("x2","40").attr("y2","40").attr("stroke","gray").attr("stroke-width","5");

d3.select("line").transition().attr("stroke-width","20");</code></pre>
</p>
<p>
We've already covered more than a few examples where we change the x and y coordinates, so this time we'll change the stroke-width.
</p>
<p>
For this example, we will have the stroke-width increase from 5 to 20.
</p>
<p>
This will give our line more weight and make it wider.
</p>
<br>
<p>
Straight Line Animation Example 2
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("line");

d3.select("line").attr("x1","5").attr("y1","5").attr("x2","40").attr("y2","40").attr("stroke","gray").attr("stroke-width","5");

d3.select("line").transition().attr("stroke","red");</code></pre>
</p>
<p>
We've already covered more than a few examples where we change the x and y coordinates, so this time we'll change the stroke color.
</p>
<p>
For this example, we will have the stroke color go from gray to red.
</p>
<p>
This will change the color of the line from gray to red.
</p>
<br>
<p>
Alright, let's go to the JavaScript Console to see the transitions in action.
</p>
<br>
<p>
We start with a blank HTML document that has the D3 library hooked up from the D3js.org website.
</p>
<br>
<p>
For each example, we will reset the browser to get a clean slate.
</p>
<br>
<p>
Rectangle Animation Example 1
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("rect");

d3.select("rect").attr("x","25").attr("y","25").attr("width","50").attr("height","100");

d3.select("rect").transition().attr("height","300");</code></pre>
</p>
<p>
Notice that the rectangle transition animation increased the height of the rectangle shape.
</p>
<br>
<p>
Rectangle Animation Example 2
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("rect");

d3.select("rect").attr("x","25").attr("y","25").attr("width","50").attr("height","100");

d3.select("rect").transition().attr("x","5");</code></pre>
</p>
<p>
Notice that the rectangle transition animation moved the rectangle location/position to the left.
</p>
<br>
<p>
Circle Animation Example 1
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("circle");

d3.select("circle").attr("cx","25").attr("cy","25").attr("r","15");

d3.select("circle").transition().attr("cy","250");</code></pre>
</p>
<p>
Notice that the circle transition animation moved the circle location/position down.
</p>
<br>
<p>
Circle Animation Example 2
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("circle");

d3.select("circle").attr("cx","25").attr("cy","25").attr("r","15");

d3.select("circle").transition().attr("r","45");</code></pre>
</p>
<p>
Notice that the circle transition animation increased the size of the circle shape.
</p>
<p>
Also notice that the circle appears to be cut off because parts of it are outside of the SVG Viewport.
</p>
<br>
<p>
Ellipse Animation Example 1
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("ellipse");

d3.select("ellipse").attr("cx","65").attr("cy","65").attr("rx","10").attr("ry","25");

d3.select("ellipse").transition().attr("ry","55");</code></pre>
</p>
<p>
Notice that the ellipse transition animation increased the length of the ellipse shape along the Y-axis.
</p>
<br>
<p>
Ellipse Animation Example 2
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("ellipse");

d3.select("ellipse").attr("cx","65").attr("cy","65").attr("rx","10").attr("ry","25");

d3.select("ellipse").transition().attr("cy","205");</code></pre>
</p>
<p>
Notice that the ellipse transition animation moved the ellipse position/location down along the Y-axis.
</p>
<br>
<p>
Straight Line Animation Example 1
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("line");

d3.select("line")
    .attr("x1","5")
    .attr("y1","5")
    .attr("x2","40")
    .attr("y2","40")
    .attr("stroke","gray")
    .attr("stroke-width","5");

d3.select("line").transition().attr("stroke-width","20");</code></pre>
</p>
<p>
Notice that the straight line transition animation widened the line width appearance.
</p>
<br>
<p>
Straight Line Animation Example 2
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("line");

d3.select("line")
    .attr("x1","5")
    .attr("y1","5")
    .attr("x2","40")
    .attr("y2","40")
    .attr("stroke","gray")
    .attr("stroke-width","5");

d3.select("line").transition().attr("stroke","red");</code></pre>
</p>
<p>
Notice that the straight line transition animation changed the line color appearance from gray to red.
</p>
<br>
<p>
Next, let's take a look at how we can apply delays and modified durations to transitions of SVG Elements.
</p>
<br>
<br>
<p>
<strong>
Delaying and Modifying Durations of Animations
</strong>
</p>
<br>
<p>
Two SVG Rectangles, Created with D3
</p>
<p>
<pre><code class="javascript">var svgSelection = d3.select("body").append("svg");

var rect1Selection = svgSelection.append("rect").attr("class", "rect1");

var rect2Selection = svgSelection.append("rect").attr("class", "rect2");

rect1Selection.attr("x","5").attr("y", "5").attr("width", "20").attr("height", "20").style("fill","red");

rect2Selection.attr("x","25").attr("y","25").attr("width","50").attr("height","100").style("fill", "green");</code></pre>
</p>
<p>
For this section, we will only use the SVG Rectangle basic shape and leave as an exercise to the viewer how it works with the other SVG basic shapes.
</p>
<p>
The examples in the previous section showed how once you understand the basic methodology, it works the same way with all of the SVG basic shapes and elements.
</p>
<p>
In this section, we will use two rectangles that are colored red and green.
</p>
<br>
<p>
Recall that you can specify how long to delay the transition before it starts.
</p>
<p>
<pre><code class="javascript">d3.selection.transition.delay(delay)
// delay = constant
// delay = function

d3.selection.transition.duration(duration)
// duration = constant
// duration = function</code></pre>
</p>
<p>
Recall that you can also specify how long the duration of the transition should last once it starts.
</p>
<br>
<p>
This is an example of the delay functionality.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect").transition().attr("y", "105").delay(function(d,i){
    if (i === 0) {
        return 2000;
    } else {
        return 4000;
    };
});</code></pre>
</p>
<p>
Here we will selectAll the rectangles on the page.
</p>
<p>
Since there are two, this selection has both the red and green rectangles.
</p>
<p>
Then a transition is applied to each rectangle.
</p>
<p>
A delay to the start of the transition is defined.
</p>
<p>
If the rectangle selection index is 0, then a location/position transition animation will occur after 2 seconds.
</p>
<p>
If the rectangle selection index is something else, then a location/position transition animation will occur after 4 seconds.
</p>
<br>
<p>
This is an example of the duration functionality.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect").transition().attr("y", "5").duration(function(d,i){
    if (i === 0) {
        return 5000;
    } else {
        return 2000;
    };
});</code></pre>
</p>
<p>
Here we will selectAll the rectangles on the page.
</p>
<p>
Since there are two, this selection has both the red and green rectangles.
</p>
<p>
Then a transition is applied to each rectangle.
</p>
<p>
A duration of the transition is defined for each element in the selection.
</p>
<p>
If the rectangle selection element index is 0, then a location/position transition animation will occur for a period of 5 seconds.
</p>
<p>
If the rectangle selection element index is something else, then a location/position transition animation will occur for a period of 2 seconds.
</p>
<br>
<p>
This is an example of combining the duration and delaying functionality being applied to a location/position transition.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect").transition().attr("y", "105").delay(function(d,i){
    if (i === 0) {
        return 1000;
    } else {
        return 5000;
    }})
.duration(function(d,i){
    if (i === 0) {
        return 5000;
    } else {
        return 1000;
    };
});</code></pre>
</p>
<p>
A delay and a modified duration transition are applied to each rectangle element.
</p>
<p>
If the index is zero, the rectangle will wait 1 second before moving and take 5 seconds to complete the transition animation.
</p>
<p>
If the index is not zero, the rectangle will wait 5 seconds before moving and then take 1 second to complete the transition animation.
</p>
<p>
By combining the delay and transition, you can create some pretty inspiring effects.
</p>
<br>
<p>
Alright, let's go to the JavaScript Console to see the transitions in action.
</p>
<br>
<p>
We start with a blank HTML document that has the D3 library hooked up from the D3js.org website.
</p>
<br>
<p>
Let's create the two rectangles
</p>
<p>
<pre><code class="javascript">var svgSelection = d3.select("body").append("svg");

var rect1Selection = svgSelection.append("rect").attr("class", "rect1");

var rect2Selection = svgSelection.append("rect").attr("class", "rect2");

rect1Selection.attr("x","5").attr("y", "5").attr("width", "20").attr("height", "20").style("fill","red");

rect2Selection.attr("x","25").attr("y","25").attr("width","50").attr("height","100").style("fill", "green");</code></pre>
</p>
<p>
You can now see the two rectangles in the webpage.
</p>
<br>
<p>
Next, let's try the delay example:
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .transition()
        .attr("y", "105")
        .delay(function(d,i){
            if (i === 0) {
                return 2000;
            } else {
                return 4000;
            };
        });</code></pre>
</p>
<p>
In this example, you saw the red rectangle transition it's location / position down after two seconds.
</p>
<p>
Then, the green rectangle transitioned it's location / position down after four seconds.
</p>
<br>
<p>
Next, let's try the duration example:
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .transition()
        .attr("y", "5")
        .duration(function(d,i){
            if (i === 0) {
                return 5000;
            } else {
                return 2000;
            };
        });</code></pre>
</p>
<p>
In this example, both rectangles start moving at the same time though the red one takes 5 seconds to complete the transition while the green one takes only 2 seconds.
</p>
<p>
This gives the animation an illusion of the green one sliding past the red one until the red one catches up.
</p>
<br>
<p>
Finally, let's try the delay and duration example:
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .transition()
        .attr("y", "105")
        .delay(function(d,i){
            if (i === 0) { return 1000; } else { return 5000; }})
        .duration(function(d,i){
            if (i === 0) { return 5000; } else { return 1000; }});</code></pre>
</p>
<p>
In this example, the total time for the transition of both rectangles is the same - six seconds.
</p>
<p>
However, the red rectangle waits 1 seconds before it start the movement and then takes 5 seconds to complete the movement.
</p>
<p>
The green rectangle on the other hand waits 5 seconds before it starts the movement and then takes 1 second to complete the movement.
</p>
<p>
Through putting together delays and durations on various elements, you can develop sophisticated animations.
</p>
<br>
<p>
And with that we have covered how D3 transitions work with SVG Elements, as well as basic examples of doing animation transitions of shape, location/position and appearance.
</p>
        </div>
      </div>
        
    </div>
<hr>
<h3 id="lesson52">DOM Event Model and JavaScript<h3>
    <div>
        <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>DOM (Document Object Model) Events have two main goals: a) event system for event listeners/handlers and event flow description and b) common subset of event systems for browsers</li>
<li>DOM Event Drivers include: mouse events, touch events, keyboard events, HTML frame/object events, HTML form events, User Interface events, and many more</li>
<li>The DOM Event Flow is set of steps taken for an Event to traverse the DOM tree from the top of the document to the exact DOM node that was interacted with</li>
<li>There are three phases to the DOM Event Flow: Capture Phase, Target Phase, and Bubble Phase</li>
<li>The DOM Event Flow Capture Phase describes the travel the event takes from the top of the DOM tree to the DOM node that was interacted with</li>
<li>The DOM Event Flow Target Phase describes the event reaching the DOM node that was interacted with</li>
<li>The DOM Event Flow Bubble Phase describes the travel the event takes from the DOM node that was interacted with back to the top of the DOM tree</li>
<li>Capture Phase event listeners are executed before Target Phase event listeners which are executed before Bubbling Phase event listeners</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/introduction-to-javascript">Introduction to JavaScript</a></li>
<li><a href="https://www.dashingd3js.com/lessons/javascript-callback-functions">JavaScript Callback Functions</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-transition-basics">D3 Transition Basics</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            DOM Event Model and JavaScript
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
DOM Event Model
</strong>
</p>
<br>
<p>
W3C - Document Object Model Events
</p>
<br>
<p>
DOM events have two main goals:
<br>
a) Event System for event listeners/handers and event flow description
<br>
b) Common subset of event systems for browsers.
</p>
<p>
The W3C designed the Document Object Model system with two main goals.
</p>
<p>
A) Event system for registration of event listeners and describing event flow through the DOM Tree Structure
</p>
<p>
B) Provide a common subset of event systems used in DOM Level 0 browsers.
</p>
<p>
These events and systems are implemented in all modern web browsers.
</p>
<p>
Which lets us focus on event-driven programming.
</p>
<br>
<p>
DOM Event Model
<br>
a) DOM Event Flow
<br>
b) Interfaces
</p>
<p>
The DOM Event Model covers how DOM Events flow through the tree-based DOM structure.
</p>
<p>
The DOM Event Model also covers how to interact with a set of interfaces to access contextual information on events and how to register event listeners.
</p>
<br>
<p>
Document Object Model Event Drivers
</p>
<p>
<ul>
<li>Mouse events</li>
<li>Touch events</li>
<li>Keyboard events</li>
<li>HTML frame/object events</li>
<li>HTML form events</li>
<li>User interface events</li>
</ul>
</p>
</p>
<p>
Document Object Model Events come many in different shapes and sizes.
</p>
<p>
They can be driven by the mouse, by a touch, by the key board and by a few other different types of specific actions.
</p>
<p>
Because various web browsers had significant differences in implementation and what events they responded to, the Document Object Model Event Model was standardized by the W3C in DOM Level 2.
</p>
<p>
When any kind of one of these events is triggered we can have our code perform one or many tasks.
</p>
<br>
<p>
DOM Event Drivers - Mouse Events
</p>
<p>
<ul>
<li>click</li>
<li>double click</li>
<li>mouse down</li>
<li>mouse up</li>
<li>mouse over</li>
<li>mouse move</li>
<li>mouse out</li>
<li>context menu</li>
<li>drag</li>
<li>drag start</li>
<li>drag enter</li>
<li>drag over</li>
<li>drag leave</li>
<li>drag end</li>
<li>drag drop</li>
<li>drag gesture</li>
<li>drag over</li>
<li>select start</li>
<li>DOM Mouse Scroll</li>
</ul>
</p>
  </p>
<p>
If we focus only on DOM Mouse events for the moment, we can take a look at a few of the common ones.
</p>
<p>
There are many DOM Mouse event Drivers that are considered Mouse Events.
</p>
<br>
<p>
DOM event Drivers - Mouse Events
<li>click</li>
<li>double click</li>
<li>mouse down</li>
<li>mouse up</li>
<li>mouse over</li>
<li>mouse move</li>
<li>mouse out</li>
</p>
<p>
The main ones are related to clicking and moving the mouse over something.
</p>
<p>
Because browsers can respond to these events, we can write exactly what happens when one of these events occurs.
</p>
<p>
Let's cover these main ones and how they are defined.
</p>
<br>
<p>
A mouse click event fires when the mouse button is clicked over an element.
</p>
<p>
A click is defined as a mouse down and mouse up over the same screen location.
</p>
<br>
<p>
A mouse double click event fires when the mouse button is doubled clicked over an element.
</p>
<p>
A click is defined as a mouse down and mouse up over the same screen location.
</p>
<br>
<p>
A mouse down event fires when the mouse button is pressed over an element.
</p>
<p>
A mouse up event fires when the mouse button is released over an element.
</p>
<p>
A mouse over event fires when the mouse cursor is moved onto an element.
</p>
<p>
A mouse move event fires when the mouse cursor is moved while over an element.
</p>
<p>
A mouse out event fires when the mouse cursor moves away from an element.
</p>
<p>
Document Object Model Event Drivers
</p>
<p>
<ul>
<li>Mouse events</li>
<li>Touch events</li>
<li>Keyboard events</li>
<li>HTML frame/object events</li>
<li>HTML form events</li>
<li>User interface events</li>
</ul>
</p>
</p>
<p>
If we go back to the list of different types of Event Drivers, we can see that there are many ways that a user can interact with the webpage and thus trigger various events.
</p>
<p>
The rest of this video will focus on how to capture these events and how they flow through the DOM tree.
</p>
<br>
<br>
<p>
<strong>
Listening For DOM Events
</strong>
</p>
<br>
<p>
DOM Level 0 Event Listener
</p>
<p>
<pre><code class="html">&lt;a href="#" onclick="alert('clicked');"&gt;Click Me&lt;/a&gt;</code></pre>
</p>
<p>
In this example, when the HTML link is clicked, an alert will pop up with the string "clicked".
</p>
<p>
This is the simplest way to define an event handler/listener.
</p>
<p>
This is called a DOM Level 0 Event Listener.
</p>
<p>
While it is the simplest way, it is not recommended for a few reasons:
</p>
<p>
One - the JavaScript is written as part of the HTML, which violates separation of concerns.
</p>
<p>
Two - this type of code is very inflexible because every link will need to have it's own written handler, which means you cannot assign a handler to all links.
</p>
<p>
Three - we can only define one type of handler for the link.

</p>
<br>
<p>
DOM Level 1 Event Listener
</p>
<p>
<pre><code class="javascript">&lt;a href="#" id="myLink"&gt;Click Me&lt;/a&gt;

&lt;script&gt;
    document.getElementById("myLink").onclick = function(){ alert('vanilla'); }
    document.getElementById("myLink").onclick = function(){ alert('cupcake'); }
&lt;/script&gt;</code></pre>
</p>
<p>
In this example, when the HTML link is clicked, an alert will pop up with the string "cupcake".
</p>
<p>
This is called a DOM Level 1 Event Listener.
</p>
<p>
This solves the separations of concerns issue.
</p>
<p>
The HTML is written separately from the JavaScript Event Handler/Listener.
</p>
<p>
This allows us to write a function for events and then we can attach it as many times as we like.
</p>
<p>
It is a little more complicated than the previous example as we are setting a callback function as an attribute of the HTML element.
</p>
<p>
Which means that if we define a new handler this way for the same element, it will overwrite that attribute.
</p>
<p>
So in the example on the screen, when this link is clicked, the word "cupcake" will be the alert that comes up, not "vanilla".
</p>
<p>
This is because the second time we define the event handler, it overwrites the original event handler.
</p>
<p>
So the main downside to this approach is that we can only define one handler per element.

</p>
<br>
<p>
DOM Level 2 Event Listener
</p>
<p>
<pre><code class="javascript">&lt;a href="#" id="myLink"&gt;Click Me&lt;/a&gt;

&lt;script&gt;
    var el = document.getElementById("myLink");

    function sayVanilla () { alert('vanilla'); };
    function sayCupcake () { alert('cupcake'); };

    el.addEventListener('click', sayVanilla, false);
    el.addEventListener('click', sayCupcake, false);
&lt;/script&gt;</code></pre>
</p>
<p>
In this example, when the HTML link is clicked, an alert will pop up with the string "vanilla".
</p>
<p>
Then when you press okay to that alert, a second alert will pop up with the string "cupcake".
</p>
<p>
This is called a DOM Level 2 Event Listener.
</p>
<p>
This solves the separations of concerns issue.
</p>
<p>
It allows us a great deal more flexibility than defining attributes of the HTML element.
</p>
<p>
It also allows us to attach as many event listeners to a specific element as we want.
</p>
<p>
In this example, we attached two event listeners, where we could have attached 1 or many more.

</p>
<br>
<p>
DOM Level 2 Event Listener
</p>
<p>
<pre><code class="javascript">&lt;a href="#" id="myLink"&gt;Click Me&lt;/a&gt;

&lt;script&gt;
    var el = document.getElementById("myLink");
    function sayCupcake () { alert('cupcake'); };
    el.addEventListener('click', sayCupcake, false);
&lt;/script&gt;</code></pre>
</p>
<p>
Looking specifically at the code, let's break it down.
</p>
<p>
First, we have the HTML code for a link.
</p>
<p>
Then we have a section of JavaScript code.
</p>
<p>
In this JavaScript code we first select the element that we are going to use.
</p>
<p>
We do this by using the HTML element id.
</p>
<p>
Then we define a function named "sayCupcake" that evaluates the alert function with the string "cupcake".
</p>
<p>
This will cause an alert to pop-up in the browser when the sayCupcake function is called.
</p>
<p>
Lastly, we use the "addEventListener" method to tell the element three things.
</p>
<p>
One - what to listen to: In this case a "click" event.
</p>
<p>
Two - what do do when the event is heard: In this case, call the function sayCupcake
</p>
<p>
Three - we tell it false.
</p>
<p>
This third parameter, is how we tell the event to trigger at a certain point in the flow of the event through the DOM Tree.
</p>
<p>
In the next section we'll explore what "false" vs "true" do as the third element of the addEventListener.
</p>
<p>
For now, know that this third parameter is used to tell the event whether the event handler is to be fired on the Capture or Bubble phase of the DOM Event Flow.
</p>
<br>
<br>
<p>
<strong>
DOM Event Flow
</strong>
</p>
<br>
<p>
Looking at the previous example, we can look at the syntax for the addEventListener.
</p>
<p>
<pre><code class="javascript">el.addEventListener('click', sayCupcake, false);

target.addEventListener(type, listener[, useCapture]);</code></pre>
</p>
<p>
The first part of the syntax is the target.
</p>
<p>
This can be a DOM element in the document, the Document itself, a window or any other object that supports events.
</p>
<p>
The "type" is a string representation of a specific event type to listen for.
</p>
<p>
There are W3C specific events and then there are browser specific events, so you want to make sure you check carefully that the events you are listening for are supported by all browsers.
</p>
<p>
The listener is the object or JavaScript function that receives a notification that the event of a specific type has occurred.
</p>
<p>
Lastly, the useCapture tells the listener when the user wants to initiate the event trigger.
</p>
<br>
<p>
There and Back Again
</p>
<p>
<ul>
<li>Capture Phase</li>
<li>Target Phase</li>
<li>Bubble Phase</li>
</ul>
</p>
</p>
<p>
Events Flow through the document in three phases.
</p>
<p>
The first phase is the capture phase.
</p>
<p>
The second phase is the target phase.
</p>
<p>
and the third phase is the bubble phase.
</p>
<br>
<p>
Let's take a look at this example HTML code.
</p>
<p>
<pre><code class="html">&lt;html&gt;
    &lt;body&gt;
        &lt;table&gt;
            &lt;tbody&gt;
                &lt;tr&gt;
                    &lt;td&gt;Shady Grove&lt;/td&gt;
                    &lt;td&gt;Aeolian&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td&gt;Over the river, Charlie&lt;/td&gt;
                    &lt;td&gt;Dorian&lt;/td&gt;
                &lt;/tr&gt;
            &lt;/tbody&gt;
        &lt;/table&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
</p>
<p>
This is an HTML document that contains a 2 by 2 table.
</p>
<p>
There are two rows and each row has 2 columns.
</p>
<p>
The td's are child elements of the tr's.
</p>
<p>
The tr's are child elements of the tbody
</p>
<p>
The tbody is a child element of the table.
</p>
<p>
The table is a child element of the body
</p>
<p>
and the body is a child element of the HTML.
</p>
<br>
<p>
This picture from the W3C Working Group perfectly illustrates the DOM tree and the event Flow.
</p>
<p>
[ Image: W3C Event Flow Diagram ]
</p>
<p>
When a td element is clicked, the click event "drills" down the document from the HTML tag to the element clicked and then makes it's way back up.
</p>
<p>
The first part is the capture phase where it goes down the tree.
</p>
<p>
The second part is when it interacts with the element that triggered the event.
</p>
<p>
The third part is the bubbling phase where it goes back up the tree.
</p>
<br>
<p>
During the capture phase, the event is sent from the root of the tree to the parent of the target node.
</p>
<br>
<p>
3 Phases
</p>
<p>
<ol>
<li>Capture Phase</li>
<li>Target Phase</li>
<li>Bubbling Phase</li>
</ol>
</p>
</p>
<p>
During the target phase, the event is sent to the target node
</p>
<p>
During the bubbling phase, the event is sent from parent of the target node to the root of the tree.
</p>
<br>
<p>
Capture Phase 
</p>
<p>
[ Image: W3C Event Flow Diagram ]
</p>
<p>
When we click on the TD, the DOM calculates that Capture Phase path.
</p>
<p>
At each element as the event sent is sent down, Capture Phase event handlers will fire in order.
</p>
<p>
So a capture phase event handler will fire for the
</p>
<p>
- document
</p>
<p>
- html
</p>
<p>
- body
</p>
<p>
- table
</p>
<p>
- tbody
</p>
<p>
- and tr
</p>
<br>
<p>
Target Phase
</p>
<p>
[ Image: W3C Event Flow Diagram ]
</p>
<p>
After the Capture Phase has completed, the target phase starts.
</p>
<p>
This is where the event handler for the element we interacted with will get the event object.
</p>
<br>
<p>
Bubbling Phase
</p>
<p>
[ Image: W3C Event Flow Diagram ]
</p>
<p>
<pre><code class="javascript">target.addEventListener(type, listener[, useCapture]);</code></pre>
</p>
<p>
After the Capture phase and the Target phase are done, the bubbling phase will commence.
</p>
<p>
At each element as the event is sent up, Bubbling Phase event handlers will fire in order.
</p>
<p>
So a bubbling phase event handler will fire for the
<br>
- tr
<br>
- tbody
<br>
- table
<br>
- body
<br>
- html
<br>
- document
</p>
<p>
As you can tell, it just does the Capture phase in reverse order.
</p>
<br>
<p>
Alright, so we now understand that when an event is triggered, it goes through the capture phase, target phase and bubbling phase.
</p>
<p>
<pre><code class="html">&lt;table&gt;
    &lt;tr id="tr_hello"&gt;
        &lt;td id="td_hello"&gt;
            &lt;a href="#"&gt;Vanilla Cupcake&lt;/a&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;script&gt;
    var el_tr = document.getElementById("tr_hello");
    var el_td = document.getElementById("td_hello");
    
    function sayVanilla() { alert('vanilla'); }
    function sayCupcake() { alert('cupcake'); }
    
    el_tr.addEventListener('click', sayVanilla, false);
    el_td.addEventListener('click', sayCupcake, false);
&lt;/script&gt;</code></pre>
</p>
<p>
Let's look at the example on the screen.
</p>
<p>
We have an HTML table with one row and one column.
</p>
<p>
The tr element has an id of tr underscore hello
</p>
<p>
The td element has an id of td underscore hello
</p>
<p>
We use JavaScript to attach event listeners to the tr element and the td element.
</p>
<p>
We click on the "Vanilla Cupcake" Link.
</p>
<p>
What happens next?
</p>
<p>
And which alert will show up first, the "vanilla" alert or the "cupcake" alert?
</p>
<br>
<p>
What order the event listeners/handlers are fired depends on two things.
</p>
<p>
<pre><code class="html">
&lt;table&gt;
    &lt;tr id="tr_hello"&gt;
        &lt;td id="td_hello"&gt;
            &lt;a href="#"&gt;Vanilla Cupcake&lt;/a&gt;
        &lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;script&gt;
    var el_tr = document.getElementById("tr_hello");
    var el_td = document.getElementById("td_hello");
    
    function sayVanilla() { alert('vanilla'); }
    function sayCupcake() { alert('cupcake'); }
    
    el_tr.addEventListener('click', sayVanilla, false);
    el_td.addEventListener('click', sayCupcake, false);
&lt;/script&gt;</code></pre>
</p>
<p>
One - which element is the parent and which element is the child
</p>
<p>
Two - which element is fired during the capture phase vs which element is fired in the bubbling phase.
</p>
<p>
In this example, the td element will fire first because it neither addEventListener had the useCapture set to true.
</p>
<p>
Which means that the events will be fired in the bubbling phase.
</p>
<p>
Since the td is a child element of the tr, it will come first.
</p>
<br>
<p>
In this example, both addEventListeners have the useCapture toggled to true.
</p>
<p>
<pre><code class="javascript">el_tr.addEventListener('click', sayVanilla, true);

el_td.addEventListener('click', sayCupcake, true);</code></pre>
</p>
<p>
Which means both events will be fired during the Capture Phase.
</p>
<p>
Which means that since the tr is a parent of td, that the tr will fire first.
</p>
<p>
In this example, the td element will fire first and then the tr element.
</p>
<p>
<pre><code class="javascript">el_tr.addEventListener('click', sayVanilla, false);

el_td.addEventListener('click', sayCupcake, true);</code></pre>
</p>
<p>
Why is this?
</p>
<p>
Because the useCapture is toggled to true for the td element while it is not for the tr element.
</p>
<br>
<p>
Lastly, let's explore this just a step further.
</p>
<p>
<pre><code class="javascript">el.addEventListener("click", function(){alert(1)}, false);

el.addEventListener("click", function(){alert(2)}, true);

el.addEventListener("click", function(){alert(3)}, false);

el.addEventListener("click", function(){alert(4)}, true);</code></pre>
</p>
<p>
Given the code on the screen, what's going to be the order of the numbers that are alerted?
</p>
<p>
BROWSER - wait 5 seconds
</p>
<p>
The answer is 2, 4, 1 and then 3.
</p>
<p>
The 2 shows up first because it is the first defined event listener that had true for it's useCapture option toggled.
</p>
<p>
The 4 shows up second because it is the second defined event listener that had true for it's useCapture option toggled.
</p>
<p>
The 1 shows up third because it is the first defined event listener that had false for it's useCapture option toggled.
</p>
<p>
and the 3 shows up fourth (or last) because it is the second defined event listener that had false for it's useCapture option toggled.
</p>
<br>
<p>
Order Matters
<br>
Capture vs Bubbling Phase Matters
<br>
Capture + Order beats Bubbling + Order
</p>
<p>
This tells us three big things:
</p>
<p>
One - Event Listeners from the Capture Phase are executed before Event Listeners from the Bubbling Phase
</p>
<p>
Two - Event Listeners are executed in order of definition
</p>
<p>
Three - Capture Phase overrides definition order if there are Bubbling Phase Event Listeners defined earlier than the Capture Phase event listeners.
</p>
<br>
<p>
Document Object Model Event Drivers
</p>
<ul>
<li>Mouse events</li>
<li>Touch events</li>
<li>Keyboard events</li>
<li>HTML frame/object events</li>
<li>HTML form events</li>
<li>User interface events</li>
</ul>
</p>
<br>
<p>
And with that we have covered the basics of how DOM Events Work, how we can add listeners to them and how we can make sure they execute at the right time.
</p>
<p>
Since there are events that can be driven by the mouse, by a touch, by the key board and other input devices, it's good to read up on the particular event you are adding to your data visualization.
</p>
<p>
Which is where our next video will go - how to add events to D3 Data Visualizations.
</p>
        </div>
      </div>

</div>
     
<hr>
<h3 id="lesson53">D3 and DOM Events<h3>
    <div>
         <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>d3.selection.on(type[, listener[, capture]]) adds an event listener to each element in the current selection</li>
<li>D3 invokes the listener in the same way it invokes other D3 operator functions - by passing the current datum "d", index "i", and the "this" context as the current DOM element</li>
<li>Notice D3 allows you to take advantage of capture phase versus bubbling phase event triggers</li>
<li>d3.event captures an event when it happens and stores it in the variable d3.event</li>
<li>The d3.event variable is a global variable that can be used in the event listener callback function registrered with the d3.selection.on operator</li>
<li>After the JavaScript callback function has finished running, the current d3.event variable is reset</li>
<li>You can "delete" an event listener by passing the JavaScript null object as the function for the eventListener type</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/introduction-to-javascript">Introduction to JavaScript</a></li>
<li><a href="https://www.dashingd3js.com/lessons/javascript-callback-functions">JavaScript Callback Functions</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-transition-basics">D3 Transition Basics</a></li>
<li><a href="https://www.dashingd3js.com/lessons/dom-event-model-and-javascript">DOM Event Model and JavaScript</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 and DOM Events
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
D3 selection.on
</strong>
</p>
<br>
<p>
Now that we have covered how to add an event listener to an HTML element using DOM Level 2 Event Listeners with JavaScript, let's cover how we can do the same with thing D3.
</p>
<p>
<pre><code class="javascript">target.addEventListener(type, listener[, useCapture]);</code></pre>
</p>
<br>
<p>
The d3 selection dot on method adds an event listener to each element in the current selection.
</p>
<p>
<pre><code class="javascript">target.addEventListener(type, listener[, useCapture]);

d3.selection.on(type[, listener[, capture]])</code></pre>
</p>
<p>
So we can use select for a 1 element selection or a selectAll for a multi-element selection.
</p>
<p>
The type is a string of the event type that we want an event listener for.
</p>
<p>
Examples could be mouse down, mouse up, mouse over, mouse out, etc.
</p>
<p>
D3 invokes the listener in the same way it invokes other operator functions - by passing the current datum d and index i and the "this" context as the current DOM element.
</p>
<p>
Note that we can still take advantage of capture phase vs bubbling phase event triggers in D3.
</p>
<br>
<p>
This example creates a selection of all the SVG Circle Elements.
</p>
<p>
<pre><code class="javascript">d3.selectAll("circle")
    .on("mouseover", function(d,i) { alert("mouseover"); })
    .on("mouseout",  function(d,i) { alert("mouseout");  });</code></pre>
</p>
<p>
Then using the d3 selection dot on, it adds a mouse over event listener to each SVG circle element.
</p>
<p>
When the mouse goes over one of the SVG Circle Elements, the anonymous function will be invoked.
</p>
<p>
Currently, it will alert us with the string "mouseover"
</p>
<p>
Then using the D3 selection dot on, it adds a mouse out event listener to each SVG circle element.
</p>
<p>
When the mouse leaves one of the the SVG Circle Elements after having been on it, the anonymous function will be invoked.
</p>
<p>
Currently it will alert us with the string "mouseout"
</p>
<p>
Notice that we are adding two different types of event listeners to the same SVG Element.
</p>
<p>
Also notice that every single element in the selection will receive the same event listeners.
</p>
<br>
<p>
As you can imagine, we can also use the index and the data object attached to each circle element.
</p>
<p>
<pre><code class="javascript">d3.selectAll("circle")
    .on("mouseover", function(d,i) { alert( d.value ); })
    .on("mouseout",  function(d,i) { alert( d.value );  });</code></pre>
</p>
<p>
In this example, if the data object had a key of "value", then this would return the value of the key,value pair.
</p>
<p>
This is very powerful, because now we have some interaction with the mouse.
</p>
<p>
This is one of the reasons that we have covered before, why it's very important to leave the data unchanged when attaching it to DOM elements.
</p>
<p>
We can also use the element index as well as the "this" context of each element.
</p>
<br>
<p>
Because event interactions can get very complicated quickly with transitions and the duration of the transition, styling and other functionality, it's often easier to understand if you write named functions elsewhere in the code that the selection.on can reference.
</p>
<p>
<pre><code class="javascript">function mouseover(d) { alert(d.value); }

function mouseout (d) { alert(d.value); }

d3.selectAll("circle")
    .on("mouseover", mouseover)
    .on("mouseout",  mouseout );</code></pre>
</p>
<p>
In this way, your code will be very clear to read and be maintainable.
</p>
<br>
<p>
SVG DOM Element + Mouse Event
</p>
<p>
So far so good, we are able to attach an event listener to the SVG Dom Element.
</p>
<p>
We are also able to specify specific actions / calculations that must happen when the event is triggered through a JavaScript Function.
</p>
<p>
Let's take a look at a few examples in the JavaScript Console.
</p>
<br>
<p>
Let's start simply by interacting with HTML Elements.
</p>
<br>
<p>
We create 3 paragraph elements.
</p>
<p>
<pre><code class="javascript">d3.select("body").append("p").text("one").attr("id","p_1");

d3.select("body").append("p").text("two").attr("id","p_2");

d3.select("body").append("p").text("three").attr("id","p_3");</code></pre>
</p>
<p>
You can see the three paragraphs in the browser window.
</p>
<p>
You can see their id's in the Chrome Developer Tool's Elements Section.
</p>
<br>
<p>
Next, let's select the first paragraph and add a mouseover event to it.
</p>
<p>
<pre><code class="javascript">d3.select("#p_1")
    .on("mouseover", function(d, i) { alert("paragraph power!");});</code></pre>
</p>
<p>
Before we move our mouse over the paragraph, notice that once the command was run nothing was added to the HTML of the page.
</p>
<br>
<p>
Now, let's move over the paragraph.
</p>
<p>
BROWSER move over any / all the paragraphs, showing that only the first paragraph has a pop-up.
</p>
<p>
BROWSER click okay on the pop-ups to close them.
</p>
<p>
You should have seen the pop-up happen.
</p>
<p>
That shows you how easy it is to add events to DOM elements, in this case HTML with D3.
</p>
<br>
<p>
Next, instead of selecting the first paragraph, let's create a selection of all the paragraphs and add the same on mouseover event functionality.
</p>
<p>
<pre><code class="javascript">d3.selectAll("p")
    .on("mouseover", function(d, i) { alert("paragraph power!");});</code></pre>
</p>
<p>
This will add a mouseover event listener to every paragraph element in the selection.
</p>
<p>
For now every paragraph will exhibit the same behavior - have an alert pop up with the string "paragraph power!" when we mouseover the paragraph.
</p>
<br>
<p>
Let's move the mouse over the paragraphs.
</p>
<p>
BROWSER move over any / all of the paragraphs.
</p>
<p>
BROWSER click okay on the pop-ups to close them.
</p>
<p>
You can see that our event trigger now happens for every paragraph element.
</p>
<p>
You can also see that all the paragraphs exhibit the same behavior.
</p>
<br>
<p>
We reset the browser and this time we'll generate some paragraphs with data.
</p>
<p>
BROWSER reset
</p>
<br>
<p>
Let's start with a simple array of 5 numbers.
</p>
<p>
<pre><code class="javascript">var myData = [5, 4, 3, 2, 1];</code></pre>
</p>
<br>
<p>
Let's create paragraphs with them.
</p>
<p>
<pre><code class="javascript">d3.select("body").selectAll("p").data(myData).enter().append("p");

d3.selectAll("p").text(function(d, i) { return "paragraph " + i; });</code></pre>
  </p>
<p>
Browser - Click into the ELEMENTS section and open the body / and first paragraph.
  </p>
<p>
You can see the output, which is 5 paragraph elements with text inside of them.
  </p>
<p>
D3 selections are 0-indexed, so the text of the paragraphs is paragraph 0 all the way to paragraph 4.
</p>
<br>
<p>
Let's check the first paragraph to see what datum was bound to it.
</p>
<p>
<pre><code class="javascript">d3.select("p").data();</code></pre>
  </p>
<p>
This tells us the datum attached to the first paragraph is 5.
  </p>
<p>
This is what we expect.
</p>
<br>
<p>
Let's now add a mouseover function to each paragraph that tells us the datum that is attached to it.
</p>
<p>
In order to do that, we'll have to add a D3 selection.on event.
</p>
<p>
<pre><code class="javascript">d3.selectAll("p")
    .on("mouseover", function(d, i) { alert(d); });</code></pre>
</p>
<p>
This will add an event listener to each paragraph element in the selection.
</p>
<p>
When an element registers a mouseover event, it will run the anonymous function we defined.
</p>
<p>
In this case, it will alert us to the datum bound to the element.
</p>
<p>
Note - that since we did not set or use the capture flag, the events will be triggered during the bubbling phase.
</p>
<br>
<p>
Let's move the mouseover the paragraphs
</p>
<p>
BROWSER move over the paragraphs from bottom to the top.
</p>
<p>
BROWSER click okay on the pop-ups to close them.
</p>
<p>
You can see that each paragraph has an event trigger that happens for every element.
</p>
<p>
You can also see that the behavior is the same for all the paragraphs, though the results are different because we are using a function to access element specific data for each event.
</p>
<br>
<p>
Now, let's make the function that is triggered more complicated and move it outside of the selection.on definition.
</p>
<p>
<pre><code class="javascript">function paragraphMouseOver(d, i) {
    if (i % 2 === 0) { alert(i + " is an even index, datum: "+d); }
    else { alert(i + " is an odd index, datum: "+d); };
};</code></pre>
</p>
<p>
This function will take in the d and i variables that are available from D3.
</p>
<p>
It will then use the i to test to see if the element has an even or odd index.
</p>
<p>
If it is even, then it will alert us with a string that tells us it is even and the datum attached to it.
</p>
<p>
If if is odd, then it will alert us with a string that tells us it is odd and the datum attached to it.
</p>
<br>
<p>
Now, let's re-define the event listener.
</p>
<p>
<pre><code class="javascript">d3.selectAll("p")
    .on("mouseover", paragraphMouseOver);</code></pre>
</p>
<p>
Before we test out the new event listener, you may be wondering what is going to happen to the previous event listener that we defined.
</p>
<p>
The D3 API tells us that if an event listener was already registered for the same type of event on the same selected elements, the existing listener is removed before the new listener is added.
</p>
<p>
If we really want to have multiple event listeners for the same element event type, the type can be followed with an optional name space.
</p>
<p>
We will leave that for later.
</p>
<br>
<p>
Alright, let's mouse over these paragraphs.
</p>
<p>
BROWSER move over the paragraphs from bottom to the top
</p>
<p>
BROWSER click okay on the pop-ups to close them.
</p>
<p>
You can see that each paragraph element has a new event listener function.
</p>
<p>
You can see that the behavior is the same for all the paragraphs based on the function paragraphMouseOver.
</p>
<p>
However, you can see the paragraphs are displaying different results based on their data and index.
</p>
<br>
<p>
Let's turn our attention to SVG DOM Objects and giving them event power.
</p>
<br>
<p>
As you can imagine, it works the exact same way.
</p>
<br>
<p>
This is why it's helpful to think of D3 as more than a Data Visualization JavaScript library - because we can do some wonderful amazing things with regular HTML.
</p>
<br>
<p>
Next, let's create three SVG circle elements based on data.
</p>
<br>
<p>
This time, our data source will be more complicated than the 1 dimensional array of numbers, it will be an array of JSON objects.
</p>
<br>
<p>
We reset the browser.
</p>
<p>
Then we define the three circles
</p>
<p>
<pre><code class="javascript">
var circleData = [ { "x": "050", "y": "050", "r": "30", "color": "yellow", "fruit": "banana"},
                   { "x": "100", "y": "100", "r": "30", "color": "purple", "fruit": "grape" },
                   { "x": "150", "y": "150", "r": "30", "color": "red",    "fruit": "apple" }
];</code></pre>
</p>
<p>
You can see that each JSON object has an x coordinate, a y coordinate, a radius, a color and a fruit type.
</p>
<p>
We will use all of this data in our circles and events.
</p>
<br>
<p>
Next, we create the circles.
</p>
<p>
<pre><code class="javascript">var svg = d3.select("body").append("svg");

var circles = svg.selectAll("circle").data(circleData).enter().append("circle");</code></pre>
</p>
<p>
BROWSER - open the body and SVG element to show the three circles.
</p>
<p>
First, we create the SVG Viewport that the SVG Circle elements will live in.
</p>
<p>
Then we create the circles with data bound to them.
</p>
<p>
The three circles now appear in the Chrome Developer Tool's Elements section.
</p>
<br>
<p>
Next, let's double check to make sure each circle got the right data.
</p>
<p>
<pre><code class="javascript">circles.data();</code></pre>
</p>
<p>
BROWSER - open all three array and objects
</p>
<p>
As you can see, the circles have the JavaScript objects bound to them.
</p>
<br>
<p>
Next, let's add the attributes to the circles.
</p>
<p>
<pre><code class="javascript">circles
    .attr("cx",function(d,i) { return d.x; })
    .attr("cy",function(d,i) { return d.y; })
    .attr("r", function(d,i) { return d.r; })
    .style("fill",function(d,i) { return d.color; });</code></pre>
</p>
<p>
We add the attributes for the "cx", "cy" and "r" to construct the circles.
</p>
<p>
Then we add a style fill to color the circles.
</p>
<p>
You can now see the three circles based on their data.
</p>
<br>
<p>
Now, let's add an event to all the circles that tells us the type of fruit they represent.
</p>
<p>
We will do it with an anonymous function within the D3 selection.on definition.
</p>
<p>
<pre><code class="javascript">d3.selectAll("circle")
    .on("mouseover", function(d, i) { alert(d.fruit); });</code></pre>
  </p>
<p>
This code will add an event listener to each circle and will alert us of the type of fruit the circle represents.
    
</p>
<p>
Let's run our mouse over the circles.
</p>
<p>
BROWSER mouse over the circles.
</p>
<p>
BROWSER click okay on the pop-ups to close them.
</p>
<p>
You can see that the events are in fact attached to each circle element and each one has a mouseover event listener function.
</p>
<br>
<p>
Next, let's try adding another event listener, this time a mouseout event.
</p>
<br>
<p>
We try the mouseout event here, because these circles have a wide enough radius that it is easy to see that it will only trigger when the mouse is no longer over the circle.
</p>
<p>
<pre><code class="javascript">d3.selectAll("circle")
    .on("mouseout", function(d, i) { alert("is tasty!"); });</code></pre>
  </p>
<p>
We use the string "mouseout" as the event when the mouse is no longer over the element we have defined the event listener for.
  </p>
<p>
Each time the mouseout event is triggered, each element will alert us with a string of "is tasty".
</p>
<br>
<p>
Let's try it out by mousing over and then moving the mouse away from the circles.
</p>
<p>
BROWSER mouse over a circle
</p>
<p>
BROWSER press enter.
</p>
<p>
BROWSER mouse away from a circle
</p>
<p>
BROWSER press enter.
  </p>
<p>
As you watch the mouse go over the circle, you can see the alert pop up telling us the specific fruit the circle represents based on the data bound to the specific SVG Circle element.
  </p>
<p>
We can move the mouse anywhere on the circle and no other event will trigger.
  </p>
<p>
When we finally move the mouse away from the circle, a new event triggers which has the anonymous function alert us with the string "is tasty".
  </p>
<p>
With these types of interactions, you can see how this can lead to very interactive data visualizations.
</p>
<br>
<p>
Now that we have worked through adding events listeners to various DOM elements, let's take a closer look at the actual event that is moving through the capture and bubbling phase.
</p>
<br>
<br>
<p>
<strong>
D3.event
</strong>
</p>
<br>
<p>
DOM Event Properties
</p>
<p>
The Document Object Model Event, when triggered, has a number of event properties that are helpful in different types of scenarios.
</p>
<p>
Some of these properties include the following:
</p>
<p>
A time stamp of when the event occurred
</p>
<p>
The horizontal coordinate of the event relative to the whole document
</p>
<p>
The vertical coordinate of the event relative to the whole document 
</p>
<p>
And other properties that help answer questions like 
</p>
<p>
What is the type of the event?
</p>
<p>
Which DOM element is the target of the event?
</p>
<p>
Which key was pressed during the event?
</p>
<p>
Which mouse button was pressed during the event?
</p>
<p>
and What was the mouse position during the event?
</p>
<br>
<p>
</p>
<p>
D3 captures an event when it happens and stores it in the variable d3.event.
        - d3.event
</p>
<p>
This is a global variable that can be used in the event listener callback function registered with the d3 selection dot on operator.
</p>
<p>
After the JavaScript callback function has finished running, the current d3.event is reset.
</p>
<br>
<p>
 </p>
<p>
There are a variety of reasons you may want to capture event properties.
</p>
<p>
<pre><code class="javascript">d3.event.pageX

d3.event.pageY</code></pre>
  </p>
<p>
One that comes up frequently is building tool tips.
  </p>
<p>
In order to build a tool tip, we have to know the x and y over the event that happened, so that we can build the tool tip close to the DOM element.
</p>
<p>
From the current event object we can extract the X and Y coordinates of the event.
</p>
<p>
These X and Y coordinates are where the event happened, which means it is where the mouse currently is.
</p>
<p>
This is useful when we are making a tool tip to show the data of a specific element.
</p>
<br>
<p>
D3 selection.on()
</p>
<p>
<pre><code class="javascript">d3.event // <--- GLOBAL VARIABLE
// d, i, this AND event</code></pre>
</p>
<p>
Going back to the D3 selection.on method.
</p>
<p>
It is important to emphasize that because the d3.event is a global variable, that we can use the event within the functions we define for when an event triggers. 
</p>
<br>
<p>
Continuing with our three circles, let's work on getting the pageX and pageY properties out of the event.
</p>
<p>
First though - let's cover how we can "delete" an eventListener.
</p>
<p>
That is, how can we use D3 to turn off an event we no longer want.
</p>
<p>
In this case, we want to turn off the "mouseout" event.
</p>
<br>
<p>
The way to do this with D3 is to pass the null object as the function for the eventListener type.
</p>
<p>
<pre><code class="javascript">circles
    .on("mouseout",null);</code></pre>
</p>
<p>
BROWSER - mouse over a circle
</p>
<p>
BROWSER - press okay on the alert box
</p>
<p>
BROWSER - mouse out of the circle
</p>
<p>
BROWSER - repeat with each circle.
</p>
<p>
You saw the event when we moved the mouse over the circle.
</p>
<p>
However, when we moved the mouse away from the circle, nothing happened.
</p>
<p>
So you can see that the way to "delete" or "turn off" an event is to redefine it with the null object.
</p>
<br>
<p>
Alright, now that we only have the mouseover event, let's extract an event property from it.
</p>
<br>
<p>
We will redefine the "mouseover" eventListener to alert us of the x and y coordinate the event occurred at.
</p>
<p>
<pre><code class="javascript">circles
    .on("mouseover", function(d, i) {
        alert("event happened at x:"+ event.pageX + " y:"+ event.pageY);
    });</code></pre>
</p>
<p>
BROWSER - go in and out of the circles.
</p>
<p>
You can see that every time we mouseover a circle, we get an alert as we did before.
</p>
<p>
This time however, we are getting the x and y coordinates for where the event happened.
</p>
<br>
<p>
So you can see that not only can you define event listeners within the actual functions, we can use the event object as well.
</p>
        </div>
      </div>
        
    </div>

<hr>
<h3 id="lesson54">D3 Transition Events<h3>
    <div>

        <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li> d3.selection.on(type[, listener[, capture]]) adds an event listener to each element in the current selection</li>
<li> D3 invokes the listener in the same way it invokes other D3 operator functions - by passing the current datum "d", index "i", and the "this" context as the current DOM element</li>
<li>When a new D3 transition starts, it cancels any prior transitions, even those that were scheduled but have not yet been run</li>
<li>D3 allows you to construct multi-stage transitions through the use of the chain syntax</li>
<li>As long as D3 transitions are chained to another D3 transition on the same JavaScript command, D3 does the hard work of tie-ing the transitions together so they will be seen as one multiple-stage transitionexecuting one right after another</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/introduction-to-javascript">Introduction to JavaScript</a></li>
<li><a href="https://www.dashingd3js.com/lessons/javascript-callback-functions">JavaScript Callback Functions</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-transition-basics">D3 Transition Basics</a></li>
<li><a href="https://www.dashingd3js.com/lessons/dom-event-model-and-javascript">DOM Event Model and JavaScript</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-and-dom-events">D3 and DOM Events</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 Transition Events
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
Transition End Event
</strong>
</p>
<br>
<p>
For this example, we will have the SVG Rectangle increase it's height from 100 to 300.
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("rect");

d3.select("rect")
    .attr("x", "25")
    .attr("y", "25")
    .attr("width", "50")
    .attr("height", "100");

d3.select("rect").transition().attr("height","300");</code></pre>
</p>
<p>
This will elongate the rectangle along the Y-Axis.
</p>
<p>
Because we do not specify a delay or duration, the animation will start immediately and take 250 milliseconds.
</p>
<br>
<p>
Rectangle Animation Example - Increase Height and Width
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("rect");

d3.select("rect")
    .attr("x","25")
    .attr("y","25")
    .attr("width","50")
    .attr("height","100");

d3.select("rect")
    .transition()
    .attr("width", "300")
    .duration(3000);</code></pre>
</p>
<p>
For this example, we will have the SVG Rectangle increase it's width from 50 to 300.
</p>
<p>
This will elongate the rectangle along the X-Axis.
</p>
<p>
We also add a transition duration to slow down the transition so that we can take a look at it.
</p>
<br>
<p>
We start with a blank document with the D3.js library loaded into it
</p>
<br>
<p>
First, we create the SVG Viewport and add the SVG Rectangle.
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("rect");</code></pre>
</p>
<p>
BROWSER - Click into the body / svg element and highlight the rectangle.
</p>
<p>
You can see the rectangle in the Chrome Developer Tools Section
</p>
<br>
<p>
Next, we add the attribute, value pairs to the rectangle to have the webpage show the SVG rectangle.
</p>
<p>
<pre><code class="javascript">d3.select("rect")
    .attr("x","25")
    .attr("y","25")
    .attr("width","50")
    .attr("height","100");</code></pre>
</p>
<p>
BROWSER - Click into the body / svg element and highlight the rectangle.
</p>
<p>
You can see the actual rectangle in the webpage as well as the Chrome Developer Tools Section.
</p>
<br>
<p>
Lastly, we apply the rectangle animation transition where the width and height increase.
</p>
<p>
<pre><code class="javascript">d3.select("rect")
    .transition()
        .attr("height", "300")
        .attr("width", "300")
        .duration(3000);</code></pre>
</p>
<p>
You saw the rectangle transition from being a small rectangle to a large square.
</p>
<p>
This has been a big step forward towards making data visualizations interactive.
</p>
<p>
This one transition is able to modify two properties of the rectangle at the same time.
</p>
<p>
What if we want to modify one property first and then a second property after that?
</p>
<br>
<p>
Only one transition per element may be active at any given time.
</p>
<p>
D3 is built so that only one transition per element may be active at any given time.
</p>
<br>
<p>
Not only that, if a newer transition runs on a given element, it cancels any prior transitions.
</p>
<p>
<pre><code class="javascript">d3.select("rect")
    .transition()
        .attr("height", "300")
        .attr("width", "300")
        .duration(3000);

d3.select("rect")
    .transition()
        .attr("height", "40")
        .attr("width", "40")
        .duration(3000);</code></pre>
</p>
<p>
Even those that were scheduled but have not yet run.
</p>
<p>
Which means that in the example on the screen, the expansion transition will be canceled.
</p>
<br>
<p>
Let's reset the browser and do the two transitions to see how one cancels the second one.
</p>
<br>
<p>
First we create the svg rectangle and define it's attribute/value pairs.
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("rect");

d3.select("rect")
    .attr("x","25")
    .attr("y","25")
    .attr("width","50")
    .attr("height","100");</code></pre>
</p>
<br>
<p>
Next, we will start the first transition.
</p>
<br>
<p>
Then during the transition we will quickly start the second transition before the first transition has ended.
</p>
<br>
<p>
What this should do is cancel the first transition and run the second transition from wherever the first transition currently is.
</p>
<br>
<p>
Let's start the first transition
</p>
<p>
<pre><code class="javascript">d3.select("rect")
    .transition()
        .attr("height","300")
        .attr("width", "300")
        .duration(3000);</code></pre>
</p>
<br>
<p>
Now, quickly the second
</p>
<p>
<pre><code class="javascript">d3.select("rect")
    .transition()
        .attr("height", "40")
        .attr("width", "40")
        .duration(3000);</code></pre>
</p>
<p>
What you should have seen is the rectangle slowly expanding outward and then as soon as we started the second transition, the expansion should have stopped and then suddenly the rectangle should have shrunk.
</p>
<p>
This is how D3 behaves when you try to create two transitions on the same element one right after another
</p>
<p>
How then can we have two transitions on the same element?
</p>
<p>
To the case earlier how do we alter the height first and then alter the width second of the rectangle?
</p>
<p>
Or in this case, how do we get the rectangle to expand fully and then contract afterwards.
</p>
<br>
<p>
In order to stage the order of transitions we go back to the D3 Transition Life-cycle.
</p>
<br>
<p>
d3.selection.transition
</p>
<ul>
<li>Transition Scheduled</li>
<li>Transition Starts</li>
<li>Transition Runs</li>
<li>Transition Ends</li>
</ul>
</p>
<p>
The life cycle of a D3 transition is broken down into four separate phases.
</p>
<p>
Because transitions happen over time, there is a sequence of recurring callbacks.
</p>
<p>
Each phase starts when the previous phase has ended.
</p>
<p>
During the transition end of the life-cycle, D3 invokes an end event.
</p>
<p>
It is this end event that can allow us to build multi-stage transitions.
</p>
<br>
<p>
The D3 selection dot on method adds an event listener to each element in the current selection.
</p>
<p>
<pre><code class="javascript">target.addEventListener(type, listener[, useCapture]);

d3.selection.on(type[, listener[, capture]])</code></pre>
</p>
<p>
In the case of transitions, we can have D3 listener for the "end event" of a transition.
</p>
<br>
<p>
In this example, we create the SVG rectangle and define it's attribute, value pairs.
</p>
<p>
<pre><code class="javascript">d3.select("rect")
    .transition()
        .attr("height", "300")
        .attr("width", "300")
        .duration(3000)
        .each("end", function() {           // ### HIGHLIGHT ###
            d3.select(this)                 // ### HIGHLIGHT ###
                .transition()               // ### HIGHLIGHT ###
                    .attr("height", "40")   // ### HIGHLIGHT ###
                    .attr("width", "40")    // ### HIGHLIGHT ###
                    .duration(3000);        // ### HIGHLIGHT ###
        });</code></pre>
</p>
<p>
Then we define the same transition we have been using all along - basically that the rectangle will expand.
</p>
<p>
What is new this time, is the .each section that is highlighted.
</p>
<p>
Here, for each element in the selection, we are going to listen to the "end" event from the transition.
</p>
<p>
Once this happens, we will run the callback function we are defining here.
</p>
<p>
Let's take a closer look
</p>
<br>
<p>
The first line is the each method that will apply a function to each element in the selection.
</p>
<p>
<pre><code class="javascript">.each("end", function() {           // ### HIGHLIGHT ###
    d3.select(this)                 // ### HIGHLIGHT ###
        .transition()               // ### HIGHLIGHT ###
            .attr("height", "40")   // ### HIGHLIGHT ###
            .attr("width", "40")    // ### HIGHLIGHT ###
            .duration(3000);        // ### HIGHLIGHT ###
});</code></pre>
</p>
<p>
The second line creates a new D3 selection using the "this" variable.
</p>
<p>
Recall that in D3 methods, the three variables that are available to us are the "d" for the datum attached to the element, the "i" for the index of the element in the selection and the "this" JavaScript variable for the actual DOM element.
</p>
<p>
Using this new selection, we define a transition to shrink the rectangle SVG shape over the period of 3 seconds to a smaller shape.
</p>
<br>
<p>
Using a reset browser, let's take a look at the effect.
</p>
<br>
<p>
First we create the svg rectangle and define it's attribute/value pairs.
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("rect");

d3.select("rect")
    .attr("x","25")
    .attr("y","25")
    .attr("width","50")
    .attr("height","100");</code></pre>
</p>
<br>
<p>
Next, we start the first transition which, when it is done will trigger the second transition.
</p>
<p>
<pre><code class="javascript">d3.select("rect")
    .transition()
        .attr("height", "300")
        .attr("width", "300")
        .duration(3000)
        .each("end", function() {       
            d3.select(this)             
                .transition()             
                    .attr("height", "40")    
                    .attr("width", "40")     
                    .duration(3000);        
        });</code></pre>
</p>
<p>
And with that command you should have seen the first transition occur fully, then the second transition occur fully right after the first transition.
</p>
<p>
Which works well and is exactly what we wanted.
</p>
<p>
The only new thing that we had to add was listening to the "end" event of the transition and using the "this" variable inside of the D3 each method to create a new D3 selection for the second transition.
</p>
<br>
<p>
What if we want to add another transition after these two transitions?
</p>
<br>
<p>
To add another transition after the two transitions, we would just add an event listener to the second transition that listen for the "end" event for the second transition.
</p>
<p>
<pre><code class="javascript">.each("end", function() {
    d3.select(this)
        .transition()
            .attr("height", "40")
            .attr("width", "40")
            .duration(3000)
            .each("end",......);
});</code></pre>
</p>
<p>
To add a fourth transition, we would just have to do the same thing.
</p>
<p>
As you can imagine, this would quickly become unreadable due to the nested nature of inserting transitions in each of the dot each methods.
</p>
<p>
Luckily for us, D3 allows us to approach the issue of multi-stage transitions another way.
</p>
<br>
<br>
<p>
<strong>
Transition Animation Chains
</strong>
</p>
<br>
<p>
With this code we define a rectangle.
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("rect");

d3.select("rect")
    .attr("x","25")
    .attr("y","25")
    .attr("width","50")
    .attr("height","100");

d3.select("rect")
    .transition()
        .attr("height","300")
        .attr("width", "300")
        .duration(3000);</code></pre>
</p>
<p>
Then the height and width are transitioned at the same time.
</p>
<p>
In the previous section we covered how if we wanted to do one transition first and then another, we would have to attach an event listener to each element of the selection.
</p>
<p>
This event listener would listen for the event "end" after which it would then start the new transition.
</p>
<br>
<p>
When D3 version 3.0 came out, transition chaining supplanted creating a new transition inside of the "end" event listener.
</p>
<p>
d3.v3 => transition chaining
</p>
<br>
<p>
This is a simple example of transition chaining.
</p>
<p>
<pre><code class="javascript">d3.select("rect")
    .transition()
        .attr("height","300")
        .duration(3000)
    .transition()
        .attr("width", "300")
        .duration(3000);</code></pre>
   </p>
<p>
As long as the transition is chained to another transition on the same JavaScript command, D3 does the hard work of tie-ing the transitions together so that they will be seen as one multiple transition.
</p>
<br>
<p>
This more complicated example does 4 transitions in a row one after another.
</p>
<p>
<pre><code class="javascript">d3.select("rect")
    .transition()
        .attr("height","300")
        .duration(3000)
    .transition()
        .attr("width", "300")
        .duration(3000)
    .transition()
        .attr("height", "40")
        .duration(3000)
    .transition()
        .attr("width", "40")
        .duration(3000);</code></pre>
</p>
<p>
By doing this we stay away from the jumble that "end" event listeners would have created.
</p>
<br>
<p>
This example does 2 transitions in a row one after another.
</p>
<p>
<pre><code class="javascript">d3.select("rect")
    .transition()
        .attr("height","300")
        .attr("fill", "green")
        .duration(3000)
    .transition()
        .attr("width", "300")
        .attr("fill", "red")
        .duration(3000);</code></pre>
</p>
<p>
What is different about this example is that each transition changes two attributes at the same time.
</p>
<p>
So the first transition changes the height of the rectangle and the color at the same time.
</p>
<p>
While the second transition changes the width of the rectangle as well as the color at the same time.
</p>
<p>
This should show you that you can make each individual transition as complicated as possible.
</p>
<p>
And still be able to chain the transitions.  
</p>
<br>
<p>
This example shows you that you can use functions within the transitions just like we have before.
</p>
<p>
<pre><code class="javascript">d3.select("rect")
    .transition()
        .attr("height", function(d, i) { return i + 150; })
        .duration(3000)
    .transition()
        .attr("width", function(d, i) { return i + 150; })
        .duration(3000);</code></pre>
</p>
<p>
Here we use the i index, though we could have used the d datum inside of the function if the elements had data bound to them.
</p>
<p>
The transition will change the height first and then the width.
</p>
<p>
In each case, it will add the index number (which is zero) to 150.  
</p>
<br>
<p>
Let's take a look at these examples in the JavaScript Console.
</p>
<br>
<p>
For the first example, we create the SVG Rectangle
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").append("rect");

d3.select("rect")
    .attr("x", "25")
    .attr("y", "25")
    .attr("width", "50")
    .attr("height", "100");</code></pre>
</p>
<br>
<p>
Next we run the simple transition:
</p>
<p>
<pre><code class="javascript">d3.select("rect")
    .transition()
        .attr("height","300")
        .duration(3000)
    .transition()
        .attr("width", "300")
        .duration(3000);</code></pre>
</p>
<p>
We see the rectangle height increase first over the span of 3 seconds.
</p>
<p>
Then we see the width increase over the span of 3 seconds once the rectangle height has stopped increasing.
</p>
<br>
<p>
Next, let's run the more complicated example that has 4 different transitions.
</p>
<p>
<pre><code class="javascript">d3.select("rect")
    .attr("x","25")
    .attr("y","25")
    .attr("width","50")
    .attr("height","100");  

d3.select("rect")
    .transition()
        .attr("height","300")
        .duration(3000)
    .transition()
        .attr("width", "300")
        .duration(3000)
    .transition()
        .attr("height", "40")
        .duration(3000)
    .transition()
        .attr("width", "40")
        .duration(3000);</code></pre>
</p>
<p>
We see the rectangle height increase first over the span of 3 seconds.
</p>
<p>
We then see the rectangle width increase over the span of 3 seconds.
</p>
<p>
We then see the rectangle height decrease over the span of 3 seconds.
</p>
<p>
And lastly, we then see the rectangle width decrease over the span of 3 seconds.
</p>
<br>
<p>
Next, let's run the transition example that changes two attributes per each transition:
</p>
<p>
<pre><code class="javascript">d3.select("rect")
    .transition()
        .attr("height", "300")
        .attr("fill", "green")
        .duration(3000)
    .transition()
        .attr("width", "300")
        .attr("fill", "red")
        .duration(3000);</code></pre>
</p>
<p>
We see the rectangle height and color fill change at the same time over a span of 3 seconds.
</p>
<p>
We then see the rectangle width and color fill change at the same time over the span of 3 seconds right after the first transition is done.
</p>
<br>
<p>
Finally, we run the transition example that uses formulas in the attribute method for each chained transition.
</p>
<p>
<pre><code class="javascript">d3.select("rect")
    .attr("x", "25")
    .attr("y", "25")
    .attr("width", "50")
    .attr("height", "100")
    .attr("fill", "black");

d3.select("rect")
    .transition()
        .attr("height", function(d, i) { return i + 150; })
        .duration(3000)
    .transition()
        .attr("width", function(d, i) { return i + 150; })
        .duration(3000);</code></pre> 
</p>
<p>
We see the height change over the span of 3 seconds.
</p>
<p>
We then see the width change over the span of 3 seconds.
</p>
<p>
Noticing of course, the height defined and the width defined were the result of an anonymous function in the attribute definition section of the transition.
</p>
<br>
<p>
Which is fantastic because we now know how to chain multiple transitions so that they execute one right after another and know that we can create complicated transitions easily.
</p>
<br>
<p>
Let's go through one final example to show you many chained transitions based on data.
</p>
<br>
<p>
First we create the data
</p>
<p>
<pre><code class="javascript">var circleData = [ {"cx": "25", "cy": "25", "r": "5"},
                   {"cx": "50", "cy": "50", "r": "5"},
                   {"cx": "75", "cy": "75", "r": "5"}];</code></pre>
</p>
<br>
<p>
Then we create the SVG Viewport
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg");</code></pre>
</p>
<br>
<p>
Then we create the circle elements
</p>
<p>
<pre><code class="javascript">d3.select("svg")
    .selectAll("circle")
    .data(circleData)
  .enter()
    .append("circle");</code></pre>
</p>
<br>
<p>
Then we define the attributes for the circle elements
</p>
<p>
<pre><code class="javascript">d3.selectAll("circle")
    .attr("cx", function(d, i) { return (i * 25) + 25; })
    .attr("cy", function(d, i) { return (i * 25) + 25; })
    .attr("r",  function(d, i) { return 5 });</code></pre>
</p>
<br>
<p>
Then we define a crazy function:
</p>
<p>
<pre><code class="javascript">function crazyFunction(d, i) { 
    d3.select(this)
        .transition().attr("r", "25").attr("fill", "yellow")      
        .transition().attr("r", "5").attr("fill", "black")
        .transition().attr("cx", "100")
        .transition().attr("cy", "100")
        .transition()
            .attr("cx", function(d, i) { return d.cx })
            .attr("cy", function(d, i) { return d.cy })
            .attr("fill", "blue")
        .transition()
            .attr("stroke-width", "2")
            .attr("stroke","red");
}</code></pre>
</p>
<p>
This will be our function that details all of our transitions
</p>
<p>
Note that this changes the radius, the cx, the cy, the fill, the stroke and the stroke width of the circle.
</p>
<br>
<p>
Lastly, combining this video with the last video, we will trigger the transition when the circle gets a mouse over event.
</p>
<p>
<pre><code class="javascript">d3.selectAll("circle").on("mouseover", crazyFunction);</code></pre>
</p>
<br>
<p>
Now, when we mouse over each circle, we get to see the series of transitions in action!
</p>
<p>
BROWSER - mouse over the circles a few times.
</p>
<br>
<p>
And with that we have covered D3 transition chaining, how to use DOM events to trigger transitions and shown how we can add many transitions together while having varying attributes of an element all transition at the same time as well.
</p>
        </div>
      </div>
        
        
        
    </div>

<h3 id="lesson55">D3 Event Action At A Distance<h3>
    <div>
         <!-- DashingD3js.com Lesson Takeaways
    ================================================== -->
      <div id="wistia_video_takeaway" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Takeaways:</span>
          </strong>
        </div>
        <div id="lesson-takeaway" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<ul>
<li>d3.selection.on(type[, listener[, capture]]) adds an event listener to each element in the current selection</li>
<li>D3 invokes the listener in the same way it invokes other D3 operator functions - by passing the current datum "d", index "i", and the "this" context as the current DOM element</li>
<li>In most cases, when this happens, you will want to trigger some type of functionality that is directly related to the element that received the event</li>
<li>Since the JavaScript callback function allows you to run any code, you can also create new SVG DOM elements on the event trigger</li>
<li>Finally, not only can you interact with the element that received the event, as well as create, modify, and remove new elements, you can also interact with any other element you already have in your data visualization (as long as you can create a D3 selection of it)</li>
</ul>
</p>
        </div>
      </div>


    <!-- DashingD3js.com Lesson Video Resources
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;">
        <div style="font-size:1.75em;">
          <strong>
            <span class="text-primary">Resources:</span>
          </strong>
        </div>
        <div id="lesson-resources" style="font-size:1.25em;padding-top:1%;padding-left:2%;padding-right:2%;">
          <p>
<strong>
D3 Video Tutorial Lessons:
</strong>
</p>
<p>
<p>
<ul>
<li><a href="https://www.dashingd3js.com/lessons/d3-transition-basics">D3 Transition Basics</a></li>
<li><a href="https://www.dashingd3js.com/lessons/dom-event-model-and-javascript">DOM Event Model and JavaScript</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-and-dom-events">D3 and DOM Events</a></li>
<li><a href="https://www.dashingd3js.com/lessons/d3-transition-events">D3 Transition Events</a></li>
</ul>
</p>
        </div>
      </div>

    <!-- Data Science Tutorial Video Lesson Transcript
    ================================================== -->
      <div id="wistia_video_resources" class="col-lg-12 well" style="background:white;margin-bottom:0px;">
        <div style="font-size:2em;">
          <strong>
              <span class="text-primary">Transcript:</span>
            <br>
            <br>
            D3 Event Action At A Distance
          </strong>
        </div>
        <br>
        <div id="lesson-transcript" style="font-size:1.25em;padding-top:15px;">
          <p>
<strong>
Event Action For This Element
</strong>
</p>
<br>
<p>
This defines an event listener in D3.
</p>
<p>
<pre><code class="javascript">d3.selection
    .on(....);</code></pre>
</p>
<p>
Every element in the selection is given an event listener.
</p>
<p>
In the event listener we can ask it to listen to a mouse on, mouse out, mouse over and other events.
</p>
<p>
In most cases, when this happens, we will want to trigger some type of functionality that is directly related to the element that received the event.
</p>
<br>
<p>
Let's create four rectangles based on our data.
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").attr("width", "300").attr("height", "300");

var rectData = [{"x": 5, "y": 25,  "height": 50, "width": 50, "color": "#1f77b4"},
                {"x": 5, "y": 100, "height": 50, "width": 50, "color": "#ff7f0e"},
                {"x": 5, "y": 175, "height": 50, "width": 50, "color": "#2ca02c"},
                {"x": 5, "y": 250, "height": 50, "width": 50, "color": "#d62728"}];

var rects = d3.select("svg").selectAll("rect").data(rectData).enter().append("rect");

rects
    .attr("x",      function(d, i) { return d.x;      })
    .attr("y",      function(d, i) { return d.y;      })
    .attr("width",  function(d, i) { return d.width;  })
    .attr("height", function(d, i) { return d.height; });</code></pre>
</p>
<p>
We create the SVG Viewport with a height and width.
</p>
<p>
Then we use the D3 pattern to bind data to the SVG rectangle elements.
</p>
<p>
Then we use the bound data to define the attributes of the rectangles.
</p>
<p>
For now, we ignore the color.
</p>
<br>
<p>
For each of these rectangles we add a mouse over event listener.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {
        d3.select(this)
            .transition()
                .attr("width", "300")
                .transition()
                .attr("width", "50")
    });</code></pre>
</p>
<p>
When we mouse over the rectangle, it will increase it's width to 300.
</p>
<p>
Then with the use of a chained transition, it will then decrease it's width back to 50, which was where it started.
</p>
<br>
<p>
The code on the screen is how we select the element that we are currently on to be able to apply the transitions to it.
</p>
<p>
<pre><code class="javascript">d3.select(this)</code></pre>
</p>
<p>
This is how we are able to apply the transition we are using to only the element we are currently interacting with.
</p>
<br>
<p>
We can also change multiple attributes of an element during one transition and then with the transition chaining, do another set of multiple transitions.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {
        d3.select(this)
            .transition()
                .attr("width", "300")
                .style("fill", "green")
            .transition()
                .attr("width", "50")
                .style("fill", "black")
    });</code></pre>
</p>
<p>
In this case each rectangle when moused over, will increase it's width while changing it's color linearly from black to green.
</p>
<p>
Then, when the first transition is done, it will decrease it's width while changing it's color linearly from green to black.
</p>
<br>
<p>
We can also transition attributes of the Element that are normally associated with CSS, like opacity.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect").on("mouseover", function(d, i) {
    d3.select(this)
        .transition()
            .attr("width", "300")
            .style("fill", "green")
        .transition()
            .attr("width", "50")
            .style("fill", "black")
        .transition()
            .attr("opacity", "0")
            .transition()
            .attr("opacity", "1")
});</code></pre>
</p>
<p>
After the width and color have expanded and changed to green and then back to the black original rectangle, the opacity attribute will make it seem like the rectangle disappears and then reappears.
</p>
<br>
<p>
Let's run the examples in the JavaScript Console.
</p>
<br>
<p>
We start with a browser that has the D3.js library imported from d3js.org
</p>
<br>
<p>
We first define the SVG container
</p>
<p>
<pre><code class="javascript">var svg = d3.select("body").append("svg").attr("width", "300").attr("height", "300");</code></pre>
</p>
<br>
<p>
Then we define the data, which is an array of JavaScript object literals
</p>
<p>
<pre><code class="javascript">var rectData = [{"x": 5, "y": 25,  "height": 50, "width": 50, "color": "#1f77b4"},
                {"x": 5, "y": 100, "height": 50, "width": 50, "color": "#ff7f0e"},
                {"x": 5, "y": 175, "height": 50, "width": 50, "color": "#2ca02c"},
                {"x": 5, "y": 250, "height": 50, "width": 50, "color": "#d62728"}];</code></pre>
</p>
<br>
<p>
Then we create the SVG rectangles
</p>
<p>
<pre><code class="javascript">var rects = svg.selectAll("rect").data(rectData).enter().append("rect");</code></pre>
</p>
<br>
<p>
Finally, we define the attributes of the SVG rectangles based on the data that was bound to each one.
</p>
<p>
<pre><code class="javascript">rects
    .attr("x",      function(d, i) { return d.x;      })
    .attr("y",      function(d, i) { return d.y;      })
    .attr("width",  function(d, i) { return d.width;  })
    .attr("height", function(d, i) { return d.height; });</code></pre>
</p>
<p>
BROWSER - open up the elements section to see the rectangles.
</p>
<p>
You can now see each rectangle on the webpage and in the Chrome Developer Tools Elements Section.
</p>
<br>
<p>
Now, let's define the first mouse over function which increases and decreases the width of each rectangle when it is moused over.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {
        d3.select(this)
            .transition()
                .attr("width", "300")
                .transition()
                .attr("width", "50")
    });</code></pre>
</p>
<p>
BROWSER - mouse over the rectangles once up and once down.
</p>
<p>
When I mouse over the rectangles you can see their width increase and their width decrease.
</p>
<p>
Each rectangle experiences a change only when I have the mouse over it.
</p>
<p>
None of the other rectangles experience a change.
</p>
<br>
<p>
Next, let's define the second mouse over function which increases and decreases the width of each rectangle while also changing the fill color from black to green when it is moused over.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {
        d3.select(this)
            .transition()
                .attr("width", "300")
                .style("fill", "green")
            .transition()
                .attr("width", "50")
                .style("fill", "black")
    });</code></pre>
</p>
<p>
BROWSER - mouse over the rectangles once up and once down.
</p>
<p>
Remember that when we define a new mouseover event listener that it overwrites the old event listener.
</p>
<p>
When I mouse over the rectangles you can see their width and color change.
</p>
<p>
Each rectangle experiences a change only when I have the mouse over it.
</p>
<p>
None of the other rectangles experience a change.
</p>
<br>
<p>
Finally, let's define the third mouse over function which increases and decreases the width of each rectangle while also changing the fill color from black to green and then changes its opacity after it's done changing the width.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {
        d3.select(this)
            .transition()
                .attr("width", "300")
                .style("fill", "green")
            .transition()
                .attr("width", "50")
                .style("fill", "black")
            .transition()
                .attr("opacity", "0")
                .transition()
                .attr("opacity", "1")
    });</code></pre>
</p>
<p>
BROWSER - mouse over the rectangles once up and once down slow and then fast.
</p>
<p>
When I mouse over the rectangles you can see their width, color and opacity change.
</p>
<p>
Each rectangle experiences a change only when I have the mouse over it.
</p>
<p>
None of the other rectangles experience a change.
</p>
<br>
<p>
Which is great - through the use of the mouseover event we are able to change different attributes of the rectangle.
</p>
<br>
<p>
In addition to changing attributes of the rectangle, we can also use event listeners to create new svg elements.
</p>
<br>
<br>
<p>
<strong>
Event Creates New SVG Element
</strong>
</p>
<br>
<p>
Using the same four rectangles and data as before, this time we'll create a new rectangle.
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").attr("width", "300").attr("height", "300");

var rectData = [{"x": 5, "y": 25,  "height": 50, "width": 50, "color": "#1f77b4"},
                {"x": 5, "y": 100, "height": 50, "width": 50, "color": "#ff7f0e"},
                {"x": 5, "y": 175, "height": 50, "width": 50, "color": "#2ca02c"},
                {"x": 5, "y": 250, "height": 50, "width": 50, "color": "#d62728"}];

var rects = d3.select("svg").selectAll("rect").data(rectData).enter().append("rect");

rects
    .attr("x",      function(d, i) { return d.x;      })
    .attr("y",      function(d, i) { return d.y;      })
    .attr("width",  function(d, i) { return d.width;  })
    .attr("height", function(d, i) { return d.height; });</code></pre>
</p>
<br>
<p>
We already know how to create a rectangle on the screen.
</p>
<p>
<pre><code class="javascript">d3.select("svg").append("rect")
    .attr("x",...)
    .attr("y",...)
    .attr("width",...)
    .attr("height",...);</code></pre>
</p>
<p>
We select the SVG container or the SVG Group element where we want the rectangle to live in and append the SVG Rectangle keyword.
</p>
<p>
Then when we define the attributes, the rectangle will appear on the screen.
</p>
<br>
<p>
What we want to do now is to create a new rectangle element when a mouseover event is triggered.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {
        // create a rectangle
    });</code></pre>
</p>
<br>
<p>
Putting the two pieces of code together, we can create a new SVG rectangle when the mouse over event happens.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {
        d3.select("svg").append("rect")
            .attr("x", 80)
            .attr("y", 25)
            .attr("width", 50)
            .attr("height", 50);
    });</code></pre>
</p>
<p>
Which is fantastic - we are able to influence another SVG element by interacting with the current one.
</p>
<p>
However, as we shall see shortly in the JavaScript console, this function will create a new rectangle in the exact same place for each mouseover trigger regardless of which rectangle is triggered.
</p>
<br>
<p>
In order to create a rectangle next to the rectangle we are mousing over, we can use the current data bound to the element to figure out the X and Y coordinates.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {   
        var currentElementX = d.x;
        var currentElementY = d.y;
        d3.select("svg").append("rect")
            .attr("x",function(d, i) { return currentElementX + 50 + 25; }) // ** Highlight **
            .attr("y",function(d, i) { return currentElementY; })           // ** Highlight **
            .attr("width", 50)
            .attr("height", 50);
    });</code></pre>
</p>
<p>
Then, when we create the new rectangles, they will be created next to the rectangle we just moused over.
</p>
<p>
The X attribute of the newly created rectangle is defined by using the moused over element's X and the addition of 50 units for the width of the moused over rectangle and 25 to provide spacing.
</p>
<p>
The Y attribute of the newly create rectangle is defined using the moused over element's Y.
</p>
<p>
This ensures that the rectangle is right next to the rectangle we moused over.
</p>
<p>
However, as we shall see shortly in the JavaScript Console, this function will create a new rectangle over and over again right next to the moused over rectangle leaving us with a bunch of rectangles all spaced right on top of each other.
</p>
<p>
If we continue mousing over the four rectangles that have the mouseover listener, we will continue to pile up rectangles.
</p>
<br>
<p>
The D3 API provides a .remove operator.
</p>
<p>
<pre><code class="javascript">d3.remove()</code></pre>
</p>
<p>
It removes the elements in the current selection from the current document.
</p>
<p>
So much like we added an element when we moused over it, we can remove an element when the mouse leaves the element we just moused over.
</p>
<br>
<p>
Which brings up the question of how do we know which element to remove?
</p>
<p>
<pre><code class="javascript">d3.select("rect");

d3.selectAll("rect");

d3.select("#id");

d3.select(".class");</code></pre>
</p>
<p>
D3.select selects the first element.
</p>
<p>
D3.selectAll selects all the elements.
</p>
<p>
What we can do is use the CSS3 selectors provided to us by D3.
</p>
<p>
This will allow us to create an element with a specific id.
</p>
<p>
Then, we can later use this id to remove the element.
</p>
<br>
<p>
We update the mouseover function and add an attribute called id and a value of "removeMe".
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {   
        var currentElementX = d.x;
        var currentElementY = d.y;
        d3.select("svg").append("rect")
            .attr("x",function(d, i) { return currentElementX + 50 + 25; }) // ** Highlight **
            .attr("y",function(d, i) { return currentElementY; })           // ** Highlight **
            .attr("width", 50)
            .attr("height", 50)
            .attr("id", "removeMe");
    });</code></pre>
</p>
<p>
Now, when we mouse over a rectangle, it will create a new rectangle right next to it on the right and it will have the id of removeMe.
</p>
<br>
<p>
We now create the mouseout function.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseout", function(d, i){
        d3.select("#removeMe")
            .remove();
    });</code></pre>
</p>
<p>
When the mouseout event is triggered, we instruct D3 to select the element with an id of "removeMe".
</p>
<p>
Then we use the D3 remove operator to remove the actual element.
</p>
<p>
Because this is a mouse out event listener, as long as we hover over the rectangle the new element will exist.
</p>
<p>
As soon as we mouse out of the rectangle, the new element will be removed.
</p>
<br>
<p>
As an example the universality of adding and removing elements, let's add and remove an SVG Text Element from the screen instead of another rectangle.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {   
        var currentElementX = d.x;
        var currentElementY = d.y;
        d3.select("svg").append("text")
            .attr("x",function(d, i) { return currentElementX + 50 + 25; })
            .attr("y",function(d, i) { return currentElementY + 10; })          
            .text(d.color)
            .attr("id", "removeMe");
    });</code></pre>
</p>
<p>
In this case we are going to use the name,value pair from the data object bound to each rectangle element.
</p>
<p>
The process is the same, except that instead of appending a rectangle and it's attributes, we append an SVG text element and it's attributes.
</p>
<p>
We can leave the mouseout functionality the same, as we are still using the id "removeMe" for the element that we are adding and removing.
</p>
<br>
<p>
As a final example, we show that we can do two things at once.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {
        d3.select(this)
            .style("fill", d.color);

        var currentElementX = d.x;
        var currentElementY = d.y;
        d3.select("svg").append("text")
            .attr("x",function(d, i) { return currentElementX + 50 + 25; })
            .attr("y",function(d, i) { return currentElementY + 10; })          
            .text(d.color)
            .attr("id", "removeMe");
    });</code></pre>
</p>
<p>
In this code, we change the color of the rectangle element we are mousing over.
</p>
<p>
As well as creating a new element to the side of it that tells us the color name.
</p>
<br>
<p>
We also update the mouseout functionality to do two things as well.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseout", function(d, i){  
        d3.select(this)
            .style("fill", "black");

        d3.select("#removeMe")
            .remove();
    });</code></pre>
</p>
<p>
One - it will change the rectangle color back to black.
</p>
<p>
Two - it will remove the text element.
</p>
<p>
By going through these examples, you can see that we can make very complicated behavior happen, not only to the element we are interacting with, but also creating and modifying new elements at the same time.
</p>
<br>
<p>
Let's run the examples in the JavaScript Console.
</p>
<br>
<p>
We start with a browser that has the D3.js library imported from d3js.org
</p>
<br>
<p>
We first define the SVG container
</p>
<p>
<pre><code class="javascript">var svg = d3.select("body").append("svg").attr("width", "300").attr("height", "300");</code></pre>
</p>
<br>
<p>
Then we define the data, which is an array of JavaScript object literals
</p>
<p>
<pre><code class="javascript">var rectData = [{"x": 5, "y": 25,  "height": 50, "width": 50, "color": "#1f77b4"},
                {"x": 5, "y": 100, "height": 50, "width": 50, "color": "#ff7f0e"},
                {"x": 5, "y": 175, "height": 50, "width": 50, "color": "#2ca02c"},
                {"x": 5, "y": 250, "height": 50, "width": 50, "color": "#d62728"}];</code></pre>
</p>
<br>
<p>
Then we create the SVG rectangles
</p>
<p>
<pre><code class="javascript">var rects = svg.selectAll("rect").data(rectData).enter().append("rect");</code></pre>
</p>
<p>
BROWSER - open up the elements section to see the rectangles.
</p>
<br>
<p>
Finally, we define the attributes of the SVG rectangles based on the data that was bound to each one.
</p>
<p>
<pre><code class="javascript">rects
    .attr("x",      function(d, i) { return d.x;      })
    .attr("y",      function(d, i) { return d.y;      })
    .attr("width",  function(d, i) { return d.width;  })
    .attr("height", function(d, i) { return d.height; });</code></pre>
</p>
<p>
You can now see each rectangle on the webpage and in the Chrome Developer Tools Elements Section.
</p>
<br>
<p>
Let's define the first mouse over function which will create a new rectangle.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {
        d3.select("svg").append("rect")
            .attr("x", 80)
            .attr("y", 25)
            .attr("width", 50)
            .attr("height", 50);
    });</code></pre>
</p>
<p>
BROWSER - Mouse over the four rectangles.
</p>
<p>
BROWSER - Move mouse over to the Elements section
</p>
<p>
As I moused over the first rectangle you saw a new rectangle appear to the right of the top rectangle.
</p>
<p>
Then when I moused over the rest of the rectangles you did not see any new rectangles being created in the page, though you did see them appear in the Chrome Developer Tools Elements Section.
</p>
<p>
You can see that they are all the same rectangle.
</p>
<p>
Because we moused over four rectangles, we see four rectangles in the screen.
</p>
<br>
<p>
Let's mouse over the new rectangles
</p>
<p>
BROWSER mouse over the new rectangles
</p>
<p>
Notice that no new rectangles appear.
</p>
<p>
This is because when we define the mouseover event, we are defining the event listener on the selection at that point in time.
</p>
<p>
Because we have added a new rectangle, it will not have been part of the old selection.
</p>
<p>
This is why the new rectangle does not have a mouse over event listener that causes new rectangles to appear.
</p>
<br>
<p>
Let's clear the document of the four new rectangles.
</p>
<p>
Browser - delete four rectangles
</p>
<p>
In Chrome Developer Tools, you are able to click on an element and press the delete key.
</p>
<p>
This deletes it from the webpage.
</p>
<br>
<p>
Let's now define the mouse over function that will cause a rectangle to appear next to the rectangle we are mousing over.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {   
        var currentElementX = d.x;
        var currentElementY = d.y;
        d3.select("svg").append("rect")
            .attr("x",function(d, i) { return currentElementX + 50 + 25; })
            .attr("y",function(d, i) { return currentElementY; })          
            .attr("width", 50)
            .attr("height", 50);
    });</code></pre>
</p>
<p>
BROWSER - Mouse over the four rectangles twice
</p>
<p>
BROWSER - Move mouse over to the Elements section
</p>
<p>
This time, you can see that the four rectangles were created right next to the rectangles we are mousing over.
</p>
<p>
You also saw that because we twice moused over a rectangle with an event listener attached,we now have 8 new rectangles on the webpage.
</p>
<br>
<p>
Let's clear the document of the eight new rectangles.
</p>
<p>
Browser - delete eight rectangles
</p>
<br>
<p>
Let's now define the mouse over function that will add an id of "removeMe" to the newly created rectangle.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {   
        var currentElementX = d.x;
        var currentElementY = d.y;
        d3.select("svg").append("rect")
            .attr("x",function(d, i) { return currentElementX + 50 + 25; })
            .attr("y",function(d, i) { return currentElementY; })           
            .attr("width", 50)
            .attr("height", 50)
            .attr("id", "removeMe");
    });</code></pre>
</p>
<p>
Then we define the mouse out function that will remove the element with the id of "removeMe".
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseout", function(d, i){
        d3.select("#removeMe")
        .remove();
    });</code></pre>
</p>
<p>
BROWSER - Mouse over the four rectangles twice
</p>
<p>
This time, you can see that when we mouse over a rectangle that a new rectangle appears with the id of "removeMe".
</p>
<p>
We can see this in the Elements Section of the Developer Tools.
</p>
<p>
As long as the mouse is over the element, the new rectangle exists.
</p>
<p>
When we mouse out of the element, the new rectangle ceases to exist.
</p>
<p>
This is how we can use an event to create and destroy a new SVG element.
</p>
<br>
<p>
We don't have to clear the page of rectangles again because the mouseout functionality is doing it for us.
</p>
<br>
<p>
Next, let's show the universality of what we are doing by creating a text element with the color attached to our data objects.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {   
        var currentElementX = d.x;
        var currentElementY = d.y;
        d3.select("svg").append("text")
            .attr("x",function(d, i) { return currentElementX + 50 + 25; })
            .attr("y",function(d, i) { return currentElementY + 10; })          
            .text(d.color)
            .attr("id", "removeMe");
    });</code></pre>
</p>
<p>
BROWSER - Mouse over the four rectangles twice
</p>
<p>
You can see that it works exactly the same way.
</p>
<p>
Remember - we didn't have to change the mouseout functionality because it is removing an element with the id of "removeMe".
</p>
<p>
And since the rectangle example and the text example both create an SVG element with the id of "removeMe", we don't have to change the functionality of the mouseout listener.
</p>
<br>
<p>
We also don't have to clear the page of SVG text elements because the mouseout functionality is doing it for us.
</p>
<br>
<p>
Next, let's show that we can do two things at once.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {
        d3.select(this)
            .style("fill",d.color);

      var currentElementX = d.x;
      var currentElementY = d.y;
      d3.select("svg").append("text")
            .attr("x",function(d, i) { return currentElementX + 50 + 25; })
            .attr("y",function(d, i) { return currentElementY + 10; })          
            .text(d.color)
            .attr("id", "removeMe");
    });</code></pre>
</p>
<p>
In this code, we change the color of the rectangle element we are mousing over.
</p>
<p>
As well as creating a new element to the side of it that tells us the color name.
</p>
<br>
<p>
We also update the mouse out functionality to change the rectangle back to the color black as well as remove the text element.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseout", function(d, i){  
        d3.select(this)
            .style("fill", "black");
    
        d3.select("#removeMe")
            .remove();
    });</code></pre>
</p>
<p>
BROWSER - Mouse over the four rectangles twice
</p>
<p>
You can see that when we mouse over the rectangle that it creates the text elements and switches the color of the rectangle to the color dictated by the data bound to the element.
</p>
<p>
Then you can see that when we mouse out of the rectangle that the text element is destroyed and the rectangle switches back to the color of black.
</p>
<br>
<p>
So far so good, we can use events to affect the element we are interacting with as well as elements that we create.
</p>
<br>
<p>
Next, let's cover how we can affect other elements that exist in the document through the interaction with one element.
</p>
<br>
<br>
<p>
<strong>
Event Affects Other SVG Elements
</strong>
</p>
<br>
<p>
Using the same four rectangles and data as before, this time we'll change the properties of other rectangles when we interact with one rectangle.
</p>
<p>
<pre><code class="javascript">d3.select("body").append("svg").attr("width", "300").attr("height", "300");

var rectData = [{"x": 5, "y": 25,  "height": 50, "width": 50, "color": "#1f77b4"},
                {"x": 5, "y": 100, "height": 50, "width": 50, "color": "#ff7f0e"},
                {"x": 5, "y": 175, "height": 50, "width": 50, "color": "#2ca02c"},
                {"x": 5, "y": 250, "height": 50, "width": 50, "color": "#d62728"}];

var rects = d3.select("svg").selectAll("rect").data(rectData).enter().append("rect");

rects
    .attr("x",      function(d, i) { return d.x;       })
    .attr("y",      function(d, i) { return d.y;       })
    .attr("width",  function(d, i) { return d.width;   })
    .attr("height", function(d, i) { return d.height;  })
    .attr("id",     function(d, i) { return "rect-"+i; });  // ** HIGHLIGHT **</code></pre>
</p>
<p>
Notice that this time, we are going to give each of the rectangles an id that belongs to them and only them.
</p>
<p>
We will use the id to select the rectangles.
</p>
<p>
First we'll cover changing one rectangle, then we'll cover changing all the rectangles.
</p>
<br>
<p>
First, we want to change only one rectangle.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {
      // change one other rectangles
      // select rectangle with id "rect-0"
      // change an attribute
    });</code></pre>
</p>
<p>
For this example, we'll want to select the first rectangle, which is the one at the top left.
</p>
<p>
So we'll have to define an event listener mouse over functionality to do this.
</p>
<br>
<p>
In the mouse over function, we select the rectangle with id "rect-0" using a CSS3 selector and style it according to the data that was bound to it.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {
        d3.select("#rect-0") // ** HIGHLIGHT **
            .style("fill",function(d, i) { return d.color; });
    });</code></pre>
</p>
<p>
Notice that the d dot color is referencing the d of the "#rect-0" selection and not the element we are mousing over.
</p>
<p>
By selecting the rectangle by it's ID, we are able to use an event to modify another element.
</p>
<br>
<p>
We also define a mouse out function to make sure that when we move the mouse away from the rectangle element we are mousing over, that the first rectangle will go back to the color black.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseout", function(d, i) {
        d3.select("#rect-0")
            .style("fill", "black");
    });</code></pre>
</p>
<br>
<p>
Using the D3 CSS3 selectors we could conceivably select any of the other rectangles as well with any type of CSS3 selector definition.
</p>
<p>
<pre><code class="javascript">d3.select("#rect-0")</code></pre>
</p>
<br>
<p>
We can also select all the rectangles and change one of their attributes when any one of the rectangles receives the mouse over event.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {
        d3.selectAll("rect")
            .style("fill",function(d, i) { return d.color; }); // ** HIGHLIGHT **
    });

d3.selectAll("rect")
    .on("mouseout", function(d, i) {
        d3.selectAll("rect")
            .style("fill", "black");
    });</code></pre>
</p>
<p>
We would have to change the mouse out event listener functionality as well to change the rectangles back.
</p>
<br>
<p>
In this example, we decrease the opacity of every rectangle using the selectAll.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {
        d3.selectAll("rect")
            .attr("opacity", "0.25");
      
        d3.select(this)
            .attr("opacity", "1")
            .style("fill", function(d, i) { return d.color; });
    });</code></pre>
</p>
<p>
Then we increase the opacity back to 1 for the element we are mousing over and change the fill color to the color found in the bound data.
</p>
<p>
In building this mouseover functionality like this, the event on one element is able affect the attributes of all the elements of the type we select.    
</p>
<br>
<p>
We also update the mouseout functionality so that it changes the opacity back to 1 for every rectangle as well as changing the fill back to black for every rectangle.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseout", function(d, i) {
        d3.selectAll("rect")
            .style("fill", "black")
            .attr("opacity", "1");
    });</code></pre>
</p>
<p>
Same as with the mouseover functionality, in building this mouseout functionality like this, the event on one element is able affect the attributes of all the elements of the type we select.
</p>
<br>
<p>
Let's run the examples in the JavaScript Console.
</p>
<br>
<p>
We start with a browser that has the D3.js library imported from d3js.org
</p>
<br>
<p>
We first define the SVG container
</p>
<p>
<pre><code class="javascript">var svg = d3.select("body").append("svg").attr("width", "300").attr("height", "300");</code></pre>
</p>
<br>
<p>
Then we define the data, which is an array of JavaScript object literals
</p>
<p>
<pre><code class="javascript">var rectData = [{"x": 5, "y": 25,  "height": 50, "width": 50, "color": "#1f77b4"},
                {"x": 5, "y": 100, "height": 50, "width": 50, "color": "#ff7f0e"},
                {"x": 5, "y": 175, "height": 50, "width": 50, "color": "#2ca02c"},
                {"x": 5, "y": 250, "height": 50, "width": 50, "color": "#d62728"}];</code></pre>
</p>
<br>
<p>
Then we create the SVG rectangles
</p>
<p>
<pre><code class="javascript">var rects = svg.selectAll("rect").data(rectData).enter().append("rect");</code></pre>
</p>
<p>
BROWSER - open up the elements section to see the rectangles.
</p>
<br>
<p>
Finally, we define the attributes of the SVG rectangles based on the data that was bound to each one.
</p>
<p>
<pre><code class="javascript">rects
    .attr("x",      function(d, i) { return d.x;         })
    .attr("y",      function(d, i) { return d.y;         })
    .attr("width",  function(d, i) { return d.width;     })
    .attr("height", function(d, i) { return d.height;    })
    .attr("id",     function(d, i) { return "rect-" + i; });</code></pre>
</p>
<p>
You can now see each rectangle on the webpage and in the Chrome Developer Tools Elements Section.
</p>
<p>
Note that this time we created the rectangles with an individual id for each one.
</p>
<br>
<p>
Let's start with the mouseover functionality that changes the color of the top rectangle.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {
        d3.select("#rect-0")
            .style("fill", function(d, i) { return d.color; });
    });</code></pre>
</p>
<p>
Note that we will be selecting the rectangle by it's id.
</p>
<br>
<p>
We also define the mouseout functionality that changes the color of the top rectangle back to black when the mouseout it triggered.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseout", function(d, i) {
        d3.select("#rect-0")
            .style("fill", "black");
    });</code></pre>
</p>
<p>
BROWSER - Mouse over the four rectangles twice
</p>
<p>
You can see the top rectangle change color as we mouseover and mouseout of any one of the four rectangles on the page.
</p>
<p>
While we are only showing the selection of one element by it's id, you can create all kinds of different effects with more complicated JavaScript functions.
</p>
<br>
<p>
Next, let's look at the example of having one event from one element trigger a change in attributes in all the elements.
</p>
<br>
<p>
We define the mouseover functionality that will change the color of all the rectangles on the screen to the respective colors as defined by the data bound to each of them.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {
        d3.selectAll("rect")
            .style("fill",function(d, i) { return d.color; });
    });</code></pre>
</p>
<br>
<p>
And, we define the mouseout functionality that will change the color of all the rectangles on the screen back to black.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseout", function(d, i) {
        d3.selectAll("rect")
            .style("fill", "black");
    });</code></pre>
</p>
<p>
BROWSER - Mouse over the four rectangles twice
</p>
<p>
You can see that all the rectangles change color as we mouseover and mouseout of any one of the four rectangles on the web page.
</p>
<p>
Just like with the specific single element selection, you can create all kinds of different effects with more complicated JavaScript functions.
</p>
<br>
<p>
Lastly, let's look at the example of having one event from one element trigger a change in attributes in all the elements as well as a change in attribute of the element receiving the event.
</p>
<br>
<p>
We define the mouse over functionality that will decrease the opacity of every rectangle while changing the color and opacity of the element that received the mouseover event.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseover", function(d, i) {
        d3.selectAll("rect")
            .attr("opacity", "0.25");

        d3.select(this)
            .attr("opacity", "1")
            .style("fill", function(d, i) { return d.color; });
    });</code></pre>
</p>
<br>
<p>
And, we define the mouseout functionality that will change the opacity back to 1 for all the elements as well as change the color of all the elements back to black.
</p>
<p>
<pre><code class="javascript">d3.selectAll("rect")
    .on("mouseout", function(d, i) {
        d3.selectAll("rect")
            .style("fill", "black")
            .attr("opacity", "1");
    });</code></pre>
</p>
<p>
BROWSER - Mouse over the four rectangles twice
</p>
<p>
You can see that all the rectangles change opacity as we mouseover and mouseout of any one of the four rectangles on the web page.
</p>
<p>
Also, notice how much more the element we are interacting with stands out, when all of the other elements have a reduced opacity.
</p>
<p>
Though we will cover this later in the data visualization theory section, this is one of the important pre-attentive properties.
</p>
<p>
When all but one element have the same type of transparency, the one element that has the different transparency will stand out.
</p>
<p>
This is very useful to communicate importance to your audience.
</p>
<p>
In building this mouseover functionality like this, the event on one element is able affect the attributes of itself as well as all of the other elements in web page.  
</p>
<br>
<p>
And with that we have covered how we can use D3 and DOM events to trigger element creation, destruction, attribute changes both for the element itself and other elements.
</p>
<p>
Additionally, we covered how an event on one element can affect 1 or more other elements on the same page. 
</p>
        </div>
      </div>
    </div>






   


        
